
zephyr.elf:     file format elf32-i386


Disassembly of section .init:

08049000 <_init>:
 8049000:	f3 0f 1e fb          	endbr32 
 8049004:	53                   	push   %ebx
 8049005:	83 ec 08             	sub    $0x8,%esp
 8049008:	e8 a3 05 00 00       	call   80495b0 <__x86.get_pc_thunk.bx>
 804900d:	81 c3 f3 7f 00 00    	add    $0x7ff3,%ebx
 8049013:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8049019:	85 c0                	test   %eax,%eax
 804901b:	74 02                	je     804901f <_init+0x1f>
 804901d:	ff d0                	call   *%eax
 804901f:	83 c4 08             	add    $0x8,%esp
 8049022:	5b                   	pop    %ebx
 8049023:	c3                   	ret    

Disassembly of section .plt:

08049030 <.plt>:
 8049030:	ff 35 04 10 05 08    	pushl  0x8051004
 8049036:	ff 25 08 10 05 08    	jmp    *0x8051008
 804903c:	0f 1f 40 00          	nopl   0x0(%eax)
 8049040:	f3 0f 1e fb          	endbr32 
 8049044:	68 00 00 00 00       	push   $0x0
 8049049:	e9 e2 ff ff ff       	jmp    8049030 <.plt>
 804904e:	66 90                	xchg   %ax,%ax
 8049050:	f3 0f 1e fb          	endbr32 
 8049054:	68 08 00 00 00       	push   $0x8
 8049059:	e9 d2 ff ff ff       	jmp    8049030 <.plt>
 804905e:	66 90                	xchg   %ax,%ax
 8049060:	f3 0f 1e fb          	endbr32 
 8049064:	68 10 00 00 00       	push   $0x10
 8049069:	e9 c2 ff ff ff       	jmp    8049030 <.plt>
 804906e:	66 90                	xchg   %ax,%ax
 8049070:	f3 0f 1e fb          	endbr32 
 8049074:	68 18 00 00 00       	push   $0x18
 8049079:	e9 b2 ff ff ff       	jmp    8049030 <.plt>
 804907e:	66 90                	xchg   %ax,%ax
 8049080:	f3 0f 1e fb          	endbr32 
 8049084:	68 20 00 00 00       	push   $0x20
 8049089:	e9 a2 ff ff ff       	jmp    8049030 <.plt>
 804908e:	66 90                	xchg   %ax,%ax
 8049090:	f3 0f 1e fb          	endbr32 
 8049094:	68 28 00 00 00       	push   $0x28
 8049099:	e9 92 ff ff ff       	jmp    8049030 <.plt>
 804909e:	66 90                	xchg   %ax,%ax
 80490a0:	f3 0f 1e fb          	endbr32 
 80490a4:	68 30 00 00 00       	push   $0x30
 80490a9:	e9 82 ff ff ff       	jmp    8049030 <.plt>
 80490ae:	66 90                	xchg   %ax,%ax
 80490b0:	f3 0f 1e fb          	endbr32 
 80490b4:	68 38 00 00 00       	push   $0x38
 80490b9:	e9 72 ff ff ff       	jmp    8049030 <.plt>
 80490be:	66 90                	xchg   %ax,%ax
 80490c0:	f3 0f 1e fb          	endbr32 
 80490c4:	68 40 00 00 00       	push   $0x40
 80490c9:	e9 62 ff ff ff       	jmp    8049030 <.plt>
 80490ce:	66 90                	xchg   %ax,%ax
 80490d0:	f3 0f 1e fb          	endbr32 
 80490d4:	68 48 00 00 00       	push   $0x48
 80490d9:	e9 52 ff ff ff       	jmp    8049030 <.plt>
 80490de:	66 90                	xchg   %ax,%ax
 80490e0:	f3 0f 1e fb          	endbr32 
 80490e4:	68 50 00 00 00       	push   $0x50
 80490e9:	e9 42 ff ff ff       	jmp    8049030 <.plt>
 80490ee:	66 90                	xchg   %ax,%ax
 80490f0:	f3 0f 1e fb          	endbr32 
 80490f4:	68 58 00 00 00       	push   $0x58
 80490f9:	e9 32 ff ff ff       	jmp    8049030 <.plt>
 80490fe:	66 90                	xchg   %ax,%ax
 8049100:	f3 0f 1e fb          	endbr32 
 8049104:	68 60 00 00 00       	push   $0x60
 8049109:	e9 22 ff ff ff       	jmp    8049030 <.plt>
 804910e:	66 90                	xchg   %ax,%ax
 8049110:	f3 0f 1e fb          	endbr32 
 8049114:	68 68 00 00 00       	push   $0x68
 8049119:	e9 12 ff ff ff       	jmp    8049030 <.plt>
 804911e:	66 90                	xchg   %ax,%ax
 8049120:	f3 0f 1e fb          	endbr32 
 8049124:	68 70 00 00 00       	push   $0x70
 8049129:	e9 02 ff ff ff       	jmp    8049030 <.plt>
 804912e:	66 90                	xchg   %ax,%ax
 8049130:	f3 0f 1e fb          	endbr32 
 8049134:	68 78 00 00 00       	push   $0x78
 8049139:	e9 f2 fe ff ff       	jmp    8049030 <.plt>
 804913e:	66 90                	xchg   %ax,%ax
 8049140:	f3 0f 1e fb          	endbr32 
 8049144:	68 80 00 00 00       	push   $0x80
 8049149:	e9 e2 fe ff ff       	jmp    8049030 <.plt>
 804914e:	66 90                	xchg   %ax,%ax
 8049150:	f3 0f 1e fb          	endbr32 
 8049154:	68 88 00 00 00       	push   $0x88
 8049159:	e9 d2 fe ff ff       	jmp    8049030 <.plt>
 804915e:	66 90                	xchg   %ax,%ax
 8049160:	f3 0f 1e fb          	endbr32 
 8049164:	68 90 00 00 00       	push   $0x90
 8049169:	e9 c2 fe ff ff       	jmp    8049030 <.plt>
 804916e:	66 90                	xchg   %ax,%ax
 8049170:	f3 0f 1e fb          	endbr32 
 8049174:	68 98 00 00 00       	push   $0x98
 8049179:	e9 b2 fe ff ff       	jmp    8049030 <.plt>
 804917e:	66 90                	xchg   %ax,%ax
 8049180:	f3 0f 1e fb          	endbr32 
 8049184:	68 a0 00 00 00       	push   $0xa0
 8049189:	e9 a2 fe ff ff       	jmp    8049030 <.plt>
 804918e:	66 90                	xchg   %ax,%ax
 8049190:	f3 0f 1e fb          	endbr32 
 8049194:	68 a8 00 00 00       	push   $0xa8
 8049199:	e9 92 fe ff ff       	jmp    8049030 <.plt>
 804919e:	66 90                	xchg   %ax,%ax
 80491a0:	f3 0f 1e fb          	endbr32 
 80491a4:	68 b0 00 00 00       	push   $0xb0
 80491a9:	e9 82 fe ff ff       	jmp    8049030 <.plt>
 80491ae:	66 90                	xchg   %ax,%ax
 80491b0:	f3 0f 1e fb          	endbr32 
 80491b4:	68 b8 00 00 00       	push   $0xb8
 80491b9:	e9 72 fe ff ff       	jmp    8049030 <.plt>
 80491be:	66 90                	xchg   %ax,%ax
 80491c0:	f3 0f 1e fb          	endbr32 
 80491c4:	68 c0 00 00 00       	push   $0xc0
 80491c9:	e9 62 fe ff ff       	jmp    8049030 <.plt>
 80491ce:	66 90                	xchg   %ax,%ax
 80491d0:	f3 0f 1e fb          	endbr32 
 80491d4:	68 c8 00 00 00       	push   $0xc8
 80491d9:	e9 52 fe ff ff       	jmp    8049030 <.plt>
 80491de:	66 90                	xchg   %ax,%ax
 80491e0:	f3 0f 1e fb          	endbr32 
 80491e4:	68 d0 00 00 00       	push   $0xd0
 80491e9:	e9 42 fe ff ff       	jmp    8049030 <.plt>
 80491ee:	66 90                	xchg   %ax,%ax
 80491f0:	f3 0f 1e fb          	endbr32 
 80491f4:	68 d8 00 00 00       	push   $0xd8
 80491f9:	e9 32 fe ff ff       	jmp    8049030 <.plt>
 80491fe:	66 90                	xchg   %ax,%ax
 8049200:	f3 0f 1e fb          	endbr32 
 8049204:	68 e0 00 00 00       	push   $0xe0
 8049209:	e9 22 fe ff ff       	jmp    8049030 <.plt>
 804920e:	66 90                	xchg   %ax,%ax
 8049210:	f3 0f 1e fb          	endbr32 
 8049214:	68 e8 00 00 00       	push   $0xe8
 8049219:	e9 12 fe ff ff       	jmp    8049030 <.plt>
 804921e:	66 90                	xchg   %ax,%ax
 8049220:	f3 0f 1e fb          	endbr32 
 8049224:	68 f0 00 00 00       	push   $0xf0
 8049229:	e9 02 fe ff ff       	jmp    8049030 <.plt>
 804922e:	66 90                	xchg   %ax,%ax
 8049230:	f3 0f 1e fb          	endbr32 
 8049234:	68 f8 00 00 00       	push   $0xf8
 8049239:	e9 f2 fd ff ff       	jmp    8049030 <.plt>
 804923e:	66 90                	xchg   %ax,%ax
 8049240:	f3 0f 1e fb          	endbr32 
 8049244:	68 00 01 00 00       	push   $0x100
 8049249:	e9 e2 fd ff ff       	jmp    8049030 <.plt>
 804924e:	66 90                	xchg   %ax,%ax
 8049250:	f3 0f 1e fb          	endbr32 
 8049254:	68 08 01 00 00       	push   $0x108
 8049259:	e9 d2 fd ff ff       	jmp    8049030 <.plt>
 804925e:	66 90                	xchg   %ax,%ax
 8049260:	f3 0f 1e fb          	endbr32 
 8049264:	68 10 01 00 00       	push   $0x110
 8049269:	e9 c2 fd ff ff       	jmp    8049030 <.plt>
 804926e:	66 90                	xchg   %ax,%ax
 8049270:	f3 0f 1e fb          	endbr32 
 8049274:	68 18 01 00 00       	push   $0x118
 8049279:	e9 b2 fd ff ff       	jmp    8049030 <.plt>
 804927e:	66 90                	xchg   %ax,%ax
 8049280:	f3 0f 1e fb          	endbr32 
 8049284:	68 20 01 00 00       	push   $0x120
 8049289:	e9 a2 fd ff ff       	jmp    8049030 <.plt>
 804928e:	66 90                	xchg   %ax,%ax
 8049290:	f3 0f 1e fb          	endbr32 
 8049294:	68 28 01 00 00       	push   $0x128
 8049299:	e9 92 fd ff ff       	jmp    8049030 <.plt>
 804929e:	66 90                	xchg   %ax,%ax
 80492a0:	f3 0f 1e fb          	endbr32 
 80492a4:	68 30 01 00 00       	push   $0x130
 80492a9:	e9 82 fd ff ff       	jmp    8049030 <.plt>
 80492ae:	66 90                	xchg   %ax,%ax
 80492b0:	f3 0f 1e fb          	endbr32 
 80492b4:	68 38 01 00 00       	push   $0x138
 80492b9:	e9 72 fd ff ff       	jmp    8049030 <.plt>
 80492be:	66 90                	xchg   %ax,%ax
 80492c0:	f3 0f 1e fb          	endbr32 
 80492c4:	68 40 01 00 00       	push   $0x140
 80492c9:	e9 62 fd ff ff       	jmp    8049030 <.plt>
 80492ce:	66 90                	xchg   %ax,%ax

Disassembly of section .plt.sec:

080492d0 <pthread_mutex_unlock@plt>:
 80492d0:	f3 0f 1e fb          	endbr32 
 80492d4:	ff 25 0c 10 05 08    	jmp    *0x805100c
 80492da:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080492e0 <__snprintf_chk@plt>:
 80492e0:	f3 0f 1e fb          	endbr32 
 80492e4:	ff 25 10 10 05 08    	jmp    *0x8051010
 80492ea:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080492f0 <__udivdi3@plt>:
 80492f0:	f3 0f 1e fb          	endbr32 
 80492f4:	ff 25 14 10 05 08    	jmp    *0x8051014
 80492fa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049300 <strcmp@plt>:
 8049300:	f3 0f 1e fb          	endbr32 
 8049304:	ff 25 18 10 05 08    	jmp    *0x8051018
 804930a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049310 <__vfprintf_chk@plt>:
 8049310:	f3 0f 1e fb          	endbr32 
 8049314:	ff 25 1c 10 05 08    	jmp    *0x805101c
 804931a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049320 <pthread_cond_broadcast@plt>:
 8049320:	f3 0f 1e fb          	endbr32 
 8049324:	ff 25 20 10 05 08    	jmp    *0x8051020
 804932a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049330 <free@plt>:
 8049330:	f3 0f 1e fb          	endbr32 
 8049334:	ff 25 24 10 05 08    	jmp    *0x8051024
 804933a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049340 <__pthread_register_cancel@plt>:
 8049340:	f3 0f 1e fb          	endbr32 
 8049344:	ff 25 28 10 05 08    	jmp    *0x8051028
 804934a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049350 <clock_gettime@plt>:
 8049350:	f3 0f 1e fb          	endbr32 
 8049354:	ff 25 2c 10 05 08    	jmp    *0x805102c
 804935a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049360 <pthread_self@plt>:
 8049360:	f3 0f 1e fb          	endbr32 
 8049364:	ff 25 30 10 05 08    	jmp    *0x8051030
 804936a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049370 <pthread_cond_wait@plt>:
 8049370:	f3 0f 1e fb          	endbr32 
 8049374:	ff 25 34 10 05 08    	jmp    *0x8051034
 804937a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049380 <sleep@plt>:
 8049380:	f3 0f 1e fb          	endbr32 
 8049384:	ff 25 38 10 05 08    	jmp    *0x8051038
 804938a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049390 <__stack_chk_fail@plt>:
 8049390:	f3 0f 1e fb          	endbr32 
 8049394:	ff 25 3c 10 05 08    	jmp    *0x805103c
 804939a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493a0 <pthread_mutex_lock@plt>:
 80493a0:	f3 0f 1e fb          	endbr32 
 80493a4:	ff 25 40 10 05 08    	jmp    *0x8051040
 80493aa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493b0 <strtoll@plt>:
 80493b0:	f3 0f 1e fb          	endbr32 
 80493b4:	ff 25 44 10 05 08    	jmp    *0x8051044
 80493ba:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493c0 <realloc@plt>:
 80493c0:	f3 0f 1e fb          	endbr32 
 80493c4:	ff 25 48 10 05 08    	jmp    *0x8051048
 80493ca:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493d0 <exit@plt>:
 80493d0:	f3 0f 1e fb          	endbr32 
 80493d4:	ff 25 4c 10 05 08    	jmp    *0x805104c
 80493da:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493e0 <__udivmoddi4@plt>:
 80493e0:	f3 0f 1e fb          	endbr32 
 80493e4:	ff 25 50 10 05 08    	jmp    *0x8051050
 80493ea:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080493f0 <strtoul@plt>:
 80493f0:	f3 0f 1e fb          	endbr32 
 80493f4:	ff 25 54 10 05 08    	jmp    *0x8051054
 80493fa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049400 <__libc_start_main@plt>:
 8049400:	f3 0f 1e fb          	endbr32 
 8049404:	ff 25 58 10 05 08    	jmp    *0x8051058
 804940a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049410 <strcasecmp@plt>:
 8049410:	f3 0f 1e fb          	endbr32 
 8049414:	ff 25 5c 10 05 08    	jmp    *0x805105c
 804941a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049420 <setvbuf@plt>:
 8049420:	f3 0f 1e fb          	endbr32 
 8049424:	ff 25 60 10 05 08    	jmp    *0x8051060
 804942a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049430 <snprintf@plt>:
 8049430:	f3 0f 1e fb          	endbr32 
 8049434:	ff 25 64 10 05 08    	jmp    *0x8051064
 804943a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049440 <putchar@plt>:
 8049440:	f3 0f 1e fb          	endbr32 
 8049444:	ff 25 68 10 05 08    	jmp    *0x8051068
 804944a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049450 <pthread_cancel@plt>:
 8049450:	f3 0f 1e fb          	endbr32 
 8049454:	ff 25 6c 10 05 08    	jmp    *0x805106c
 804945a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049460 <strtoull@plt>:
 8049460:	f3 0f 1e fb          	endbr32 
 8049464:	ff 25 70 10 05 08    	jmp    *0x8051070
 804946a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049470 <strtod@plt>:
 8049470:	f3 0f 1e fb          	endbr32 
 8049474:	ff 25 74 10 05 08    	jmp    *0x8051074
 804947a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049480 <pthread_exit@plt>:
 8049480:	f3 0f 1e fb          	endbr32 
 8049484:	ff 25 78 10 05 08    	jmp    *0x8051078
 804948a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049490 <strnlen@plt>:
 8049490:	f3 0f 1e fb          	endbr32 
 8049494:	ff 25 7c 10 05 08    	jmp    *0x805107c
 804949a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494a0 <__sigsetjmp@plt>:
 80494a0:	f3 0f 1e fb          	endbr32 
 80494a4:	ff 25 80 10 05 08    	jmp    *0x8051080
 80494aa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494b0 <sigemptyset@plt>:
 80494b0:	f3 0f 1e fb          	endbr32 
 80494b4:	ff 25 84 10 05 08    	jmp    *0x8051084
 80494ba:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494c0 <__pthread_unwind_next@plt>:
 80494c0:	f3 0f 1e fb          	endbr32 
 80494c4:	ff 25 88 10 05 08    	jmp    *0x8051088
 80494ca:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494d0 <nanosleep@plt>:
 80494d0:	f3 0f 1e fb          	endbr32 
 80494d4:	ff 25 8c 10 05 08    	jmp    *0x805108c
 80494da:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494e0 <__fprintf_chk@plt>:
 80494e0:	f3 0f 1e fb          	endbr32 
 80494e4:	ff 25 90 10 05 08    	jmp    *0x8051090
 80494ea:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

080494f0 <pthread_create@plt>:
 80494f0:	f3 0f 1e fb          	endbr32 
 80494f4:	ff 25 94 10 05 08    	jmp    *0x8051094
 80494fa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049500 <sigaction@plt>:
 8049500:	f3 0f 1e fb          	endbr32 
 8049504:	ff 25 98 10 05 08    	jmp    *0x8051098
 804950a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049510 <pthread_detach@plt>:
 8049510:	f3 0f 1e fb          	endbr32 
 8049514:	ff 25 9c 10 05 08    	jmp    *0x805109c
 804951a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049520 <isatty@plt>:
 8049520:	f3 0f 1e fb          	endbr32 
 8049524:	ff 25 a0 10 05 08    	jmp    *0x80510a0
 804952a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049530 <strtol@plt>:
 8049530:	f3 0f 1e fb          	endbr32 
 8049534:	ff 25 a4 10 05 08    	jmp    *0x80510a4
 804953a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049540 <__ctype_b_loc@plt>:
 8049540:	f3 0f 1e fb          	endbr32 
 8049544:	ff 25 a8 10 05 08    	jmp    *0x80510a8
 804954a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

08049550 <calloc@plt>:
 8049550:	f3 0f 1e fb          	endbr32 
 8049554:	ff 25 ac 10 05 08    	jmp    *0x80510ac
 804955a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

Disassembly of section .text:

08049560 <_start>:
 8049560:	f3 0f 1e fb          	endbr32 
 8049564:	31 ed                	xor    %ebp,%ebp
 8049566:	5e                   	pop    %esi
 8049567:	89 e1                	mov    %esp,%ecx
 8049569:	83 e4 f0             	and    $0xfffffff0,%esp
 804956c:	50                   	push   %eax
 804956d:	54                   	push   %esp
 804956e:	52                   	push   %edx
 804956f:	e8 23 00 00 00       	call   8049597 <_start+0x37>
 8049574:	81 c3 8c 7a 00 00    	add    $0x7a8c,%ebx
 804957a:	8d 83 f0 86 ff ff    	lea    -0x7910(%ebx),%eax
 8049580:	50                   	push   %eax
 8049581:	8d 83 80 86 ff ff    	lea    -0x7980(%ebx),%eax
 8049587:	50                   	push   %eax
 8049588:	51                   	push   %ecx
 8049589:	56                   	push   %esi
 804958a:	c7 c0 ed b7 04 08    	mov    $0x804b7ed,%eax
 8049590:	50                   	push   %eax
 8049591:	e8 6a fe ff ff       	call   8049400 <__libc_start_main@plt>
 8049596:	f4                   	hlt    
 8049597:	8b 1c 24             	mov    (%esp),%ebx
 804959a:	c3                   	ret    
 804959b:	66 90                	xchg   %ax,%ax
 804959d:	66 90                	xchg   %ax,%ax
 804959f:	90                   	nop

080495a0 <_dl_relocate_static_pie>:
 80495a0:	f3 0f 1e fb          	endbr32 
 80495a4:	c3                   	ret    
 80495a5:	66 90                	xchg   %ax,%ax
 80495a7:	66 90                	xchg   %ax,%ax
 80495a9:	66 90                	xchg   %ax,%ax
 80495ab:	66 90                	xchg   %ax,%ax
 80495ad:	66 90                	xchg   %ax,%ax
 80495af:	90                   	nop

080495b0 <__x86.get_pc_thunk.bx>:
 80495b0:	8b 1c 24             	mov    (%esp),%ebx
 80495b3:	c3                   	ret    
 80495b4:	66 90                	xchg   %ax,%ax
 80495b6:	66 90                	xchg   %ax,%ax
 80495b8:	66 90                	xchg   %ax,%ax
 80495ba:	66 90                	xchg   %ax,%ax
 80495bc:	66 90                	xchg   %ax,%ax
 80495be:	66 90                	xchg   %ax,%ax

080495c0 <deregister_tm_clones>:
 80495c0:	b8 94 12 05 08       	mov    $0x8051294,%eax
 80495c5:	3d 94 12 05 08       	cmp    $0x8051294,%eax
 80495ca:	74 24                	je     80495f0 <deregister_tm_clones+0x30>
 80495cc:	b8 00 00 00 00       	mov    $0x0,%eax
 80495d1:	85 c0                	test   %eax,%eax
 80495d3:	74 1b                	je     80495f0 <deregister_tm_clones+0x30>
 80495d5:	55                   	push   %ebp
 80495d6:	89 e5                	mov    %esp,%ebp
 80495d8:	83 ec 14             	sub    $0x14,%esp
 80495db:	68 94 12 05 08       	push   $0x8051294
 80495e0:	ff d0                	call   *%eax
 80495e2:	83 c4 10             	add    $0x10,%esp
 80495e5:	c9                   	leave  
 80495e6:	c3                   	ret    
 80495e7:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80495ee:	66 90                	xchg   %ax,%ax
 80495f0:	c3                   	ret    
 80495f1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80495f8:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80495ff:	90                   	nop

08049600 <register_tm_clones>:
 8049600:	b8 94 12 05 08       	mov    $0x8051294,%eax
 8049605:	2d 94 12 05 08       	sub    $0x8051294,%eax
 804960a:	89 c2                	mov    %eax,%edx
 804960c:	c1 e8 1f             	shr    $0x1f,%eax
 804960f:	c1 fa 02             	sar    $0x2,%edx
 8049612:	01 d0                	add    %edx,%eax
 8049614:	d1 f8                	sar    %eax
 8049616:	74 20                	je     8049638 <register_tm_clones+0x38>
 8049618:	ba 00 00 00 00       	mov    $0x0,%edx
 804961d:	85 d2                	test   %edx,%edx
 804961f:	74 17                	je     8049638 <register_tm_clones+0x38>
 8049621:	55                   	push   %ebp
 8049622:	89 e5                	mov    %esp,%ebp
 8049624:	83 ec 10             	sub    $0x10,%esp
 8049627:	50                   	push   %eax
 8049628:	68 94 12 05 08       	push   $0x8051294
 804962d:	ff d2                	call   *%edx
 804962f:	83 c4 10             	add    $0x10,%esp
 8049632:	c9                   	leave  
 8049633:	c3                   	ret    
 8049634:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049638:	c3                   	ret    
 8049639:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08049640 <__do_global_dtors_aux>:
 8049640:	f3 0f 1e fb          	endbr32 
 8049644:	80 3d 9c 29 05 08 00 	cmpb   $0x0,0x805299c
 804964b:	75 1b                	jne    8049668 <__do_global_dtors_aux+0x28>
 804964d:	55                   	push   %ebp
 804964e:	89 e5                	mov    %esp,%ebp
 8049650:	83 ec 08             	sub    $0x8,%esp
 8049653:	e8 68 ff ff ff       	call   80495c0 <deregister_tm_clones>
 8049658:	c6 05 9c 29 05 08 01 	movb   $0x1,0x805299c
 804965f:	c9                   	leave  
 8049660:	c3                   	ret    
 8049661:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049668:	c3                   	ret    
 8049669:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08049670 <frame_dummy>:
 8049670:	f3 0f 1e fb          	endbr32 
 8049674:	eb 8a                	jmp    8049600 <register_tm_clones>
 8049676:	66 90                	xchg   %ax,%ax
 8049678:	66 90                	xchg   %ax,%ax
 804967a:	66 90                	xchg   %ax,%ax
 804967c:	66 90                	xchg   %ax,%ax
 804967e:	66 90                	xchg   %ax,%ax

08049680 <__libc_csu_init>:
 8049680:	f3 0f 1e fb          	endbr32 
 8049684:	55                   	push   %ebp
 8049685:	e8 b0 3d 00 00       	call   804d43a <__x86.get_pc_thunk.bp>
 804968a:	81 c5 76 79 00 00    	add    $0x7976,%ebp
 8049690:	57                   	push   %edi
 8049691:	56                   	push   %esi
 8049692:	53                   	push   %ebx
 8049693:	83 ec 0c             	sub    $0xc,%esp
 8049696:	89 eb                	mov    %ebp,%ebx
 8049698:	8b 7c 24 28          	mov    0x28(%esp),%edi
 804969c:	e8 5f f9 ff ff       	call   8049000 <_init>
 80496a1:	8d 9d 98 13 00 00    	lea    0x1398(%ebp),%ebx
 80496a7:	8d 85 94 13 00 00    	lea    0x1394(%ebp),%eax
 80496ad:	29 c3                	sub    %eax,%ebx
 80496af:	c1 fb 02             	sar    $0x2,%ebx
 80496b2:	74 29                	je     80496dd <__libc_csu_init+0x5d>
 80496b4:	31 f6                	xor    %esi,%esi
 80496b6:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80496bd:	8d 76 00             	lea    0x0(%esi),%esi
 80496c0:	83 ec 04             	sub    $0x4,%esp
 80496c3:	57                   	push   %edi
 80496c4:	ff 74 24 2c          	pushl  0x2c(%esp)
 80496c8:	ff 74 24 2c          	pushl  0x2c(%esp)
 80496cc:	ff 94 b5 94 13 00 00 	call   *0x1394(%ebp,%esi,4)
 80496d3:	83 c6 01             	add    $0x1,%esi
 80496d6:	83 c4 10             	add    $0x10,%esp
 80496d9:	39 f3                	cmp    %esi,%ebx
 80496db:	75 e3                	jne    80496c0 <__libc_csu_init+0x40>
 80496dd:	83 c4 0c             	add    $0xc,%esp
 80496e0:	5b                   	pop    %ebx
 80496e1:	5e                   	pop    %esi
 80496e2:	5f                   	pop    %edi
 80496e3:	5d                   	pop    %ebp
 80496e4:	c3                   	ret    
 80496e5:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80496ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080496f0 <__libc_csu_fini>:
 80496f0:	f3 0f 1e fb          	endbr32 
 80496f4:	c3                   	ret    

080496f5 <_Z7thread2PvS_S_>:
}

K_THREAD_DEFINE(thread1_id, 500, thread1, NULL, NULL, NULL, 5, 0, 0);

void thread2(void *a, void *b, void *c)
{
 80496f5:	f3 0f 1e fb          	endbr32 
 80496f9:	55                   	push   %ebp
 80496fa:	89 e5                	mov    %esp,%ebp
 80496fc:	83 ec 08             	sub    $0x8,%esp
    while (true)
    {
        printk("Thread2\n");
 80496ff:	83 ec 0c             	sub    $0xc,%esp
 8049702:	68 64 e1 04 08       	push   $0x804e164
 8049707:	e8 eb 00 00 00       	call   80497f7 <printk>
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_BUSY_WAIT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_busy_wait(usec_to_wait);
 804970c:	c7 04 24 a0 86 01 00 	movl   $0x186a0,(%esp)
 8049713:	e8 80 3c 00 00       	call   804d398 <z_impl_k_busy_wait>
 8049718:	83 c4 10             	add    $0x10,%esp
 804971b:	eb e2                	jmp    80496ff <_Z7thread2PvS_S_+0xa>

0804971d <_Z7thread1PvS_S_>:
void thread1(void *a, void *b, void *c) {
 804971d:	f3 0f 1e fb          	endbr32 
 8049721:	55                   	push   %ebp
 8049722:	89 e5                	mov    %esp,%ebp
 8049724:	83 ec 10             	sub    $0x10,%esp
	return z_impl_k_sleep(timeout);
 8049727:	6a 00                	push   $0x0
 8049729:	68 e8 03 00 00       	push   $0x3e8
 804972e:	e8 1b 37 00 00       	call   804ce4e <z_impl_k_sleep>
 8049733:	83 c4 10             	add    $0x10,%esp
        printk("Thread1\n");
 8049736:	83 ec 0c             	sub    $0xc,%esp
 8049739:	68 6d e1 04 08       	push   $0x804e16d
 804973e:	e8 b4 00 00 00       	call   80497f7 <printk>
	z_impl_k_busy_wait(usec_to_wait);
 8049743:	c7 04 24 a0 86 01 00 	movl   $0x186a0,(%esp)
 804974a:	e8 49 3c 00 00       	call   804d398 <z_impl_k_busy_wait>
 804974f:	eb e2                	jmp    8049733 <_Z7thread1PvS_S_+0x16>

08049751 <zephyr_app_main>:
    }
}
K_THREAD_DEFINE(thread2_id, 500, thread2, NULL, NULL, NULL, 6, 0, 0);

void main(void)
{
 8049751:	f3 0f 1e fb          	endbr32 
 8049755:	55                   	push   %ebp
 8049756:	89 e5                	mov    %esp,%ebp
 8049758:	83 ec 10             	sub    $0x10,%esp
    printk("Hello! %s\n", CONFIG_BOARD);
 804975b:	68 76 e1 04 08       	push   $0x804e176
 8049760:	68 83 e1 04 08       	push   $0x804e183
 8049765:	e8 8d 00 00 00       	call   80497f7 <printk>
 804976a:	58                   	pop    %eax
 804976b:	5a                   	pop    %edx
	return z_impl_k_sleep(timeout);
 804976c:	6a ff                	push   $0xffffffff
 804976e:	6a ff                	push   $0xffffffff
 8049770:	e8 d9 36 00 00       	call   804ce4e <z_impl_k_sleep>

    k_sleep(K_FOREVER);

    posix_exit(0);
 8049775:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804977c:	e8 30 20 00 00       	call   804b7b1 <posix_exit>
 8049781:	83 c4 10             	add    $0x10,%esp
}
 8049784:	c9                   	leave  
 8049785:	c3                   	ret    

08049786 <arch_printk_char_out>:
 *
 * @return 0
 */
/* LCOV_EXCL_START */
__attribute__((weak)) int arch_printk_char_out(int c)
{
 8049786:	f3 0f 1e fb          	endbr32 
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
 804978a:	31 c0                	xor    %eax,%eax
 804978c:	c3                   	ret    

0804978d <char_out>:
struct out_context {
	int count;
};

static int char_out(int c, void *ctx_p)
{
 804978d:	f3 0f 1e fb          	endbr32 
 8049791:	55                   	push   %ebp
 8049792:	89 e5                	mov    %esp,%ebp
 8049794:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct out_context *ctx = ctx_p;

	ctx->count++;
 8049797:	ff 00                	incl   (%eax)
	return _char_out(c);
}
 8049799:	5d                   	pop    %ebp
	return _char_out(c);
 804979a:	ff 25 70 12 05 08    	jmp    *0x8051270

080497a0 <__printk_hook_install>:
{
 80497a0:	f3 0f 1e fb          	endbr32 
 80497a4:	55                   	push   %ebp
 80497a5:	89 e5                	mov    %esp,%ebp
	_char_out = fn;
 80497a7:	8b 45 08             	mov    0x8(%ebp),%eax
}
 80497aa:	5d                   	pop    %ebp
	_char_out = fn;
 80497ab:	a3 70 12 05 08       	mov    %eax,0x8051270
}
 80497b0:	c3                   	ret    

080497b1 <vprintk>:

void vprintk(const char *fmt, va_list ap)
{
 80497b1:	f3 0f 1e fb          	endbr32 
 80497b5:	55                   	push   %ebp
 80497b6:	89 e5                	mov    %esp,%ebp
 80497b8:	83 ec 18             	sub    $0x18,%esp
 80497bb:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 80497c1:	89 45 f4             	mov    %eax,-0xc(%ebp)
 80497c4:	31 c0                	xor    %eax,%eax
		struct out_context ctx = { 0 };
#ifdef CONFIG_PRINTK_SYNC
		k_spinlock_key_t key = k_spin_lock(&lock);
#endif

		cbvprintf(char_out, &ctx, fmt, ap);
 80497c6:	8d 45 f0             	lea    -0x10(%ebp),%eax
 80497c9:	ff 75 0c             	pushl  0xc(%ebp)
 80497cc:	ff 75 08             	pushl  0x8(%ebp)
 80497cf:	50                   	push   %eax
 80497d0:	68 8d 97 04 08       	push   $0x804978d
		struct out_context ctx = { 0 };
 80497d5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cbvprintf(char_out, &ctx, fmt, ap);
 80497dc:	e8 cc 01 00 00       	call   80499ad <cbvprintf>
 80497e1:	83 c4 10             	add    $0x10,%esp

#ifdef CONFIG_PRINTK_SYNC
		k_spin_unlock(&lock, key);
#endif
	}
}
 80497e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80497e7:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 80497ee:	74 05                	je     80497f5 <vprintk+0x44>
 80497f0:	e8 9b fb ff ff       	call   8049390 <__stack_chk_fail@plt>
 80497f5:	c9                   	leave  
 80497f6:	c3                   	ret    

080497f7 <printk>:
 *
 * @param fmt formatted string to output
 */

void printk(const char *fmt, ...)
{
 80497f7:	f3 0f 1e fb          	endbr32 
 80497fb:	55                   	push   %ebp
 80497fc:	89 e5                	mov    %esp,%ebp
 80497fe:	83 ec 10             	sub    $0x10,%esp
	va_list ap;

	va_start(ap, fmt);
 8049801:	8d 45 0c             	lea    0xc(%ebp),%eax

	vprintk(fmt, ap);
 8049804:	50                   	push   %eax
 8049805:	ff 75 08             	pushl  0x8(%ebp)
 8049808:	e8 a4 ff ff ff       	call   80497b1 <vprintk>
 804980d:	83 c4 10             	add    $0x10,%esp

	va_end(ap);
}
 8049810:	c9                   	leave  
 8049811:	c3                   	ret    

08049812 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
 8049812:	f3 0f 1e fb          	endbr32 
 8049816:	55                   	push   %ebp
 8049817:	89 e5                	mov    %esp,%ebp
 8049819:	83 ec 0c             	sub    $0xc,%esp
#ifdef CONFIG_THREAD_LOCAL_STORAGE
	z_tls_current = z_current_get();
#endif
	entry(p1, p2, p3);
 804981c:	ff 75 14             	pushl  0x14(%ebp)
 804981f:	ff 75 10             	pushl  0x10(%ebp)
 8049822:	ff 75 0c             	pushl  0xc(%ebp)
 8049825:	ff 55 08             	call   *0x8(%ebp)
 8049828:	83 c4 10             	add    $0x10,%esp
	if (z_syscall_trap()) {
		return (k_tid_t) arch_syscall_invoke0(K_SYSCALL_Z_CURRENT_GET);
	}
#endif
	compiler_barrier();
	return z_impl_z_current_get();
 804982b:	e8 58 36 00 00       	call   804ce88 <z_impl_z_current_get>
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_THREAD_ABORT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_abort(thread);
 8049830:	83 ec 0c             	sub    $0xc,%esp
 8049833:	50                   	push   %eax
 8049834:	e8 dc 0d 00 00       	call   804a615 <z_impl_k_thread_abort>
 8049839:	83 c4 0c             	add    $0xc,%esp
	/*
	 * Compiler can't tell that k_thread_abort() won't return and issues a
	 * warning unless we tell it that control never gets this far.
	 */

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 804983c:	6a 2d                	push   $0x2d
 804983e:	68 a4 e1 04 08       	push   $0x804e1a4
 8049843:	68 cd e1 04 08       	push   $0x804e1cd
 8049848:	e8 a1 20 00 00       	call   804b8ee <posix_print_error_and_exit>
 804984d:	83 c4 10             	add    $0x10,%esp

08049850 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
 8049850:	55                   	push   %ebp
 8049851:	89 e5                	mov    %esp,%ebp
 8049853:	57                   	push   %edi
 8049854:	89 cf                	mov    %ecx,%edi
 8049856:	56                   	push   %esi
 8049857:	89 c6                	mov    %eax,%esi
 8049859:	53                   	push   %ebx
	size_t count = 0;
 804985a:	31 db                	xor    %ebx,%ebx
{
 804985c:	83 ec 1c             	sub    $0x1c,%esp

	while ((sp < ep) || ((ep == NULL) && *sp)) {
 804985f:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
 8049862:	39 45 08             	cmp    %eax,0x8(%ebp)
 8049865:	76 1a                	jbe    8049881 <outs+0x31>
		int rc = out((int)*sp++, ctx);
 8049867:	50                   	push   %eax
 8049868:	50                   	push   %eax
 8049869:	0f be 04 1f          	movsbl (%edi,%ebx,1),%eax
 804986d:	52                   	push   %edx
 804986e:	50                   	push   %eax
 804986f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 8049872:	ff d6                	call   *%esi
 8049874:	83 c4 10             	add    $0x10,%esp

		if (rc < 0) {
 8049877:	85 c0                	test   %eax,%eax
 8049879:	78 18                	js     8049893 <outs+0x43>
			return rc;
		}
		++count;
 804987b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804987e:	43                   	inc    %ebx
 804987f:	eb de                	jmp    804985f <outs+0xf>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
 8049881:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8049885:	74 04                	je     804988b <outs+0x3b>
	}

	return (int)count;
 8049887:	89 d8                	mov    %ebx,%eax
 8049889:	eb 08                	jmp    8049893 <outs+0x43>
	while ((sp < ep) || ((ep == NULL) && *sp)) {
 804988b:	80 3c 1f 00          	cmpb   $0x0,(%edi,%ebx,1)
 804988f:	75 d6                	jne    8049867 <outs+0x17>
 8049891:	eb f4                	jmp    8049887 <outs+0x37>
}
 8049893:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8049896:	5b                   	pop    %ebx
 8049897:	5e                   	pop    %esi
 8049898:	5f                   	pop    %edi
 8049899:	5d                   	pop    %ebp
 804989a:	c3                   	ret    

0804989b <extract_decimal>:
{
 804989b:	55                   	push   %ebp
 804989c:	89 e5                	mov    %esp,%ebp
 804989e:	57                   	push   %edi
 804989f:	56                   	push   %esi
 80498a0:	53                   	push   %ebx
 80498a1:	89 c3                	mov    %eax,%ebx
 80498a3:	83 ec 0c             	sub    $0xc,%esp
	const char *sp = *str;
 80498a6:	8b 30                	mov    (%eax),%esi
	while (isdigit((int)(unsigned char)*sp)) {
 80498a8:	e8 93 fc ff ff       	call   8049540 <__ctype_b_loc@plt>
 80498ad:	8b 08                	mov    (%eax),%ecx
	size_t val = 0;
 80498af:	31 c0                	xor    %eax,%eax
	while (isdigit((int)(unsigned char)*sp)) {
 80498b1:	0f be 16             	movsbl (%esi),%edx
 80498b4:	0f b6 fa             	movzbl %dl,%edi
 80498b7:	f6 44 79 01 08       	testb  $0x8,0x1(%ecx,%edi,2)
 80498bc:	74 0a                	je     80498c8 <extract_decimal+0x2d>
		val = 10U * val + *sp++ - '0';
 80498be:	6b c0 0a             	imul   $0xa,%eax,%eax
 80498c1:	46                   	inc    %esi
 80498c2:	8d 44 10 d0          	lea    -0x30(%eax,%edx,1),%eax
 80498c6:	eb e9                	jmp    80498b1 <extract_decimal+0x16>
	*str = sp;
 80498c8:	89 33                	mov    %esi,(%ebx)
}
 80498ca:	83 c4 0c             	add    $0xc,%esp
 80498cd:	5b                   	pop    %ebx
 80498ce:	5e                   	pop    %esi
 80498cf:	5f                   	pop    %edi
 80498d0:	5d                   	pop    %ebp
 80498d1:	c3                   	ret    

080498d2 <encode_uint>:
{
 80498d2:	55                   	push   %ebp
 80498d3:	89 e5                	mov    %esp,%ebp
 80498d5:	57                   	push   %edi
 80498d6:	56                   	push   %esi
 80498d7:	89 ce                	mov    %ecx,%esi
 80498d9:	53                   	push   %ebx
	switch (specifier) {
 80498da:	bb 08 00 00 00       	mov    $0x8,%ebx
{
 80498df:	83 ec 3c             	sub    $0x3c,%esp
 80498e2:	89 55 dc             	mov    %edx,-0x24(%ebp)
 80498e5:	89 45 d8             	mov    %eax,-0x28(%ebp)
	bool upcase = isupper((int)conv->specifier);
 80498e8:	e8 53 fc ff ff       	call   8049540 <__ctype_b_loc@plt>
 80498ed:	0f b6 4e 03          	movzbl 0x3(%esi),%ecx
 80498f1:	8b 10                	mov    (%eax),%edx
 80498f3:	66 8b 14 4a          	mov    (%edx,%ecx,2),%dx
 80498f7:	66 81 e2 00 01       	and    $0x100,%dx
 80498fc:	66 89 55 ce          	mov    %dx,-0x32(%ebp)
	switch (specifier) {
 8049900:	80 f9 6f             	cmp    $0x6f,%cl
 8049903:	74 1b                	je     8049920 <encode_uint+0x4e>
 8049905:	89 c8                	mov    %ecx,%eax
 8049907:	77 05                	ja     804990e <encode_uint+0x3c>
		return 16;
 8049909:	80 f9 58             	cmp    $0x58,%cl
 804990c:	eb 05                	jmp    8049913 <encode_uint+0x41>
	switch (specifier) {
 804990e:	83 e0 f7             	and    $0xfffffff7,%eax
		return 16;
 8049911:	3c 70                	cmp    $0x70,%al
 8049913:	bb 0a 00 00 00       	mov    $0xa,%ebx
 8049918:	b8 10 00 00 00       	mov    $0x10,%eax
 804991d:	0f 44 d8             	cmove  %eax,%ebx
		unsigned int lsv = (unsigned int)(value % radix);
 8049920:	89 5d d0             	mov    %ebx,-0x30(%ebp)
	char *bp = bps + (bpe - bps);
 8049923:	8b 7d 0c             	mov    0xc(%ebp),%edi
		unsigned int lsv = (unsigned int)(value % radix);
 8049926:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
 804992d:	83 ec 0c             	sub    $0xc,%esp
 8049930:	8d 45 e0             	lea    -0x20(%ebp),%eax
 8049933:	50                   	push   %eax
 8049934:	ff 75 d4             	pushl  -0x2c(%ebp)
 8049937:	ff 75 d0             	pushl  -0x30(%ebp)
 804993a:	ff 75 dc             	pushl  -0x24(%ebp)
 804993d:	ff 75 d8             	pushl  -0x28(%ebp)
 8049940:	e8 9b fa ff ff       	call   80493e0 <__udivmoddi4@plt>
 8049945:	83 c4 20             	add    $0x20,%esp
 8049948:	89 45 c0             	mov    %eax,-0x40(%ebp)
 804994b:	8b 45 e0             	mov    -0x20(%ebp),%eax
		*--bp = (lsv <= 9) ? ('0' + lsv)
 804994e:	89 55 c4             	mov    %edx,-0x3c(%ebp)
 8049951:	8d 50 30             	lea    0x30(%eax),%edx
 8049954:	83 f8 09             	cmp    $0x9,%eax
 8049957:	76 0d                	jbe    8049966 <encode_uint+0x94>
 8049959:	66 83 7d ce 00       	cmpw   $0x0,-0x32(%ebp)
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
 804995e:	8d 50 57             	lea    0x57(%eax),%edx
		*--bp = (lsv <= 9) ? ('0' + lsv)
 8049961:	74 03                	je     8049966 <encode_uint+0x94>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
 8049963:	8d 50 37             	lea    0x37(%eax),%edx
	} while ((value != 0) && (bps < bp));
 8049966:	8b 45 d0             	mov    -0x30(%ebp),%eax
		*--bp = (lsv <= 9) ? ('0' + lsv)
 8049969:	4f                   	dec    %edi
	} while ((value != 0) && (bps < bp));
 804996a:	39 45 d8             	cmp    %eax,-0x28(%ebp)
		*--bp = (lsv <= 9) ? ('0' + lsv)
 804996d:	88 17                	mov    %dl,(%edi)
	} while ((value != 0) && (bps < bp));
 804996f:	8b 45 dc             	mov    -0x24(%ebp),%eax
 8049972:	1b 45 d4             	sbb    -0x2c(%ebp),%eax
 8049975:	72 13                	jb     804998a <encode_uint+0xb8>
 8049977:	3b 7d 08             	cmp    0x8(%ebp),%edi
 804997a:	76 0e                	jbe    804998a <encode_uint+0xb8>
		value /= radix;
 804997c:	8b 45 c0             	mov    -0x40(%ebp),%eax
 804997f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
 8049982:	89 45 d8             	mov    %eax,-0x28(%ebp)
 8049985:	89 55 dc             	mov    %edx,-0x24(%ebp)
 8049988:	eb a3                	jmp    804992d <encode_uint+0x5b>
	if (conv->flag_hash) {
 804998a:	f6 06 20             	testb  $0x20,(%esi)
 804998d:	74 14                	je     80499a3 <encode_uint+0xd1>
		if (radix == 8) {
 804998f:	83 fb 08             	cmp    $0x8,%ebx
 8049992:	75 06                	jne    804999a <encode_uint+0xc8>
			conv->altform_0 = true;
 8049994:	80 4e 02 08          	orb    $0x8,0x2(%esi)
 8049998:	eb 09                	jmp    80499a3 <encode_uint+0xd1>
		} else if (radix == 16) {
 804999a:	83 fb 10             	cmp    $0x10,%ebx
 804999d:	75 04                	jne    80499a3 <encode_uint+0xd1>
			conv->altform_0c = true;
 804999f:	80 4e 02 10          	orb    $0x10,0x2(%esi)
}
 80499a3:	8d 65 f4             	lea    -0xc(%ebp),%esp
 80499a6:	89 f8                	mov    %edi,%eax
 80499a8:	5b                   	pop    %ebx
 80499a9:	5e                   	pop    %esi
 80499aa:	5f                   	pop    %edi
 80499ab:	5d                   	pop    %ebp
 80499ac:	c3                   	ret    

080499ad <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
 80499ad:	f3 0f 1e fb          	endbr32 
 80499b1:	55                   	push   %ebp
 80499b2:	89 e5                	mov    %esp,%ebp
 80499b4:	57                   	push   %edi
 80499b5:	56                   	push   %esi
 80499b6:	53                   	push   %ebx
 80499b7:	83 ec 6c             	sub    $0x6c,%esp
 80499ba:	8b 45 08             	mov    0x8(%ebp),%eax
 80499bd:	8b 5d 14             	mov    0x14(%ebp),%ebx
 80499c0:	89 45 98             	mov    %eax,-0x68(%ebp)
 80499c3:	8b 45 0c             	mov    0xc(%ebp),%eax
 80499c6:	89 45 94             	mov    %eax,-0x6c(%ebp)
 80499c9:	8b 45 10             	mov    0x10(%ebp),%eax
 80499cc:	89 45 9c             	mov    %eax,-0x64(%ebp)
 80499cf:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 80499d5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 80499d8:	31 c0                	xor    %eax,%eax
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
 80499da:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
 80499e1:	8b 45 9c             	mov    -0x64(%ebp),%eax
 80499e4:	0f be 00             	movsbl (%eax),%eax
 80499e7:	84 c0                	test   %al,%al
 80499e9:	0f 84 81 07 00 00    	je     804a170 <cbvprintf+0x7c3>
		if (*fp != '%') {
 80499ef:	8b 7d 9c             	mov    -0x64(%ebp),%edi
 80499f2:	47                   	inc    %edi
 80499f3:	89 7d 90             	mov    %edi,-0x70(%ebp)
 80499f6:	3c 25                	cmp    $0x25,%al
 80499f8:	74 0b                	je     8049a05 <cbvprintf+0x58>
			OUTC(*fp++);
 80499fa:	56                   	push   %esi
 80499fb:	56                   	push   %esi
 80499fc:	ff 75 94             	pushl  -0x6c(%ebp)
 80499ff:	50                   	push   %eax
 8049a00:	e9 5b 04 00 00       	jmp    8049e60 <cbvprintf+0x4b3>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
 8049a05:	31 c0                	xor    %eax,%eax
 8049a07:	8d 7d b4             	lea    -0x4c(%ebp),%edi
 8049a0a:	b9 03 00 00 00       	mov    $0x3,%ecx
 8049a0f:	f3 ab                	rep stos %eax,%es:(%edi)
	*conv = (struct conversion) {
 8049a11:	8d 7d c0             	lea    -0x40(%ebp),%edi
 8049a14:	b9 03 00 00 00       	mov    $0x3,%ecx
 8049a19:	f3 ab                	rep stos %eax,%es:(%edi)
	if (*sp == '%') {
 8049a1b:	8b 45 9c             	mov    -0x64(%ebp),%eax
 8049a1e:	80 78 01 25          	cmpb   $0x25,0x1(%eax)
 8049a22:	75 1c                	jne    8049a40 <cbvprintf+0x93>
		conv->specifier = *sp++;
 8049a24:	83 c0 02             	add    $0x2,%eax
 8049a27:	c6 45 c3 25          	movb   $0x25,-0x3d(%ebp)
 8049a2b:	89 45 90             	mov    %eax,-0x70(%ebp)
		return sp;
 8049a2e:	e9 52 02 00 00       	jmp    8049c85 <cbvprintf+0x2d8>
		switch (*sp) {
 8049a33:	7e 16                	jle    8049a4b <cbvprintf+0x9e>
 8049a35:	3c 2d                	cmp    $0x2d,%al
 8049a37:	75 1c                	jne    8049a55 <cbvprintf+0xa8>
			conv->flag_dash = true;
 8049a39:	80 4d c0 04          	orb    $0x4,-0x40(%ebp)
			++sp;
 8049a3d:	ff 45 90             	incl   -0x70(%ebp)
		switch (*sp) {
 8049a40:	8b 45 90             	mov    -0x70(%ebp),%eax
 8049a43:	8a 00                	mov    (%eax),%al
 8049a45:	3c 2b                	cmp    $0x2b,%al
 8049a47:	75 ea                	jne    8049a33 <cbvprintf+0x86>
 8049a49:	eb 23                	jmp    8049a6e <cbvprintf+0xc1>
 8049a4b:	3c 20                	cmp    $0x20,%al
 8049a4d:	74 25                	je     8049a74 <cbvprintf+0xc7>
 8049a4f:	3c 23                	cmp    $0x23,%al
 8049a51:	74 27                	je     8049a7a <cbvprintf+0xcd>
 8049a53:	eb 04                	jmp    8049a59 <cbvprintf+0xac>
 8049a55:	3c 30                	cmp    $0x30,%al
 8049a57:	74 27                	je     8049a80 <cbvprintf+0xd3>
	if (conv->flag_zero && conv->flag_dash) {
 8049a59:	8a 45 c0             	mov    -0x40(%ebp),%al
 8049a5c:	89 c2                	mov    %eax,%edx
 8049a5e:	83 e2 44             	and    $0x44,%edx
 8049a61:	80 fa 44             	cmp    $0x44,%dl
 8049a64:	75 20                	jne    8049a86 <cbvprintf+0xd9>
		conv->flag_zero = false;
 8049a66:	83 e0 bf             	and    $0xffffffbf,%eax
 8049a69:	88 45 c0             	mov    %al,-0x40(%ebp)
 8049a6c:	eb 18                	jmp    8049a86 <cbvprintf+0xd9>
			conv->flag_plus = true;
 8049a6e:	80 4d c0 08          	orb    $0x8,-0x40(%ebp)
			break;
 8049a72:	eb c9                	jmp    8049a3d <cbvprintf+0x90>
			conv->flag_space = true;
 8049a74:	80 4d c0 10          	orb    $0x10,-0x40(%ebp)
			break;
 8049a78:	eb c3                	jmp    8049a3d <cbvprintf+0x90>
			conv->flag_hash = true;
 8049a7a:	80 4d c0 20          	orb    $0x20,-0x40(%ebp)
			break;
 8049a7e:	eb bd                	jmp    8049a3d <cbvprintf+0x90>
			conv->flag_zero = true;
 8049a80:	80 4d c0 40          	orb    $0x40,-0x40(%ebp)
			break;
 8049a84:	eb b7                	jmp    8049a3d <cbvprintf+0x90>
	sp = extract_width(conv, sp);
 8049a86:	8b 45 90             	mov    -0x70(%ebp),%eax
	conv->width_present = true;
 8049a89:	80 4d c0 80          	orb    $0x80,-0x40(%ebp)
 8049a8d:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (*sp == '*') {
 8049a90:	80 38 2a             	cmpb   $0x2a,(%eax)
 8049a93:	75 09                	jne    8049a9e <cbvprintf+0xf1>
		return ++sp;
 8049a95:	89 c2                	mov    %eax,%edx
		conv->width_star = true;
 8049a97:	80 4d c1 01          	orb    $0x1,-0x3f(%ebp)
		return ++sp;
 8049a9b:	42                   	inc    %edx
 8049a9c:	eb 30                	jmp    8049ace <cbvprintf+0x121>
	size_t width = extract_decimal(&sp);
 8049a9e:	8d 45 b0             	lea    -0x50(%ebp),%eax
 8049aa1:	e8 f5 fd ff ff       	call   804989b <extract_decimal>
	if (sp != wp) {
 8049aa6:	8b 55 b0             	mov    -0x50(%ebp),%edx
 8049aa9:	3b 55 90             	cmp    -0x70(%ebp),%edx
 8049aac:	74 20                	je     8049ace <cbvprintf+0x121>
		conv->unsupported |= ((conv->width_value < 0)
 8049aae:	8a 4d c0             	mov    -0x40(%ebp),%cl
		conv->width_value = width;
 8049ab1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				      || (width != (size_t)conv->width_value));
 8049ab4:	c1 e8 1f             	shr    $0x1f,%eax
		conv->unsupported |= ((conv->width_value < 0)
 8049ab7:	d0 e9                	shr    %cl
 8049ab9:	83 e1 01             	and    $0x1,%ecx
 8049abc:	09 c8                	or     %ecx,%eax
 8049abe:	8a 4d c0             	mov    -0x40(%ebp),%cl
 8049ac1:	01 c0                	add    %eax,%eax
 8049ac3:	83 c8 80             	or     $0xffffff80,%eax
 8049ac6:	83 e1 7d             	and    $0x7d,%ecx
 8049ac9:	09 c8                	or     %ecx,%eax
 8049acb:	88 45 c0             	mov    %al,-0x40(%ebp)
	sp = extract_prec(conv, sp);
 8049ace:	89 55 b0             	mov    %edx,-0x50(%ebp)
	conv->prec_present = (*sp == '.');
 8049ad1:	8a 0a                	mov    (%edx),%cl
 8049ad3:	80 f9 2e             	cmp    $0x2e,%cl
 8049ad6:	0f 94 c0             	sete   %al
 8049ad9:	8d 34 00             	lea    (%eax,%eax,1),%esi
 8049adc:	8a 45 c1             	mov    -0x3f(%ebp),%al
 8049adf:	83 e0 fd             	and    $0xfffffffd,%eax
 8049ae2:	09 f0                	or     %esi,%eax
 8049ae4:	88 45 c1             	mov    %al,-0x3f(%ebp)
	if (!conv->prec_present) {
 8049ae7:	80 f9 2e             	cmp    $0x2e,%cl
 8049aea:	75 3e                	jne    8049b2a <cbvprintf+0x17d>
	++sp;
 8049aec:	8d 4a 01             	lea    0x1(%edx),%ecx
 8049aef:	89 4d b0             	mov    %ecx,-0x50(%ebp)
	if (*sp == '*') {
 8049af2:	80 7a 01 2a          	cmpb   $0x2a,0x1(%edx)
 8049af6:	75 0b                	jne    8049b03 <cbvprintf+0x156>
		conv->prec_star = true;
 8049af8:	83 c8 04             	or     $0x4,%eax
		return ++sp;
 8049afb:	83 c2 02             	add    $0x2,%edx
		conv->prec_star = true;
 8049afe:	88 45 c1             	mov    %al,-0x3f(%ebp)
		return ++sp;
 8049b01:	eb 27                	jmp    8049b2a <cbvprintf+0x17d>
	size_t prec = extract_decimal(&sp);
 8049b03:	8d 45 b0             	lea    -0x50(%ebp),%eax
 8049b06:	e8 90 fd ff ff       	call   804989b <extract_decimal>
	conv->unsupported |= ((conv->prec_value < 0)
 8049b0b:	8a 55 c0             	mov    -0x40(%ebp),%dl
	conv->prec_value = prec;
 8049b0e:	89 45 c8             	mov    %eax,-0x38(%ebp)
			      || (prec != (size_t)conv->prec_value));
 8049b11:	c1 e8 1f             	shr    $0x1f,%eax
	conv->unsupported |= ((conv->prec_value < 0)
 8049b14:	89 d1                	mov    %edx,%ecx
 8049b16:	83 e2 fd             	and    $0xfffffffd,%edx
 8049b19:	d0 e9                	shr    %cl
 8049b1b:	83 e1 01             	and    $0x1,%ecx
 8049b1e:	09 c8                	or     %ecx,%eax
 8049b20:	01 c0                	add    %eax,%eax
 8049b22:	09 c2                	or     %eax,%edx
 8049b24:	88 55 c0             	mov    %dl,-0x40(%ebp)
	return sp;
 8049b27:	8b 55 b0             	mov    -0x50(%ebp),%edx
	switch (*sp) {
 8049b2a:	8a 0a                	mov    (%edx),%cl
 8049b2c:	8d 72 01             	lea    0x1(%edx),%esi
 8049b2f:	80 f9 6c             	cmp    $0x6c,%cl
 8049b32:	74 50                	je     8049b84 <cbvprintf+0x1d7>
 8049b34:	7f 20                	jg     8049b56 <cbvprintf+0x1a9>
 8049b36:	80 f9 68             	cmp    $0x68,%cl
 8049b39:	74 30                	je     8049b6b <cbvprintf+0x1be>
 8049b3b:	80 f9 6a             	cmp    $0x6a,%cl
 8049b3e:	74 66                	je     8049ba6 <cbvprintf+0x1f9>
 8049b40:	80 f9 4c             	cmp    $0x4c,%cl
 8049b43:	75 74                	jne    8049bb9 <cbvprintf+0x20c>
		conv->unsupported = true;
 8049b45:	8b 45 c0             	mov    -0x40(%ebp),%eax
 8049b48:	66 25 fd 87          	and    $0x87fd,%ax
 8049b4c:	66 0d 02 40          	or     $0x4002,%ax
 8049b50:	66 89 45 c0          	mov    %ax,-0x40(%ebp)
		break;
 8049b54:	eb 69                	jmp    8049bbf <cbvprintf+0x212>
	switch (*sp) {
 8049b56:	80 f9 74             	cmp    $0x74,%cl
 8049b59:	8a 45 c1             	mov    -0x3f(%ebp),%al
 8049b5c:	74 53                	je     8049bb1 <cbvprintf+0x204>
 8049b5e:	80 f9 7a             	cmp    $0x7a,%cl
 8049b61:	75 56                	jne    8049bb9 <cbvprintf+0x20c>
		conv->length_mod = LENGTH_Z;
 8049b63:	83 e0 87             	and    $0xffffff87,%eax
 8049b66:	83 c8 30             	or     $0x30,%eax
 8049b69:	eb 36                	jmp    8049ba1 <cbvprintf+0x1f4>
		if (*++sp == 'h') {
 8049b6b:	80 7a 01 68          	cmpb   $0x68,0x1(%edx)
 8049b6f:	8a 45 c1             	mov    -0x3f(%ebp),%al
 8049b72:	75 08                	jne    8049b7c <cbvprintf+0x1cf>
			conv->length_mod = LENGTH_HH;
 8049b74:	83 e0 87             	and    $0xffffff87,%eax
 8049b77:	83 c8 08             	or     $0x8,%eax
 8049b7a:	eb 17                	jmp    8049b93 <cbvprintf+0x1e6>
			conv->length_mod = LENGTH_H;
 8049b7c:	83 e0 87             	and    $0xffffff87,%eax
 8049b7f:	83 c8 10             	or     $0x10,%eax
 8049b82:	eb 1d                	jmp    8049ba1 <cbvprintf+0x1f4>
		if (*++sp == 'l') {
 8049b84:	80 7a 01 6c          	cmpb   $0x6c,0x1(%edx)
 8049b88:	8a 45 c1             	mov    -0x3f(%ebp),%al
 8049b8b:	75 0e                	jne    8049b9b <cbvprintf+0x1ee>
			conv->length_mod = LENGTH_LL;
 8049b8d:	83 e0 87             	and    $0xffffff87,%eax
 8049b90:	83 c8 20             	or     $0x20,%eax
 8049b93:	88 45 c1             	mov    %al,-0x3f(%ebp)
			++sp;
 8049b96:	8d 72 02             	lea    0x2(%edx),%esi
 8049b99:	eb 24                	jmp    8049bbf <cbvprintf+0x212>
			conv->length_mod = LENGTH_L;
 8049b9b:	83 e0 87             	and    $0xffffff87,%eax
 8049b9e:	83 c8 18             	or     $0x18,%eax
 8049ba1:	88 45 c1             	mov    %al,-0x3f(%ebp)
 8049ba4:	eb 19                	jmp    8049bbf <cbvprintf+0x212>
		conv->length_mod = LENGTH_J;
 8049ba6:	8a 45 c1             	mov    -0x3f(%ebp),%al
 8049ba9:	83 e0 87             	and    $0xffffff87,%eax
 8049bac:	83 c8 28             	or     $0x28,%eax
 8049baf:	eb f0                	jmp    8049ba1 <cbvprintf+0x1f4>
		conv->length_mod = LENGTH_T;
 8049bb1:	83 e0 87             	and    $0xffffff87,%eax
 8049bb4:	83 c8 38             	or     $0x38,%eax
 8049bb7:	eb e8                	jmp    8049ba1 <cbvprintf+0x1f4>
		conv->length_mod = LENGTH_NONE;
 8049bb9:	80 65 c1 87          	andb   $0x87,-0x3f(%ebp)
		break;
 8049bbd:	89 d6                	mov    %edx,%esi
	conv->specifier = *sp++;
 8049bbf:	8d 46 01             	lea    0x1(%esi),%eax
 8049bc2:	8a 55 c1             	mov    -0x3f(%ebp),%dl
 8049bc5:	89 45 90             	mov    %eax,-0x70(%ebp)
 8049bc8:	8a 06                	mov    (%esi),%al
 8049bca:	88 45 c3             	mov    %al,-0x3d(%ebp)
	switch (conv->specifier) {
 8049bcd:	3c 78                	cmp    $0x78,%al
 8049bcf:	0f 8f 94 00 00 00    	jg     8049c69 <cbvprintf+0x2bc>
 8049bd5:	3c 57                	cmp    $0x57,%al
 8049bd7:	7f 11                	jg     8049bea <cbvprintf+0x23d>
 8049bd9:	3c 41                	cmp    $0x41,%al
 8049bdb:	74 51                	je     8049c2e <cbvprintf+0x281>
 8049bdd:	83 e8 45             	sub    $0x45,%eax
 8049be0:	3c 02                	cmp    $0x2,%al
 8049be2:	0f 87 81 00 00 00    	ja     8049c69 <cbvprintf+0x2bc>
 8049be8:	eb 44                	jmp    8049c2e <cbvprintf+0x281>
 8049bea:	8d 48 a8             	lea    -0x58(%eax),%ecx
 8049bed:	80 f9 20             	cmp    $0x20,%cl
 8049bf0:	77 77                	ja     8049c69 <cbvprintf+0x2bc>
 8049bf2:	0f b6 c9             	movzbl %cl,%ecx
 8049bf5:	3e ff 24 8d 04 e0 04 	notrack jmp *0x804e004(,%ecx,4)
 8049bfc:	08 
		conv->specifier_cat = SPECIFIER_SINT;
 8049bfd:	8a 4d c2             	mov    -0x3e(%ebp),%cl
 8049c00:	83 e1 f8             	and    $0xfffffff8,%ecx
 8049c03:	83 c9 01             	or     $0x1,%ecx
 8049c06:	eb 09                	jmp    8049c11 <cbvprintf+0x264>
		conv->specifier_cat = SPECIFIER_UINT;
 8049c08:	8a 4d c2             	mov    -0x3e(%ebp),%cl
 8049c0b:	83 e1 f8             	and    $0xfffffff8,%ecx
 8049c0e:	83 c9 02             	or     $0x2,%ecx
 8049c11:	f3 0f 1e fb          	endbr32 
		if (conv->length_mod == LENGTH_UPPER_L) {
 8049c15:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_UINT;
 8049c18:	88 4d c2             	mov    %cl,-0x3e(%ebp)
		if (conv->length_mod == LENGTH_UPPER_L) {
 8049c1b:	80 fa 40             	cmp    $0x40,%dl
 8049c1e:	75 04                	jne    8049c24 <cbvprintf+0x277>
			conv->invalid = true;
 8049c20:	80 4d c0 01          	orb    $0x1,-0x40(%ebp)
	bool unsupported = false;
 8049c24:	31 c9                	xor    %ecx,%ecx
		if (conv->specifier == 'c') {
 8049c26:	3c 63                	cmp    $0x63,%al
 8049c28:	75 45                	jne    8049c6f <cbvprintf+0x2c2>
			unsupported = (conv->length_mod != LENGTH_NONE);
 8049c2a:	84 d2                	test   %dl,%dl
 8049c2c:	eb 36                	jmp    8049c64 <cbvprintf+0x2b7>
		conv->specifier_cat = SPECIFIER_FP;
 8049c2e:	8a 45 c2             	mov    -0x3e(%ebp),%al
			unsupported = true;
 8049c31:	b1 01                	mov    $0x1,%cl
		conv->specifier_cat = SPECIFIER_FP;
 8049c33:	83 e0 f8             	and    $0xfffffff8,%eax
 8049c36:	83 c8 04             	or     $0x4,%eax
 8049c39:	88 45 c2             	mov    %al,-0x3e(%ebp)
			break;
 8049c3c:	eb 31                	jmp    8049c6f <cbvprintf+0x2c2>
		conv->specifier_cat = SPECIFIER_PTR;
 8049c3e:	8a 45 c2             	mov    -0x3e(%ebp),%al
		if (conv->length_mod == LENGTH_UPPER_L) {
 8049c41:	83 e2 78             	and    $0x78,%edx
		conv->specifier_cat = SPECIFIER_PTR;
 8049c44:	83 e0 f8             	and    $0xfffffff8,%eax
 8049c47:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod == LENGTH_UPPER_L) {
 8049c4a:	80 fa 40             	cmp    $0x40,%dl
		conv->specifier_cat = SPECIFIER_PTR;
 8049c4d:	88 45 c2             	mov    %al,-0x3e(%ebp)
		if (conv->length_mod == LENGTH_UPPER_L) {
 8049c50:	0f 94 c1             	sete   %cl
 8049c53:	eb 1a                	jmp    8049c6f <cbvprintf+0x2c2>
		conv->specifier_cat = SPECIFIER_PTR;
 8049c55:	8a 45 c2             	mov    -0x3e(%ebp),%al
 8049c58:	83 e0 f8             	and    $0xfffffff8,%eax
 8049c5b:	83 c8 03             	or     $0x3,%eax
		if (conv->length_mod != LENGTH_NONE) {
 8049c5e:	80 e2 78             	and    $0x78,%dl
		conv->specifier_cat = SPECIFIER_PTR;
 8049c61:	88 45 c2             	mov    %al,-0x3e(%ebp)
		if (conv->length_mod != LENGTH_NONE) {
 8049c64:	0f 95 c1             	setne  %cl
 8049c67:	eb 06                	jmp    8049c6f <cbvprintf+0x2c2>
		conv->invalid = true;
 8049c69:	80 4d c0 01          	orb    $0x1,-0x40(%ebp)
	bool unsupported = false;
 8049c6d:	31 c9                	xor    %ecx,%ecx
	conv->unsupported |= unsupported;
 8049c6f:	8a 55 c0             	mov    -0x40(%ebp),%dl
 8049c72:	89 d0                	mov    %edx,%eax
 8049c74:	83 e2 fd             	and    $0xfffffffd,%edx
 8049c77:	d0 e8                	shr    %al
 8049c79:	83 e0 01             	and    $0x1,%eax
 8049c7c:	09 c8                	or     %ecx,%eax
 8049c7e:	01 c0                	add    %eax,%eax
 8049c80:	09 d0                	or     %edx,%eax
 8049c82:	88 45 c0             	mov    %al,-0x40(%ebp)
		fp = extract_conversion(conv, sp);

		/* If dynamic width is specified, process it,
		 * otherwise set width if present.
		 */
		if (conv->width_star) {
 8049c85:	8a 55 c1             	mov    -0x3f(%ebp),%dl
 8049c88:	f6 c2 01             	test   $0x1,%dl
 8049c8b:	74 15                	je     8049ca2 <cbvprintf+0x2f5>
			width = va_arg(ap, int);
 8049c8d:	8d 43 04             	lea    0x4(%ebx),%eax
 8049c90:	8b 1b                	mov    (%ebx),%ebx
 8049c92:	89 5d a0             	mov    %ebx,-0x60(%ebp)

			if (width < 0) {
 8049c95:	85 db                	test   %ebx,%ebx
 8049c97:	79 22                	jns    8049cbb <cbvprintf+0x30e>
				conv->flag_dash = true;
 8049c99:	80 4d c0 04          	orb    $0x4,-0x40(%ebp)
				width = -width;
 8049c9d:	f7 5d a0             	negl   -0x60(%ebp)
 8049ca0:	eb 19                	jmp    8049cbb <cbvprintf+0x30e>
			}
		} else if (conv->width_present) {
 8049ca2:	80 7d c0 00          	cmpb   $0x0,-0x40(%ebp)
 8049ca6:	79 0a                	jns    8049cb2 <cbvprintf+0x305>
			width = conv->width_value;
 8049ca8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 8049cab:	89 45 a0             	mov    %eax,-0x60(%ebp)
 8049cae:	89 d8                	mov    %ebx,%eax
 8049cb0:	eb 09                	jmp    8049cbb <cbvprintf+0x30e>
		int width = -1;
 8049cb2:	c7 45 a0 ff ff ff ff 	movl   $0xffffffff,-0x60(%ebp)
 8049cb9:	89 d8                	mov    %ebx,%eax

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
 8049cbb:	f6 c2 04             	test   $0x4,%dl
 8049cbe:	74 0f                	je     8049ccf <cbvprintf+0x322>
			int arg = va_arg(ap, int);
 8049cc0:	8b 38                	mov    (%eax),%edi
 8049cc2:	8d 58 04             	lea    0x4(%eax),%ebx

			if (arg < 0) {
 8049cc5:	85 ff                	test   %edi,%edi
 8049cc7:	79 17                	jns    8049ce0 <cbvprintf+0x333>
				conv->prec_present = false;
 8049cc9:	80 65 c1 fd          	andb   $0xfd,-0x3f(%ebp)
 8049ccd:	eb 0e                	jmp    8049cdd <cbvprintf+0x330>
			} else {
				precision = arg;
			}
		} else if (conv->prec_present) {
 8049ccf:	80 e2 02             	and    $0x2,%dl
 8049cd2:	74 07                	je     8049cdb <cbvprintf+0x32e>
			precision = conv->prec_value;
 8049cd4:	8b 7d c8             	mov    -0x38(%ebp),%edi
 8049cd7:	89 c3                	mov    %eax,%ebx
 8049cd9:	eb 05                	jmp    8049ce0 <cbvprintf+0x333>
 8049cdb:	89 c3                	mov    %eax,%ebx
		int precision = -1;
 8049cdd:	83 cf ff             	or     $0xffffffff,%edi
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
 8049ce0:	8a 45 c1             	mov    -0x3f(%ebp),%al
			= (enum specifier_cat_enum)conv->specifier_cat;
 8049ce3:	8a 55 c2             	mov    -0x3e(%ebp),%dl
		conv->pad0_value = 0;
 8049ce6:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		conv->pad0_pre_exp = 0;
 8049ced:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
			= (enum length_mod_enum)conv->length_mod;
 8049cf4:	c0 e8 03             	shr    $0x3,%al
		enum specifier_cat_enum specifier_cat
 8049cf7:	83 e2 07             	and    $0x7,%edx
			= (enum length_mod_enum)conv->length_mod;
 8049cfa:	83 e0 0f             	and    $0xf,%eax
		enum length_mod_enum length_mod
 8049cfd:	0f b6 c8             	movzbl %al,%ecx
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
 8049d00:	83 fa 01             	cmp    $0x1,%edx
 8049d03:	75 1f                	jne    8049d24 <cbvprintf+0x377>
			switch (length_mod) {
 8049d05:	3c 05                	cmp    $0x5,%al
 8049d07:	74 28                	je     8049d31 <cbvprintf+0x384>
 8049d09:	77 39                	ja     8049d44 <cbvprintf+0x397>
 8049d0b:	3c 03                	cmp    $0x3,%al
 8049d0d:	74 06                	je     8049d15 <cbvprintf+0x368>
 8049d0f:	3c 04                	cmp    $0x4,%al
 8049d11:	74 1e                	je     8049d31 <cbvprintf+0x384>
 8049d13:	eb 2f                	jmp    8049d44 <cbvprintf+0x397>
				if (WCHAR_IS_SIGNED
				    && (conv->specifier == 'c')) {
					value->sint = (wchar_t)va_arg(ap,
							      WINT_TYPE);
				} else {
					value->sint = va_arg(ap, long);
 8049d15:	8b 0b                	mov    (%ebx),%ecx
 8049d17:	8d 53 04             	lea    0x4(%ebx),%edx
 8049d1a:	89 cb                	mov    %ecx,%ebx
 8049d1c:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
 8049d1f:	c1 fb 1f             	sar    $0x1f,%ebx
 8049d22:	eb 18                	jmp    8049d3c <cbvprintf+0x38f>
			if (length_mod == LENGTH_HH) {
				value->sint = (char)value->sint;
			} else if (length_mod == LENGTH_H) {
				value->sint = (short)value->sint;
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
 8049d24:	83 fa 02             	cmp    $0x2,%edx
 8049d27:	0f 85 97 00 00 00    	jne    8049dc4 <cbvprintf+0x417>
			switch (length_mod) {
 8049d2d:	3c 05                	cmp    $0x5,%al
 8049d2f:	75 44                	jne    8049d75 <cbvprintf+0x3c8>
				value->sint =
 8049d31:	8b 0b                	mov    (%ebx),%ecx
					(sint_value_type)va_arg(ap, long long);
 8049d33:	8d 53 08             	lea    0x8(%ebx),%edx
				value->sint =
 8049d36:	8b 5b 04             	mov    0x4(%ebx),%ebx
 8049d39:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
 8049d3c:	89 5d b8             	mov    %ebx,-0x48(%ebp)
				break;
 8049d3f:	e9 31 04 00 00       	jmp    804a175 <cbvprintf+0x7c8>
					(sint_value_type)va_arg(ap, ptrdiff_t);
 8049d44:	8b 13                	mov    (%ebx),%edx
 8049d46:	83 c3 04             	add    $0x4,%ebx
 8049d49:	89 55 b4             	mov    %edx,-0x4c(%ebp)
 8049d4c:	c1 fa 1f             	sar    $0x1f,%edx
 8049d4f:	89 55 b8             	mov    %edx,-0x48(%ebp)
			if (length_mod == LENGTH_HH) {
 8049d52:	83 f9 01             	cmp    $0x1,%ecx
 8049d55:	75 06                	jne    8049d5d <cbvprintf+0x3b0>
				value->sint = (char)value->sint;
 8049d57:	0f be 55 b4          	movsbl -0x4c(%ebp),%edx
 8049d5b:	eb 0d                	jmp    8049d6a <cbvprintf+0x3bd>
			} else if (length_mod == LENGTH_H) {
 8049d5d:	83 f9 02             	cmp    $0x2,%ecx
 8049d60:	0f 85 89 00 00 00    	jne    8049def <cbvprintf+0x442>
				value->sint = (short)value->sint;
 8049d66:	0f bf 55 b4          	movswl -0x4c(%ebp),%edx
 8049d6a:	89 55 b4             	mov    %edx,-0x4c(%ebp)
 8049d6d:	c1 fa 1f             	sar    $0x1f,%edx
 8049d70:	89 55 b8             	mov    %edx,-0x48(%ebp)
 8049d73:	eb 7a                	jmp    8049def <cbvprintf+0x442>
			switch (length_mod) {
 8049d75:	77 1e                	ja     8049d95 <cbvprintf+0x3e8>
 8049d77:	3c 03                	cmp    $0x3,%al
 8049d79:	74 06                	je     8049d81 <cbvprintf+0x3d4>
 8049d7b:	3c 04                	cmp    $0x4,%al
 8049d7d:	74 b2                	je     8049d31 <cbvprintf+0x384>
 8049d7f:	eb 14                	jmp    8049d95 <cbvprintf+0x3e8>
				if ((!WCHAR_IS_SIGNED)
				    && (conv->specifier == 'c')) {
					value->uint = (wchar_t)va_arg(ap,
							      WINT_TYPE);
				} else {
					value->uint = va_arg(ap, unsigned long);
 8049d81:	8d 53 04             	lea    0x4(%ebx),%edx
 8049d84:	8b 1b                	mov    (%ebx),%ebx
 8049d86:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 8049d8d:	89 5d b4             	mov    %ebx,-0x4c(%ebp)
				}
				break;
 8049d90:	e9 e0 03 00 00       	jmp    804a175 <cbvprintf+0x7c8>
								uintmax_t);
				break;
			case LENGTH_Z:		/* size_t */
			case LENGTH_T:		/* ptrdiff_t */
				value->uint =
					(uint_value_type)va_arg(ap, size_t);
 8049d95:	8b 33                	mov    (%ebx),%esi
 8049d97:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 8049d9e:	83 c3 04             	add    $0x4,%ebx
 8049da1:	89 75 b4             	mov    %esi,-0x4c(%ebp)
				break;
			}
			if (length_mod == LENGTH_HH) {
 8049da4:	83 f9 01             	cmp    $0x1,%ecx
 8049da7:	75 06                	jne    8049daf <cbvprintf+0x402>
				value->uint = (unsigned char)value->uint;
 8049da9:	0f b6 55 b4          	movzbl -0x4c(%ebp),%edx
 8049dad:	eb 09                	jmp    8049db8 <cbvprintf+0x40b>
			} else if (length_mod == LENGTH_H) {
 8049daf:	83 f9 02             	cmp    $0x2,%ecx
 8049db2:	75 3b                	jne    8049def <cbvprintf+0x442>
				value->uint = (unsigned short)value->uint;
 8049db4:	0f b7 55 b4          	movzwl -0x4c(%ebp),%edx
 8049db8:	89 55 b4             	mov    %edx,-0x4c(%ebp)
 8049dbb:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
 8049dc2:	eb 2b                	jmp    8049def <cbvprintf+0x442>
			}
		} else if (specifier_cat == SPECIFIER_FP) {
 8049dc4:	83 fa 04             	cmp    $0x4,%edx
 8049dc7:	75 19                	jne    8049de2 <cbvprintf+0x435>
			if (length_mod == LENGTH_UPPER_L) {
 8049dc9:	83 f9 08             	cmp    $0x8,%ecx
 8049dcc:	75 0a                	jne    8049dd8 <cbvprintf+0x42b>
				value->ldbl = va_arg(ap, long double);
 8049dce:	db 2b                	fldt   (%ebx)
 8049dd0:	83 c3 0c             	add    $0xc,%ebx
 8049dd3:	db 7d b4             	fstpt  -0x4c(%ebp)
 8049dd6:	eb 17                	jmp    8049def <cbvprintf+0x442>
			} else {
				value->dbl = va_arg(ap, double);
 8049dd8:	dd 03                	fldl   (%ebx)
 8049dda:	83 c3 08             	add    $0x8,%ebx
 8049ddd:	dd 5d b4             	fstpl  -0x4c(%ebp)
 8049de0:	eb 0d                	jmp    8049def <cbvprintf+0x442>
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
 8049de2:	83 fa 03             	cmp    $0x3,%edx
 8049de5:	75 08                	jne    8049def <cbvprintf+0x442>
			value->ptr = va_arg(ap, void *);
 8049de7:	8b 13                	mov    (%ebx),%edx
 8049de9:	83 c3 04             	add    $0x4,%ebx
 8049dec:	89 55 b4             	mov    %edx,-0x4c(%ebp)
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
 8049def:	8a 55 c0             	mov    -0x40(%ebp),%dl
 8049df2:	f6 c2 03             	test   $0x3,%dl
 8049df5:	74 27                	je     8049e1e <cbvprintf+0x471>
			OUTS(sp, fp);
 8049df7:	83 ec 0c             	sub    $0xc,%esp
 8049dfa:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
 8049dfd:	8b 55 94             	mov    -0x6c(%ebp),%edx
 8049e00:	ff 75 90             	pushl  -0x70(%ebp)
 8049e03:	8b 45 98             	mov    -0x68(%ebp),%eax
 8049e06:	e8 45 fa ff ff       	call   8049850 <outs>
 8049e0b:	83 c4 10             	add    $0x10,%esp
 8049e0e:	85 c0                	test   %eax,%eax
 8049e10:	0f 88 66 03 00 00    	js     804a17c <cbvprintf+0x7cf>
 8049e16:	01 45 a4             	add    %eax,-0x5c(%ebp)
			continue;
 8049e19:	e9 47 03 00 00       	jmp    804a165 <cbvprintf+0x7b8>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
 8049e1e:	8a 4d c3             	mov    -0x3d(%ebp),%cl
 8049e21:	80 f9 78             	cmp    $0x78,%cl
 8049e24:	0f 87 3b 03 00 00    	ja     804a165 <cbvprintf+0x7b8>
 8049e2a:	80 f9 62             	cmp    $0x62,%cl
 8049e2d:	77 13                	ja     8049e42 <cbvprintf+0x495>
 8049e2f:	80 f9 25             	cmp    $0x25,%cl
 8049e32:	74 25                	je     8049e59 <cbvprintf+0x4ac>
 8049e34:	80 f9 58             	cmp    $0x58,%cl
 8049e37:	0f 84 bb 00 00 00    	je     8049ef8 <cbvprintf+0x54b>
 8049e3d:	e9 23 03 00 00       	jmp    804a165 <cbvprintf+0x7b8>
 8049e42:	83 e9 63             	sub    $0x63,%ecx
 8049e45:	80 f9 15             	cmp    $0x15,%cl
 8049e48:	0f 87 17 03 00 00    	ja     804a165 <cbvprintf+0x7b8>
 8049e4e:	0f b6 c9             	movzbl %cl,%ecx
 8049e51:	3e ff 24 8d 88 e0 04 	notrack jmp *0x804e088(,%ecx,4)
 8049e58:	08 
		case '%':
			OUTC('%');
 8049e59:	51                   	push   %ecx
 8049e5a:	51                   	push   %ecx
 8049e5b:	ff 75 94             	pushl  -0x6c(%ebp)
 8049e5e:	6a 25                	push   $0x25
 8049e60:	8b 45 98             	mov    -0x68(%ebp),%eax
 8049e63:	ff d0                	call   *%eax
 8049e65:	83 c4 10             	add    $0x10,%esp
 8049e68:	85 c0                	test   %eax,%eax
 8049e6a:	0f 88 0c 03 00 00    	js     804a17c <cbvprintf+0x7cf>
 8049e70:	ff 45 a4             	incl   -0x5c(%ebp)
			break;
 8049e73:	e9 ed 02 00 00       	jmp    804a165 <cbvprintf+0x7b8>
		case 's': {
			bps = (const char *)value->ptr;
 8049e78:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 8049e7b:	89 45 9c             	mov    %eax,-0x64(%ebp)

			size_t len;

			if (precision >= 0) {
 8049e7e:	85 ff                	test   %edi,%edi
 8049e80:	78 0e                	js     8049e90 <cbvprintf+0x4e3>
				len = strnlen(bps, precision);
 8049e82:	52                   	push   %edx
 8049e83:	52                   	push   %edx
 8049e84:	57                   	push   %edi
 8049e85:	50                   	push   %eax
 8049e86:	e8 05 f6 ff ff       	call   8049490 <strnlen@plt>
 8049e8b:	83 c4 10             	add    $0x10,%esp
 8049e8e:	eb 0f                	jmp    8049e9f <cbvprintf+0x4f2>
			} else {
				len = strlen(bps);
 8049e90:	8b 7d 9c             	mov    -0x64(%ebp),%edi
 8049e93:	31 c0                	xor    %eax,%eax
 8049e95:	83 c9 ff             	or     $0xffffffff,%ecx
 8049e98:	f2 ae                	repnz scas %es:(%edi),%al
 8049e9a:	89 c8                	mov    %ecx,%eax
 8049e9c:	f7 d0                	not    %eax
 8049e9e:	48                   	dec    %eax
			}

			bpe = bps + len;
 8049e9f:	03 45 9c             	add    -0x64(%ebp),%eax
		char sign = 0;
 8049ea2:	31 f6                	xor    %esi,%esi
			bpe = bps + len;
 8049ea4:	89 45 8c             	mov    %eax,-0x74(%ebp)
			precision = -1;

			break;
 8049ea7:	e9 16 01 00 00       	jmp    8049fc2 <cbvprintf+0x615>
		}
		case 'c':
			bps = buf;
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
 8049eac:	8b 45 b4             	mov    -0x4c(%ebp),%eax
			bpe = buf + 1;
			break;
 8049eaf:	31 f6                	xor    %esi,%esi
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
 8049eb1:	88 45 ce             	mov    %al,-0x32(%ebp)
			bpe = buf + 1;
 8049eb4:	8d 45 cf             	lea    -0x31(%ebp),%eax
 8049eb7:	89 45 8c             	mov    %eax,-0x74(%ebp)
			bps = buf;
 8049eba:	8d 45 ce             	lea    -0x32(%ebp),%eax
 8049ebd:	89 45 9c             	mov    %eax,-0x64(%ebp)
			break;
 8049ec0:	e9 18 01 00 00       	jmp    8049fdd <cbvprintf+0x630>
		case 'd':
		case 'i':
			if (conv->flag_plus) {
				sign = '+';
 8049ec5:	be 2b 00 00 00       	mov    $0x2b,%esi
			if (conv->flag_plus) {
 8049eca:	f6 c2 08             	test   $0x8,%dl
 8049ecd:	75 0b                	jne    8049eda <cbvprintf+0x52d>
			} else if (conv->flag_space) {
				sign = ' ';
 8049ecf:	80 e2 10             	and    $0x10,%dl
 8049ed2:	0f 95 c0             	setne  %al
 8049ed5:	c1 e0 05             	shl    $0x5,%eax
 8049ed8:	89 c6                	mov    %eax,%esi

			/* sint/uint overlay in the union, and so
			 * can't appear in read and write operations
			 * in the same statement.
			 */
			sint = value->sint;
 8049eda:	8b 55 b8             	mov    -0x48(%ebp),%edx
 8049edd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
			if (sint < 0) {
 8049ee0:	85 d2                	test   %edx,%edx
 8049ee2:	79 16                	jns    8049efa <cbvprintf+0x54d>
				sign = '-';
				value->uint = (uint_value_type)-sint;
 8049ee4:	f7 d8                	neg    %eax
				sign = '-';
 8049ee6:	be 2d 00 00 00       	mov    $0x2d,%esi
				value->uint = (uint_value_type)-sint;
 8049eeb:	83 d2 00             	adc    $0x0,%edx
 8049eee:	89 45 b4             	mov    %eax,-0x4c(%ebp)
 8049ef1:	f7 da                	neg    %edx
 8049ef3:	89 55 b8             	mov    %edx,-0x48(%ebp)
 8049ef6:	eb 02                	jmp    8049efa <cbvprintf+0x54d>
		switch (conv->specifier) {
 8049ef8:	31 f6                	xor    %esi,%esi
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value->uint, conv, buf, bpe);
 8049efa:	8d 55 e4             	lea    -0x1c(%ebp),%edx
 8049efd:	50                   	push   %eax
 8049efe:	8d 4d c0             	lea    -0x40(%ebp),%ecx
 8049f01:	50                   	push   %eax
 8049f02:	8d 45 ce             	lea    -0x32(%ebp),%eax
 8049f05:	52                   	push   %edx
 8049f06:	8b 55 b8             	mov    -0x48(%ebp),%edx
 8049f09:	50                   	push   %eax
 8049f0a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 8049f0d:	e8 c0 f9 ff ff       	call   80498d2 <encode_uint>
 8049f12:	83 c4 10             	add    $0x10,%esp
 8049f15:	89 45 9c             	mov    %eax,-0x64(%ebp)
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
 8049f18:	85 ff                	test   %edi,%edi
 8049f1a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8049f1d:	0f 88 9c 00 00 00    	js     8049fbf <cbvprintf+0x612>
				size_t len = bpe - bps;
 8049f23:	89 c2                	mov    %eax,%edx
 8049f25:	2b 55 9c             	sub    -0x64(%ebp),%edx

				/* Zero-padding flag is ignored for integer
				 * conversions with precision.
				 */
				conv->flag_zero = false;
 8049f28:	80 65 c0 bf          	andb   $0xbf,-0x40(%ebp)
		const char *bpe = buf + sizeof(buf);
 8049f2c:	89 45 8c             	mov    %eax,-0x74(%ebp)

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
 8049f2f:	39 d7                	cmp    %edx,%edi
 8049f31:	0f 86 8b 00 00 00    	jbe    8049fc2 <cbvprintf+0x615>
					conv->pad0_value = precision - (int)len;
 8049f37:	29 d7                	sub    %edx,%edi
 8049f39:	89 7d c4             	mov    %edi,-0x3c(%ebp)
 8049f3c:	e9 81 00 00 00       	jmp    8049fc2 <cbvprintf+0x615>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value->ptr != NULL) {
 8049f41:	8b 45 b4             	mov    -0x4c(%ebp),%eax
 8049f44:	85 c0                	test   %eax,%eax
 8049f46:	0f 84 81 00 00 00    	je     8049fcd <cbvprintf+0x620>
				bps = encode_uint((uintptr_t)value->ptr, conv,
 8049f4c:	8d 75 e4             	lea    -0x1c(%ebp),%esi
 8049f4f:	51                   	push   %ecx
 8049f50:	31 d2                	xor    %edx,%edx
 8049f52:	51                   	push   %ecx
 8049f53:	8d 4d ce             	lea    -0x32(%ebp),%ecx
 8049f56:	56                   	push   %esi
		char sign = 0;
 8049f57:	31 f6                	xor    %esi,%esi
				bps = encode_uint((uintptr_t)value->ptr, conv,
 8049f59:	51                   	push   %ecx
 8049f5a:	8d 4d c0             	lea    -0x40(%ebp),%ecx
 8049f5d:	e8 70 f9 ff ff       	call   80498d2 <encode_uint>
 8049f62:	83 c4 10             	add    $0x10,%esp
 8049f65:	89 45 9c             	mov    %eax,-0x64(%ebp)
						  buf, bpe);

				/* Use 0x prefix */
				conv->altform_0c = true;
 8049f68:	66 8b 45 c2          	mov    -0x3e(%ebp),%ax
 8049f6c:	66 25 ef 00          	and    $0xef,%ax
 8049f70:	66 0d 10 78          	or     $0x7810,%ax
 8049f74:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
				conv->specifier = 'x';

				goto prec_int_pad0;
 8049f78:	eb 9e                	jmp    8049f18 <cbvprintf+0x56b>
			bpe = bps + 5;

			break;
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(conv, value->ptr, count);
 8049f7a:	8b 55 b4             	mov    -0x4c(%ebp),%edx
	switch ((enum length_mod_enum)conv->length_mod) {
 8049f7d:	3c 07                	cmp    $0x7,%al
 8049f7f:	0f 87 e0 01 00 00    	ja     804a165 <cbvprintf+0x7b8>
 8049f85:	0f b6 c0             	movzbl %al,%eax
 8049f88:	3e ff 24 85 e0 e0 04 	notrack jmp *0x804e0e0(,%eax,4)
 8049f8f:	08 
		*(signed char *)dp = (signed char)count;
 8049f90:	8a 45 a4             	mov    -0x5c(%ebp),%al
 8049f93:	88 02                	mov    %al,(%edx)
		break;
 8049f95:	e9 cb 01 00 00       	jmp    804a165 <cbvprintf+0x7b8>
		*(short *)dp = (short)count;
 8049f9a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8049f9d:	66 89 02             	mov    %ax,(%edx)
		break;
 8049fa0:	e9 c0 01 00 00       	jmp    804a165 <cbvprintf+0x7b8>
		*(intmax_t *)dp = (intmax_t)count;
 8049fa5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8049fa8:	89 02                	mov    %eax,(%edx)
 8049faa:	c1 f8 1f             	sar    $0x1f,%eax
 8049fad:	89 42 04             	mov    %eax,0x4(%edx)
		break;
 8049fb0:	e9 b0 01 00 00       	jmp    804a165 <cbvprintf+0x7b8>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
 8049fb5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 8049fb8:	89 02                	mov    %eax,(%edx)
		break;
 8049fba:	e9 a6 01 00 00       	jmp    804a165 <cbvprintf+0x7b8>
		const char *bpe = buf + sizeof(buf);
 8049fbf:	89 45 8c             	mov    %eax,-0x74(%ebp)
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
 8049fc2:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
 8049fc6:	75 15                	jne    8049fdd <cbvprintf+0x630>
 8049fc8:	e9 98 01 00 00       	jmp    804a165 <cbvprintf+0x7b8>
			bpe = bps + 5;
 8049fcd:	c7 45 8c f7 e1 04 08 	movl   $0x804e1f7,-0x74(%ebp)
 8049fd4:	31 f6                	xor    %esi,%esi
			bps = "(nil)";
 8049fd6:	c7 45 9c f2 e1 04 08 	movl   $0x804e1f2,-0x64(%ebp)
		 */
		size_t nj_len = (bpe - bps);
		int pad_len = 0;

		if (sign != 0) {
			nj_len += 1U;
 8049fdd:	89 f1                	mov    %esi,%ecx
		}

		if (conv->altform_0c) {
 8049fdf:	8a 55 c2             	mov    -0x3e(%ebp),%dl
		size_t nj_len = (bpe - bps);
 8049fe2:	8b 45 8c             	mov    -0x74(%ebp),%eax
 8049fe5:	2b 45 9c             	sub    -0x64(%ebp),%eax
			nj_len += 1U;
 8049fe8:	80 f9 01             	cmp    $0x1,%cl
 8049feb:	83 d8 ff             	sbb    $0xffffffff,%eax
		if (conv->altform_0c) {
 8049fee:	f6 c2 10             	test   $0x10,%dl
 8049ff1:	74 05                	je     8049ff8 <cbvprintf+0x64b>
			nj_len += 2U;
 8049ff3:	83 c0 02             	add    $0x2,%eax
 8049ff6:	eb 0b                	jmp    804a003 <cbvprintf+0x656>
		} else if (conv->altform_0) {
 8049ff8:	89 d1                	mov    %edx,%ecx
 8049ffa:	83 e1 08             	and    $0x8,%ecx
			nj_len += 1U;
 8049ffd:	80 f9 01             	cmp    $0x1,%cl
 804a000:	83 d8 ff             	sbb    $0xffffffff,%eax
		}

		nj_len += conv->pad0_value;
 804a003:	03 45 c4             	add    -0x3c(%ebp),%eax
		if (conv->pad_fp) {
 804a006:	80 e2 40             	and    $0x40,%dl
 804a009:	74 03                	je     804a00e <cbvprintf+0x661>
			nj_len += conv->pad0_pre_exp;
 804a00b:	03 45 c8             	add    -0x38(%ebp),%eax
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
 804a00e:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
 804a012:	7e 7c                	jle    804a090 <cbvprintf+0x6e3>
			width -= (int)nj_len;
 804a014:	8b 7d a0             	mov    -0x60(%ebp),%edi
 804a017:	29 c7                	sub    %eax,%edi

			if (!conv->flag_dash) {
 804a019:	8a 45 c0             	mov    -0x40(%ebp),%al
 804a01c:	a8 04                	test   $0x4,%al
 804a01e:	75 6d                	jne    804a08d <cbvprintf+0x6e0>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
 804a020:	a8 40                	test   $0x40,%al
 804a022:	74 26                	je     804a04a <cbvprintf+0x69d>
					if (sign != 0) {
 804a024:	89 f0                	mov    %esi,%eax
 804a026:	84 c0                	test   %al,%al
 804a028:	74 27                	je     804a051 <cbvprintf+0x6a4>
						OUTC(sign);
 804a02a:	0f be f0             	movsbl %al,%esi
 804a02d:	52                   	push   %edx
 804a02e:	8b 45 98             	mov    -0x68(%ebp),%eax
 804a031:	52                   	push   %edx
 804a032:	ff 75 94             	pushl  -0x6c(%ebp)
 804a035:	56                   	push   %esi
 804a036:	ff d0                	call   *%eax
 804a038:	83 c4 10             	add    $0x10,%esp
 804a03b:	85 c0                	test   %eax,%eax
 804a03d:	0f 88 39 01 00 00    	js     804a17c <cbvprintf+0x7cf>
 804a043:	ff 45 a4             	incl   -0x5c(%ebp)
						sign = 0;
 804a046:	31 f6                	xor    %esi,%esi
 804a048:	eb 07                	jmp    804a051 <cbvprintf+0x6a4>
				char pad = ' ';
 804a04a:	ba 20 00 00 00       	mov    $0x20,%edx
 804a04f:	eb 05                	jmp    804a056 <cbvprintf+0x6a9>
					}
					pad = '0';
 804a051:	ba 30 00 00 00       	mov    $0x30,%edx
 804a056:	89 7d a0             	mov    %edi,-0x60(%ebp)
 804a059:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804a05c:	8b 4d a0             	mov    -0x60(%ebp),%ecx
 804a05f:	01 f8                	add    %edi,%eax
 804a061:	2b 45 a0             	sub    -0x60(%ebp),%eax
				}

				while (width-- > 0) {
 804a064:	ff 4d a0             	decl   -0x60(%ebp)
 804a067:	85 c9                	test   %ecx,%ecx
 804a069:	7e 1d                	jle    804a088 <cbvprintf+0x6db>
					OUTC(pad);
 804a06b:	50                   	push   %eax
 804a06c:	50                   	push   %eax
 804a06d:	8b 45 98             	mov    -0x68(%ebp),%eax
 804a070:	ff 75 94             	pushl  -0x6c(%ebp)
 804a073:	52                   	push   %edx
 804a074:	89 55 88             	mov    %edx,-0x78(%ebp)
 804a077:	ff d0                	call   *%eax
 804a079:	8b 55 88             	mov    -0x78(%ebp),%edx
 804a07c:	83 c4 10             	add    $0x10,%esp
 804a07f:	85 c0                	test   %eax,%eax
 804a081:	79 d6                	jns    804a059 <cbvprintf+0x6ac>
 804a083:	e9 f4 00 00 00       	jmp    804a17c <cbvprintf+0x7cf>
 804a088:	89 45 a4             	mov    %eax,-0x5c(%ebp)
 804a08b:	eb 03                	jmp    804a090 <cbvprintf+0x6e3>
			width -= (int)nj_len;
 804a08d:	89 7d a0             	mov    %edi,-0x60(%ebp)
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
 804a090:	89 f0                	mov    %esi,%eax
 804a092:	84 c0                	test   %al,%al
 804a094:	74 1c                	je     804a0b2 <cbvprintf+0x705>
			OUTC(sign);
 804a096:	0f be f0             	movsbl %al,%esi
 804a099:	57                   	push   %edi
 804a09a:	8b 45 98             	mov    -0x68(%ebp),%eax
 804a09d:	57                   	push   %edi
 804a09e:	ff 75 94             	pushl  -0x6c(%ebp)
 804a0a1:	56                   	push   %esi
 804a0a2:	ff d0                	call   *%eax
 804a0a4:	83 c4 10             	add    $0x10,%esp
 804a0a7:	85 c0                	test   %eax,%eax
 804a0a9:	0f 88 cd 00 00 00    	js     804a17c <cbvprintf+0x7cf>
 804a0af:	ff 45 a4             	incl   -0x5c(%ebp)
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
 804a0b2:	8a 45 c2             	mov    -0x3e(%ebp),%al
 804a0b5:	a8 10                	test   $0x10,%al
 804a0b7:	75 04                	jne    804a0bd <cbvprintf+0x710>
 804a0b9:	a8 08                	test   $0x8,%al
 804a0bb:	74 1a                	je     804a0d7 <cbvprintf+0x72a>
				OUTC('0');
 804a0bd:	56                   	push   %esi
 804a0be:	8b 45 98             	mov    -0x68(%ebp),%eax
 804a0c1:	56                   	push   %esi
 804a0c2:	ff 75 94             	pushl  -0x6c(%ebp)
 804a0c5:	6a 30                	push   $0x30
 804a0c7:	ff d0                	call   *%eax
 804a0c9:	83 c4 10             	add    $0x10,%esp
 804a0cc:	85 c0                	test   %eax,%eax
 804a0ce:	0f 88 a8 00 00 00    	js     804a17c <cbvprintf+0x7cf>
 804a0d4:	ff 45 a4             	incl   -0x5c(%ebp)
			}

			if (conv->altform_0c) {
 804a0d7:	f6 45 c2 10          	testb  $0x10,-0x3e(%ebp)
 804a0db:	74 1d                	je     804a0fa <cbvprintf+0x74d>
				OUTC(conv->specifier);
 804a0dd:	0f b6 45 c3          	movzbl -0x3d(%ebp),%eax
 804a0e1:	51                   	push   %ecx
 804a0e2:	51                   	push   %ecx
 804a0e3:	ff 75 94             	pushl  -0x6c(%ebp)
 804a0e6:	50                   	push   %eax
 804a0e7:	8b 45 98             	mov    -0x68(%ebp),%eax
 804a0ea:	ff d0                	call   *%eax
 804a0ec:	83 c4 10             	add    $0x10,%esp
 804a0ef:	85 c0                	test   %eax,%eax
 804a0f1:	0f 88 85 00 00 00    	js     804a17c <cbvprintf+0x7cf>
 804a0f7:	ff 45 a4             	incl   -0x5c(%ebp)
			}

			pad_len = conv->pad0_value;
 804a0fa:	8b 7d c4             	mov    -0x3c(%ebp),%edi
			while (pad_len-- > 0) {
 804a0fd:	8b 75 a4             	mov    -0x5c(%ebp),%esi
 804a100:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804a103:	01 f8                	add    %edi,%eax
 804a105:	29 f0                	sub    %esi,%eax
 804a107:	85 c0                	test   %eax,%eax
 804a109:	7e 16                	jle    804a121 <cbvprintf+0x774>
				OUTC('0');
 804a10b:	52                   	push   %edx
 804a10c:	8b 45 98             	mov    -0x68(%ebp),%eax
 804a10f:	52                   	push   %edx
 804a110:	ff 75 94             	pushl  -0x6c(%ebp)
 804a113:	6a 30                	push   $0x30
 804a115:	ff d0                	call   *%eax
 804a117:	83 c4 10             	add    $0x10,%esp
 804a11a:	85 c0                	test   %eax,%eax
 804a11c:	78 5e                	js     804a17c <cbvprintf+0x7cf>
 804a11e:	46                   	inc    %esi
 804a11f:	eb df                	jmp    804a100 <cbvprintf+0x753>
			}

			OUTS(bps, bpe);
 804a121:	83 ec 0c             	sub    $0xc,%esp
 804a124:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
 804a127:	8b 55 94             	mov    -0x6c(%ebp),%edx
 804a12a:	ff 75 8c             	pushl  -0x74(%ebp)
 804a12d:	8b 45 98             	mov    -0x68(%ebp),%eax
 804a130:	e8 1b f7 ff ff       	call   8049850 <outs>
 804a135:	83 c4 10             	add    $0x10,%esp
 804a138:	85 c0                	test   %eax,%eax
 804a13a:	78 40                	js     804a17c <cbvprintf+0x7cf>
 804a13c:	01 c6                	add    %eax,%esi
 804a13e:	89 75 a4             	mov    %esi,-0x5c(%ebp)
		}

		/* Finish left justification */
		while (width > 0) {
 804a141:	8b 45 a0             	mov    -0x60(%ebp),%eax
 804a144:	01 f0                	add    %esi,%eax
 804a146:	2b 45 a4             	sub    -0x5c(%ebp),%eax
 804a149:	85 c0                	test   %eax,%eax
 804a14b:	7e 18                	jle    804a165 <cbvprintf+0x7b8>
			OUTC(' ');
 804a14d:	50                   	push   %eax
 804a14e:	50                   	push   %eax
 804a14f:	8b 45 98             	mov    -0x68(%ebp),%eax
 804a152:	ff 75 94             	pushl  -0x6c(%ebp)
 804a155:	6a 20                	push   $0x20
 804a157:	ff d0                	call   *%eax
 804a159:	83 c4 10             	add    $0x10,%esp
 804a15c:	85 c0                	test   %eax,%eax
 804a15e:	78 1c                	js     804a17c <cbvprintf+0x7cf>
 804a160:	ff 45 a4             	incl   -0x5c(%ebp)
 804a163:	eb dc                	jmp    804a141 <cbvprintf+0x794>
			OUTS(bps, bpe);
 804a165:	8b 45 90             	mov    -0x70(%ebp),%eax
 804a168:	89 45 9c             	mov    %eax,-0x64(%ebp)
 804a16b:	e9 71 f8 ff ff       	jmp    80499e1 <cbvprintf+0x34>
			--width;
		}
	}

	return count;
 804a170:	8b 45 a4             	mov    -0x5c(%ebp),%eax
 804a173:	eb 07                	jmp    804a17c <cbvprintf+0x7cf>
					(uint_value_type)va_arg(ap, size_t);
 804a175:	89 d3                	mov    %edx,%ebx
 804a177:	e9 73 fc ff ff       	jmp    8049def <cbvprintf+0x442>
#undef OUTS
#undef OUTC
}
 804a17c:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
 804a17f:	65 33 1d 14 00 00 00 	xor    %gs:0x14,%ebx
 804a186:	74 05                	je     804a18d <cbvprintf+0x7e0>
 804a188:	e8 03 f2 ff ff       	call   8049390 <__stack_chk_fail@plt>
 804a18d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804a190:	5b                   	pop    %ebx
 804a191:	5e                   	pop    %esi
 804a192:	5f                   	pop    %edi
 804a193:	5d                   	pop    %ebp
 804a194:	c3                   	ret    

0804a195 <assert_print>:

	k_panic();
}

void assert_print(const char *fmt, ...)
{
 804a195:	f3 0f 1e fb          	endbr32 
 804a199:	55                   	push   %ebp
 804a19a:	89 e5                	mov    %esp,%ebp
 804a19c:	83 ec 10             	sub    $0x10,%esp
	va_list ap;

	va_start(ap, fmt);
 804a19f:	8d 45 0c             	lea    0xc(%ebp),%eax

	vprintk(fmt, ap);
 804a1a2:	50                   	push   %eax
 804a1a3:	ff 75 08             	pushl  0x8(%ebp)
 804a1a6:	e8 06 f6 ff ff       	call   80497b1 <vprintk>
 804a1ab:	83 c4 10             	add    $0x10,%esp

	va_end(ap);
}
 804a1ae:	c9                   	leave  
 804a1af:	c3                   	ret    

0804a1b0 <_ConfigAbsSyms>:

/* file is auto-generated, do not modify ! */

#include <zephyr/toolchain.h>

GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
 804a1b0:	f3 0f 1e fb          	endbr32 
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_STAT, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_LEGACY_INCLUDE_PATH, 1);

GEN_ABS_SYM_END
 804a1b4:	c3                   	ret    

0804a1b5 <__cxa_atexit>:
 * do not need to be deleted
 *
 * @retval 0 on success.
 */
int __cxa_atexit(void (*destructor)(void *), void *objptr, void *dso)
{
 804a1b5:	f3 0f 1e fb          	endbr32 
	ARG_UNUSED(destructor);
	ARG_UNUSED(objptr);
	ARG_UNUSED(dso);
	return 0;
}
 804a1b9:	31 c0                	xor    %eax,%eax
 804a1bb:	c3                   	ret    

0804a1bc <sys_trace_isr_enter>:

#include <zephyr/init.h>
#include <string.h>
#include <zephyr/kernel.h>

void sys_trace_isr_enter(void) {}
 804a1bc:	f3 0f 1e fb          	endbr32 
 804a1c0:	c3                   	ret    

0804a1c1 <sys_trace_isr_exit>:
 804a1c1:	f3 0f 1e fb          	endbr32 
 804a1c5:	c3                   	ret    

0804a1c6 <sys_trace_idle>:
 804a1c6:	f3 0f 1e fb          	endbr32 
 804a1ca:	c3                   	ret    

0804a1cb <arch_cpu_idle>:
 * arch_busy_wait()
 */
#endif

void arch_cpu_idle(void)
{
 804a1cb:	f3 0f 1e fb          	endbr32 
 804a1cf:	55                   	push   %ebp
 804a1d0:	89 e5                	mov    %esp,%ebp
 804a1d2:	83 ec 08             	sub    $0x8,%esp
	sys_trace_idle();
 804a1d5:	e8 ec ff ff ff       	call   804a1c6 <sys_trace_idle>
	posix_irq_full_unlock();
 804a1da:	e8 7c 12 00 00       	call   804b45b <posix_irq_full_unlock>
	posix_halt_cpu();
}
 804a1df:	c9                   	leave  
	posix_halt_cpu();
 804a1e0:	e9 95 06 00 00       	jmp    804a87a <posix_halt_cpu>

0804a1e5 <arch_system_halt>:
#include <inttypes.h>
#include <zephyr/logging/log_ctrl.h>
#include <zephyr/arch/posix/posix_soc_if.h>

FUNC_NORETURN void arch_system_halt(unsigned int reason)
{
 804a1e5:	f3 0f 1e fb          	endbr32 
 804a1e9:	55                   	push   %ebp
 804a1ea:	89 e5                	mov    %esp,%ebp
 804a1ec:	83 ec 14             	sub    $0x14,%esp
	ARG_UNUSED(reason);

	posix_print_error_and_exit("Exiting due to fatal error\n");
 804a1ef:	68 f8 e1 04 08       	push   $0x804e1f8
 804a1f4:	e8 f5 16 00 00       	call   804b8ee <posix_print_error_and_exit>
 804a1f9:	83 c4 0c             	add    $0xc,%esp
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 804a1fc:	6a 15                	push   $0x15
 804a1fe:	68 14 e2 04 08       	push   $0x804e214
 804a203:	68 cd e1 04 08       	push   $0x804e1cd
 804a208:	e8 e1 16 00 00       	call   804b8ee <posix_print_error_and_exit>
 804a20d:	83 c4 10             	add    $0x10,%esp

0804a210 <arch_irq_enable>:
	posix_irq_offload(routine, parameter);
}
#endif

void arch_irq_enable(unsigned int irq)
{
 804a210:	f3 0f 1e fb          	endbr32 
	posix_irq_enable(irq);
 804a214:	e9 58 12 00 00       	jmp    804b471 <posix_irq_enable>

0804a219 <pc_safe_call>:
#endif

static inline void pc_safe_call(int test, const char *test_str)
{
	/* LCOV_EXCL_START */ /* See Note1 */
	if (unlikely(test)) {
 804a219:	85 c0                	test   %eax,%eax
 804a21b:	74 16                	je     804a233 <pc_safe_call+0x1a>
{
 804a21d:	55                   	push   %ebp
 804a21e:	89 e5                	mov    %esp,%ebp
 804a220:	83 ec 10             	sub    $0x10,%esp
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804a223:	52                   	push   %edx
 804a224:	68 3f e2 04 08       	push   $0x804e23f
 804a229:	e8 c0 16 00 00       	call   804b8ee <posix_print_error_and_exit>
 804a22e:	83 c4 10             	add    $0x10,%esp
					   test_str);
	}
	/* LCOV_EXCL_STOP */
}
 804a231:	c9                   	leave  
 804a232:	c3                   	ret    
 804a233:	c3                   	ret    

0804a234 <posix_preexit_cleanup>:
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
}


static void posix_preexit_cleanup(void)
{
 804a234:	55                   	push   %ebp
 804a235:	89 e5                	mov    %esp,%ebp
 804a237:	83 ec 14             	sub    $0x14,%esp
	/*
	 * Release the mutex so the next allowed thread can run
	 */
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
 804a23a:	68 2c 29 05 08       	push   $0x805292c
 804a23f:	e8 8c f0 ff ff       	call   80492d0 <pthread_mutex_unlock@plt>
 804a244:	83 c4 10             	add    $0x10,%esp
 804a247:	ba 59 e2 04 08       	mov    $0x804e259,%edx
 804a24c:	e8 c8 ff ff ff       	call   804a219 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
 804a251:	e8 0a f1 ff ff       	call   8049360 <pthread_self@plt>
 804a256:	83 ec 0c             	sub    $0xc,%esp
 804a259:	50                   	push   %eax
 804a25a:	e8 b1 f2 ff ff       	call   8049510 <pthread_detach@plt>
 804a25f:	83 c4 10             	add    $0x10,%esp
}
 804a262:	c9                   	leave  
 804a263:	c3                   	ret    

0804a264 <abort_tail>:
{
 804a264:	55                   	push   %ebp
	threads_table[this_th_nbr].running = false;
 804a265:	6b c0 14             	imul   $0x14,%eax,%eax
{
 804a268:	89 e5                	mov    %esp,%ebp
 804a26a:	83 ec 08             	sub    $0x8,%esp
	threads_table[this_th_nbr].running = false;
 804a26d:	03 05 48 29 05 08    	add    0x8052948,%eax
 804a273:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	threads_table[this_th_nbr].state = ABORTED;
 804a277:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
	posix_preexit_cleanup();
 804a27d:	e8 b2 ff ff ff       	call   804a234 <posix_preexit_cleanup>
	pthread_exit(NULL);
 804a282:	83 ec 0c             	sub    $0xc,%esp
 804a285:	6a 00                	push   $0x0
 804a287:	e8 f4 f1 ff ff       	call   8049480 <pthread_exit@plt>

0804a28c <posix_wait_until_allowed>:
{
 804a28c:	55                   	push   %ebp
 804a28d:	89 e5                	mov    %esp,%ebp
 804a28f:	56                   	push   %esi
	threads_table[this_th_nbr].running = false;
 804a290:	6b f0 14             	imul   $0x14,%eax,%esi
{
 804a293:	53                   	push   %ebx
 804a294:	89 c3                	mov    %eax,%ebx
	threads_table[this_th_nbr].running = false;
 804a296:	a1 48 29 05 08       	mov    0x8052948,%eax
 804a29b:	c6 44 30 04 00       	movb   $0x0,0x4(%eax,%esi,1)
	while (this_th_nbr != currently_allowed_thread) {
 804a2a0:	39 1d 28 29 05 08    	cmp    %ebx,0x8052928
 804a2a6:	74 2a                	je     804a2d2 <posix_wait_until_allowed+0x46>
		pthread_cond_wait(&cond_threads, &mtx_threads);
 804a2a8:	50                   	push   %eax
 804a2a9:	50                   	push   %eax
 804a2aa:	68 2c 29 05 08       	push   $0x805292c
 804a2af:	68 e0 24 05 08       	push   $0x80524e0
 804a2b4:	e8 b7 f0 ff ff       	call   8049370 <pthread_cond_wait@plt>
		if (threads_table &&
 804a2b9:	a1 48 29 05 08       	mov    0x8052948,%eax
		pthread_cond_wait(&cond_threads, &mtx_threads);
 804a2be:	83 c4 10             	add    $0x10,%esp
		if (threads_table &&
 804a2c1:	85 c0                	test   %eax,%eax
 804a2c3:	74 db                	je     804a2a0 <posix_wait_until_allowed+0x14>
 804a2c5:	83 3c 30 02          	cmpl   $0x2,(%eax,%esi,1)
 804a2c9:	75 d5                	jne    804a2a0 <posix_wait_until_allowed+0x14>
			abort_tail(this_th_nbr);
 804a2cb:	89 d8                	mov    %ebx,%eax
 804a2cd:	e8 92 ff ff ff       	call   804a264 <abort_tail>
	threads_table[this_th_nbr].running = true;
 804a2d2:	a1 48 29 05 08       	mov    0x8052948,%eax
 804a2d7:	c6 44 30 04 01       	movb   $0x1,0x4(%eax,%esi,1)
}
 804a2dc:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804a2df:	5b                   	pop    %ebx
 804a2e0:	5e                   	pop    %esi
 804a2e1:	5d                   	pop    %ebp
 804a2e2:	c3                   	ret    

0804a2e3 <posix_cleanup_handler>:

/**
 * Handler called when any thread is cancelled or exits
 */
static void posix_cleanup_handler(void *arg)
{
 804a2e3:	f3 0f 1e fb          	endbr32 
	 * and the mutex was already released
	 * Otherwise, release the mutex so other threads which may be
	 * caught waiting for it could terminate
	 */

	if (!terminate) {
 804a2e7:	80 3d 9d 29 05 08 00 	cmpb   $0x0,0x805299d
 804a2ee:	74 2b                	je     804a31b <posix_cleanup_handler+0x38>
{
 804a2f0:	55                   	push   %ebp
 804a2f1:	89 e5                	mov    %esp,%ebp
 804a2f3:	83 ec 14             	sub    $0x14,%esp
		ptr->thread_idx,
		__func__);
#endif


	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_threads));
 804a2f6:	68 2c 29 05 08       	push   $0x805292c
 804a2fb:	e8 d0 ef ff ff       	call   80492d0 <pthread_mutex_unlock@plt>
 804a300:	83 c4 10             	add    $0x10,%esp
 804a303:	ba 59 e2 04 08       	mov    $0x804e259,%edx
 804a308:	e8 0c ff ff ff       	call   804a219 <pc_safe_call>

	/* We detach ourselves so nobody needs to join to us */
	pthread_detach(pthread_self());
 804a30d:	e8 4e f0 ff ff       	call   8049360 <pthread_self@plt>
 804a312:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804a315:	c9                   	leave  
	pthread_detach(pthread_self());
 804a316:	e9 f5 f1 ff ff       	jmp    8049510 <pthread_detach@plt>
 804a31b:	c3                   	ret    

0804a31c <posix_thread_starter>:
 *  It will block the thread until a arch_swap() is called for it
 *
 * Spawned from posix_new_thread() below
 */
static void *posix_thread_starter(void *arg)
{
 804a31c:	f3 0f 1e fb          	endbr32 
 804a320:	55                   	push   %ebp
 804a321:	89 e5                	mov    %esp,%ebp
 804a323:	83 ec 54             	sub    $0x54,%esp
 804a326:	8b 45 08             	mov    0x8(%ebp),%eax
 804a329:	89 45 c4             	mov    %eax,-0x3c(%ebp)
 804a32c:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804a332:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a335:	31 c0                	xor    %eax,%eax

	/*
	 * We block until all other running threads reach the while loop
	 * in posix_wait_until_allowed() and they release the mutex
	 */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
 804a337:	68 2c 29 05 08       	push   $0x805292c
 804a33c:	e8 5f f0 ff ff       	call   80493a0 <pthread_mutex_lock@plt>
 804a341:	83 c4 10             	add    $0x10,%esp
 804a344:	ba 7c e2 04 08       	mov    $0x804e27c,%edx
 804a349:	e8 cb fe ff ff       	call   804a219 <pc_safe_call>

	/*
	 * The program may have been finished before this thread ever got to run
	 */
	/* LCOV_EXCL_START */ /* See Note1 */
	if (!threads_table) {
 804a34e:	83 3d 48 29 05 08 00 	cmpl   $0x0,0x8052948
 804a355:	75 17                	jne    804a36e <posix_thread_starter+0x52>
		posix_cleanup_handler(arg);
 804a357:	83 ec 0c             	sub    $0xc,%esp
 804a35a:	ff 75 c4             	pushl  -0x3c(%ebp)
 804a35d:	e8 81 ff ff ff       	call   804a2e3 <posix_cleanup_handler>
		pthread_exit(NULL);
 804a362:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804a369:	e8 12 f1 ff ff       	call   8049480 <pthread_exit@plt>
	}
	/* LCOV_EXCL_STOP */

	pthread_cleanup_push(posix_cleanup_handler, arg);
 804a36e:	50                   	push   %eax
 804a36f:	50                   	push   %eax
 804a370:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804a373:	6a 00                	push   $0x0
 804a375:	50                   	push   %eax
 804a376:	e8 25 f1 ff ff       	call   80494a0 <__sigsetjmp@plt>
 804a37b:	f3 0f 1e fb          	endbr32 
 804a37f:	83 c4 10             	add    $0x10,%esp
 804a382:	85 c0                	test   %eax,%eax
 804a384:	74 16                	je     804a39c <posix_thread_starter+0x80>
 804a386:	83 ec 0c             	sub    $0xc,%esp
 804a389:	ff 75 c4             	pushl  -0x3c(%ebp)
 804a38c:	e8 52 ff ff ff       	call   804a2e3 <posix_cleanup_handler>
 804a391:	83 c4 10             	add    $0x10,%esp
 804a394:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804a397:	e8 24 f1 ff ff       	call   80494c0 <__pthread_unwind_next@plt>
 804a39c:	8d 45 c8             	lea    -0x38(%ebp),%eax
 804a39f:	e8 9c ef ff ff       	call   8049340 <__pthread_register_cancel@plt>

	/*
	 * The thread would try to execute immediately, so we block it
	 * until allowed
	 */
	posix_wait_until_allowed(thread_idx);
 804a3a4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
 804a3a7:	e8 e0 fe ff ff       	call   804a28c <posix_wait_until_allowed>

	posix_new_thread_pre_start();
 804a3ac:	e8 9e 03 00 00       	call   804a74f <posix_new_thread_pre_start>

	posix_thread_status_t *ptr = threads_table[thread_idx].t_status;
 804a3b1:	6b 45 c4 14          	imul   $0x14,-0x3c(%ebp),%eax
 804a3b5:	03 05 48 29 05 08    	add    0x8052948,%eax
 804a3bb:	8b 40 10             	mov    0x10(%eax),%eax

	z_thread_entry(ptr->entry_point, ptr->arg1, ptr->arg2, ptr->arg3);
 804a3be:	ff 70 0c             	pushl  0xc(%eax)
 804a3c1:	ff 70 08             	pushl  0x8(%eax)
 804a3c4:	ff 70 04             	pushl  0x4(%eax)
 804a3c7:	ff 30                	pushl  (%eax)
 804a3c9:	e8 44 f4 ff ff       	call   8049812 <z_thread_entry>

0804a3ce <posix_swap>:
{
 804a3ce:	f3 0f 1e fb          	endbr32 
 804a3d2:	55                   	push   %ebp
 804a3d3:	89 e5                	mov    %esp,%ebp
 804a3d5:	53                   	push   %ebx
 804a3d6:	83 ec 10             	sub    $0x10,%esp
	currently_allowed_thread = next_allowed_th;
 804a3d9:	8b 45 08             	mov    0x8(%ebp),%eax
{
 804a3dc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804a3df:	68 e0 24 05 08       	push   $0x80524e0
	currently_allowed_thread = next_allowed_th;
 804a3e4:	a3 28 29 05 08       	mov    %eax,0x8052928
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804a3e9:	e8 32 ef ff ff       	call   8049320 <pthread_cond_broadcast@plt>
 804a3ee:	83 c4 10             	add    $0x10,%esp
 804a3f1:	ba 9d e2 04 08       	mov    $0x804e29d,%edx
 804a3f6:	e8 1e fe ff ff       	call   804a219 <pc_safe_call>
	if (threads_table[this_th_nbr].state == ABORTING) {
 804a3fb:	6b c3 14             	imul   $0x14,%ebx,%eax
 804a3fe:	03 05 48 29 05 08    	add    0x8052948,%eax
 804a404:	83 38 02             	cmpl   $0x2,(%eax)
		abort_tail(this_th_nbr);
 804a407:	89 d8                	mov    %ebx,%eax
	if (threads_table[this_th_nbr].state == ABORTING) {
 804a409:	75 05                	jne    804a410 <posix_swap+0x42>
		abort_tail(this_th_nbr);
 804a40b:	e8 54 fe ff ff       	call   804a264 <abort_tail>
}
 804a410:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804a413:	c9                   	leave  
		posix_wait_until_allowed(this_th_nbr);
 804a414:	e9 73 fe ff ff       	jmp    804a28c <posix_wait_until_allowed>

0804a419 <posix_main_thread_start>:
{
 804a419:	f3 0f 1e fb          	endbr32 
 804a41d:	55                   	push   %ebp
 804a41e:	89 e5                	mov    %esp,%ebp
 804a420:	83 ec 14             	sub    $0x14,%esp
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804a423:	68 e0 24 05 08       	push   $0x80524e0
	currently_allowed_thread = next_allowed_th;
 804a428:	8b 45 08             	mov    0x8(%ebp),%eax
 804a42b:	a3 28 29 05 08       	mov    %eax,0x8052928
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_threads));
 804a430:	e8 eb ee ff ff       	call   8049320 <pthread_cond_broadcast@plt>
 804a435:	83 c4 10             	add    $0x10,%esp
 804a438:	ba 9d e2 04 08       	mov    $0x804e29d,%edx
 804a43d:	e8 d7 fd ff ff       	call   804a219 <pc_safe_call>
	posix_preexit_cleanup();
 804a442:	e8 ed fd ff ff       	call   804a234 <posix_preexit_cleanup>
	pthread_exit(NULL);
 804a447:	83 ec 0c             	sub    $0xc,%esp
 804a44a:	6a 00                	push   $0x0
 804a44c:	e8 2f f0 ff ff       	call   8049480 <pthread_exit@plt>

0804a451 <posix_new_thread>:
 * Create a new POSIX thread for the new Zephyr thread.
 * arch_new_thread() picks from the kernel structures what it is that we need
 * to call with what parameters
 */
void posix_new_thread(posix_thread_status_t *ptr)
{
 804a451:	f3 0f 1e fb          	endbr32 
 804a455:	55                   	push   %ebp
	for (int i = 0; i < threads_table_size; i++) {
 804a456:	31 d2                	xor    %edx,%edx
{
 804a458:	89 e5                	mov    %esp,%ebp
 804a45a:	57                   	push   %edi
 804a45b:	56                   	push   %esi
 804a45c:	53                   	push   %ebx
 804a45d:	83 ec 0c             	sub    $0xc,%esp
 804a460:	8b 75 08             	mov    0x8(%ebp),%esi
	for (int i = 0; i < threads_table_size; i++) {
 804a463:	a1 4c 29 05 08       	mov    0x805294c,%eax
		if ((threads_table[i].state == NOTUSED)
 804a468:	8b 0d 48 29 05 08    	mov    0x8052948,%ecx
	for (int i = 0; i < threads_table_size; i++) {
 804a46e:	39 c2                	cmp    %eax,%edx
 804a470:	7d 0c                	jge    804a47e <posix_new_thread+0x2d>
		if ((threads_table[i].state == NOTUSED)
 804a472:	6b da 14             	imul   $0x14,%edx,%ebx
 804a475:	83 3c 19 00          	cmpl   $0x0,(%ecx,%ebx,1)
 804a479:	74 50                	je     804a4cb <posix_new_thread+0x7a>
	for (int i = 0; i < threads_table_size; i++) {
 804a47b:	42                   	inc    %edx
 804a47c:	eb f0                	jmp    804a46e <posix_new_thread+0x1d>
				(threads_table_size + PC_ALLOC_CHUNK_SIZE)
 804a47e:	83 c0 40             	add    $0x40,%eax
	threads_table = realloc(threads_table,
 804a481:	52                   	push   %edx
 804a482:	6b c0 14             	imul   $0x14,%eax,%eax
 804a485:	52                   	push   %edx
 804a486:	50                   	push   %eax
 804a487:	51                   	push   %ecx
 804a488:	e8 33 ef ff ff       	call   80493c0 <realloc@plt>
 804a48d:	83 c4 10             	add    $0x10,%esp
 804a490:	a3 48 29 05 08       	mov    %eax,0x8052948
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
 804a495:	85 c0                	test   %eax,%eax
 804a497:	75 10                	jne    804a4a9 <posix_new_thread+0x58>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
 804a499:	83 ec 0c             	sub    $0xc,%esp
 804a49c:	68 c3 e2 04 08       	push   $0x804e2c3
 804a4a1:	e8 48 14 00 00       	call   804b8ee <posix_print_error_and_exit>
 804a4a6:	83 c4 10             	add    $0x10,%esp
	(void)memset(&threads_table[threads_table_size], 0,
 804a4a9:	8b 15 4c 29 05 08    	mov    0x805294c,%edx
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
 804a4af:	31 c0                	xor    %eax,%eax
 804a4b1:	b9 40 01 00 00       	mov    $0x140,%ecx
 804a4b6:	6b da 14             	imul   $0x14,%edx,%ebx
 804a4b9:	03 1d 48 29 05 08    	add    0x8052948,%ebx
 804a4bf:	89 df                	mov    %ebx,%edi
 804a4c1:	f3 ab                	rep stos %eax,%es:(%edi)
	threads_table_size += PC_ALLOC_CHUNK_SIZE;
 804a4c3:	8d 42 40             	lea    0x40(%edx),%eax
 804a4c6:	a3 4c 29 05 08       	mov    %eax,0x805294c
	int t_slot;

	t_slot = ttable_get_empty_slot();
	threads_table[t_slot].state = USED;
	threads_table[t_slot].running = false;
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804a4cb:	8b 0d 44 29 05 08    	mov    0x8052944,%ecx
	threads_table[t_slot].state = USED;
 804a4d1:	6b c2 14             	imul   $0x14,%edx,%eax
 804a4d4:	03 05 48 29 05 08    	add    0x8052948,%eax
	threads_table[t_slot].t_status = ptr;
 804a4da:	89 70 10             	mov    %esi,0x10(%eax)
	ptr->thread_idx = t_slot;

	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804a4dd:	83 c0 08             	add    $0x8,%eax
	threads_table[t_slot].state = USED;
 804a4e0:	c7 40 f8 01 00 00 00 	movl   $0x1,-0x8(%eax)
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804a4e7:	8d 59 01             	lea    0x1(%ecx),%ebx
	threads_table[t_slot].running = false;
 804a4ea:	c6 40 fc 00          	movb   $0x0,-0x4(%eax)
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804a4ee:	89 48 04             	mov    %ecx,0x4(%eax)
	ptr->thread_idx = t_slot;
 804a4f1:	89 56 10             	mov    %edx,0x10(%esi)
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804a4f4:	52                   	push   %edx
 804a4f5:	68 1c a3 04 08       	push   $0x804a31c
 804a4fa:	6a 00                	push   $0x0
 804a4fc:	50                   	push   %eax
	threads_table[t_slot].thead_cnt = thread_create_count++;
 804a4fd:	89 1d 44 29 05 08    	mov    %ebx,0x8052944
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804a503:	e8 e8 ef ff ff       	call   80494f0 <pthread_create@plt>
 804a508:	83 c4 10             	add    $0x10,%esp
		__func__,
		threads_table[t_slot].thead_cnt,
		t_slot,
		threads_table[t_slot].thread);

}
 804a50b:	8d 65 f4             	lea    -0xc(%ebp),%esp
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804a50e:	ba eb e2 04 08       	mov    $0x804e2eb,%edx
}
 804a513:	5b                   	pop    %ebx
 804a514:	5e                   	pop    %esi
 804a515:	5f                   	pop    %edi
 804a516:	5d                   	pop    %ebp
	PC_SAFE_CALL(pthread_create(&threads_table[t_slot].thread,
 804a517:	e9 fd fc ff ff       	jmp    804a219 <pc_safe_call>

0804a51c <posix_init_multithreading>:
/**
 * Called from zephyr_wrapper()
 * prepare whatever needs to be prepared to be able to start threads
 */
void posix_init_multithreading(void)
{
 804a51c:	f3 0f 1e fb          	endbr32 
 804a520:	55                   	push   %ebp
 804a521:	89 e5                	mov    %esp,%ebp
 804a523:	83 ec 10             	sub    $0x10,%esp
	thread_create_count = 0;
 804a526:	c7 05 44 29 05 08 00 	movl   $0x0,0x8052944
 804a52d:	00 00 00 

	currently_allowed_thread = -1;

	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
 804a530:	6a 14                	push   $0x14
 804a532:	6a 40                	push   $0x40
	currently_allowed_thread = -1;
 804a534:	c7 05 28 29 05 08 ff 	movl   $0xffffffff,0x8052928
 804a53b:	ff ff ff 
	threads_table = calloc(PC_ALLOC_CHUNK_SIZE,
 804a53e:	e8 0d f0 ff ff       	call   8049550 <calloc@plt>
 804a543:	83 c4 10             	add    $0x10,%esp
 804a546:	a3 48 29 05 08       	mov    %eax,0x8052948
				sizeof(struct threads_table_el));
	if (threads_table == NULL) { /* LCOV_EXCL_BR_LINE */
 804a54b:	85 c0                	test   %eax,%eax
 804a54d:	75 10                	jne    804a55f <posix_init_multithreading+0x43>
		posix_print_error_and_exit(NO_MEM_ERR); /* LCOV_EXCL_LINE */
 804a54f:	83 ec 0c             	sub    $0xc,%esp
 804a552:	68 c3 e2 04 08       	push   $0x804e2c3
 804a557:	e8 92 13 00 00       	call   804b8ee <posix_print_error_and_exit>
 804a55c:	83 c4 10             	add    $0x10,%esp
	}

	threads_table_size = PC_ALLOC_CHUNK_SIZE;
 804a55f:	c7 05 4c 29 05 08 40 	movl   $0x40,0x805294c
 804a566:	00 00 00 


	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
 804a569:	83 ec 0c             	sub    $0xc,%esp
 804a56c:	68 2c 29 05 08       	push   $0x805292c
 804a571:	e8 2a ee ff ff       	call   80493a0 <pthread_mutex_lock@plt>
 804a576:	83 c4 10             	add    $0x10,%esp
 804a579:	ba 7c e2 04 08       	mov    $0x804e27c,%edx
}
 804a57e:	c9                   	leave  
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_threads));
 804a57f:	e9 95 fc ff ff       	jmp    804a219 <pc_safe_call>

0804a584 <posix_core_clean_up>:
 * => we prefer the supposed memory leak report from valgrind, and ensure we
 * will not hang
 *
 */
void posix_core_clean_up(void)
{
 804a584:	f3 0f 1e fb          	endbr32 

	if (!threads_table) { /* LCOV_EXCL_BR_LINE */
 804a588:	83 3d 48 29 05 08 00 	cmpl   $0x0,0x8052948
 804a58f:	74 65                	je     804a5f6 <posix_core_clean_up+0x72>
{
 804a591:	55                   	push   %ebp
 804a592:	89 e5                	mov    %esp,%ebp
 804a594:	53                   	push   %ebx
		return; /* LCOV_EXCL_LINE */
	}

	terminate = true;

	for (int i = 0; i < threads_table_size; i++) {
 804a595:	31 db                	xor    %ebx,%ebx
{
 804a597:	52                   	push   %edx
	terminate = true;
 804a598:	c6 05 9d 29 05 08 01 	movb   $0x1,0x805299d
	for (int i = 0; i < threads_table_size; i++) {
 804a59f:	a1 48 29 05 08       	mov    0x8052948,%eax
 804a5a4:	39 1d 4c 29 05 08    	cmp    %ebx,0x805294c
 804a5aa:	7e 2f                	jle    804a5db <posix_core_clean_up+0x57>
		if (threads_table[i].state != USED) {
 804a5ac:	6b d3 14             	imul   $0x14,%ebx,%edx
 804a5af:	01 d0                	add    %edx,%eax
 804a5b1:	83 38 01             	cmpl   $0x1,(%eax)
 804a5b4:	75 22                	jne    804a5d8 <posix_core_clean_up+0x54>
			continue;
		}

		/* LCOV_EXCL_START */
		if (pthread_cancel(threads_table[i].thread)) {
 804a5b6:	83 ec 0c             	sub    $0xc,%esp
 804a5b9:	ff 70 08             	pushl  0x8(%eax)
 804a5bc:	e8 8f ee ff ff       	call   8049450 <pthread_cancel@plt>
 804a5c1:	83 c4 10             	add    $0x10,%esp
 804a5c4:	85 c0                	test   %eax,%eax
 804a5c6:	74 10                	je     804a5d8 <posix_core_clean_up+0x54>
			posix_print_warning(
 804a5c8:	50                   	push   %eax
 804a5c9:	50                   	push   %eax
 804a5ca:	53                   	push   %ebx
 804a5cb:	68 4f e3 04 08       	push   $0x804e34f
 804a5d0:	e8 48 13 00 00       	call   804b91d <posix_print_warning>
 804a5d5:	83 c4 10             	add    $0x10,%esp
	for (int i = 0; i < threads_table_size; i++) {
 804a5d8:	43                   	inc    %ebx
 804a5d9:	eb c4                	jmp    804a59f <posix_core_clean_up+0x1b>
				i);
		}
		/* LCOV_EXCL_STOP */
	}

	free(threads_table);
 804a5db:	83 ec 0c             	sub    $0xc,%esp
 804a5de:	50                   	push   %eax
 804a5df:	e8 4c ed ff ff       	call   8049330 <free@plt>
	threads_table = NULL;
}
 804a5e4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	free(threads_table);
 804a5e7:	83 c4 10             	add    $0x10,%esp
	threads_table = NULL;
 804a5ea:	c7 05 48 29 05 08 00 	movl   $0x0,0x8052948
 804a5f1:	00 00 00 
}
 804a5f4:	c9                   	leave  
 804a5f5:	c3                   	ret    
 804a5f6:	c3                   	ret    

0804a5f7 <posix_abort_thread>:


void posix_abort_thread(int thread_idx)
{
 804a5f7:	f3 0f 1e fb          	endbr32 
 804a5fb:	55                   	push   %ebp
 804a5fc:	89 e5                	mov    %esp,%ebp
	if (threads_table[thread_idx].state != USED) { /* LCOV_EXCL_BR_LINE */
 804a5fe:	6b 45 08 14          	imul   $0x14,0x8(%ebp),%eax
 804a602:	03 05 48 29 05 08    	add    0x8052948,%eax
 804a608:	83 38 01             	cmpl   $0x1,(%eax)
 804a60b:	75 06                	jne    804a613 <posix_abort_thread+0x1c>

	PC_DEBUG("Aborting not scheduled thread [%i] %i\n",
		threads_table[thread_idx].thead_cnt,
		thread_idx);

	threads_table[thread_idx].state = ABORTING;
 804a60d:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	 * mutex or awakes on the condition.
	 * Note that even if we would pthread_cancel() the thread here, that
	 * would be the case, but with a pthread_cancel() the mutex state would
	 * be uncontrolled
	 */
}
 804a613:	5d                   	pop    %ebp
 804a614:	c3                   	ret    

0804a615 <z_impl_k_thread_abort>:


#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
 804a615:	f3 0f 1e fb          	endbr32 
 804a619:	55                   	push   %ebp
 804a61a:	89 e5                	mov    %esp,%ebp
 804a61c:	57                   	push   %edi
 804a61d:	56                   	push   %esi
 804a61e:	53                   	push   %ebx
 804a61f:	83 ec 1c             	sub    $0x1c,%esp
 804a622:	8b 75 08             	mov    0x8(%ebp),%esi
	unsigned int key;
	int thread_idx;

	posix_thread_status_t *tstatus =
 804a625:	8b 5e 34             	mov    0x34(%esi),%ebx
					(posix_thread_status_t *)
					thread->callee_saved.thread_status;

	thread_idx = tstatus->thread_idx;
 804a628:	8b 7b 10             	mov    0x10(%ebx),%edi
	return key == false;
}

static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	return posix_irq_lock();
 804a62b:	e8 0c 0e 00 00       	call   804b43c <posix_irq_lock>
 804a630:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	key = irq_lock();

	if (_current == thread) {
 804a633:	39 35 68 28 05 08    	cmp    %esi,0x8052868
 804a639:	75 2e                	jne    804a669 <z_impl_k_thread_abort+0x54>
		if (tstatus->aborted == 0) { /* LCOV_EXCL_BR_LINE */
 804a63b:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
 804a63f:	75 09                	jne    804a64a <z_impl_k_thread_abort+0x35>
			tstatus->aborted = 1;
 804a641:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
 804a648:	eb 10                	jmp    804a65a <z_impl_k_thread_abort+0x45>
		} else {
			posix_print_warning(/* LCOV_EXCL_LINE */
 804a64a:	50                   	push   %eax
 804a64b:	50                   	push   %eax
 804a64c:	57                   	push   %edi
 804a64d:	68 83 e3 04 08       	push   $0x804e383
 804a652:	e8 c6 12 00 00       	call   804b91d <posix_print_warning>
 804a657:	83 c4 10             	add    $0x10,%esp
				PREFIX"The kernel is trying to abort and swap "
				"out of an already aborted thread %i. This "
				"should NOT have happened\n",
				thread_idx);
		}
		threads_table[thread_idx].state = ABORTING;
 804a65a:	6b c7 14             	imul   $0x14,%edi,%eax
 804a65d:	03 05 48 29 05 08    	add    0x8052948,%eax
 804a663:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
			threads_table[thread_idx].thead_cnt,
			thread_idx,
			__func__);
	}

	z_thread_abort(thread);
 804a669:	83 ec 0c             	sub    $0xc,%esp
 804a66c:	56                   	push   %esi
 804a66d:	e8 20 28 00 00       	call   804ce92 <z_thread_abort>
 804a672:	83 c4 10             	add    $0x10,%esp

	if (tstatus->aborted == 0) {
 804a675:	83 7b 14 00          	cmpl   $0x0,0x14(%ebx)
 804a679:	75 13                	jne    804a68e <z_impl_k_thread_abort+0x79>
			__func__,
			threads_table[thread_idx].thead_cnt,
			thread_idx);

		tstatus->aborted = 1;
		posix_abort_thread(thread_idx);
 804a67b:	83 ec 0c             	sub    $0xc,%esp
		tstatus->aborted = 1;
 804a67e:	c7 43 14 01 00 00 00 	movl   $0x1,0x14(%ebx)
		posix_abort_thread(thread_idx);
 804a685:	57                   	push   %edi
 804a686:	e8 6c ff ff ff       	call   804a5f7 <posix_abort_thread>
 804a68b:	83 c4 10             	add    $0x10,%esp
			threads_table[thread_idx].thead_cnt,
			thread_idx);
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
 804a68e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a691:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804a694:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804a697:	5b                   	pop    %ebx
 804a698:	5e                   	pop    %esi
 804a699:	5f                   	pop    %edi
 804a69a:	5d                   	pop    %ebp
	z_reschedule_irqlock(key);
 804a69b:	e9 63 22 00 00       	jmp    804c903 <z_reschedule_irqlock>

0804a6a0 <arch_swap>:
#include <zephyr/irq.h>
#include "kswap.h"
#include <zephyr/pm/pm.h>

int arch_swap(unsigned int key)
{
 804a6a0:	f3 0f 1e fb          	endbr32 
 804a6a4:	55                   	push   %ebp
 804a6a5:	89 e5                	mov    %esp,%ebp
 804a6a7:	83 ec 10             	sub    $0x10,%esp
	 * threads => those are all nicely kept by the native OS kernel
	 */
#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif
	_current->callee_saved.key = key;
 804a6aa:	a1 68 28 05 08       	mov    0x8052868,%eax
 804a6af:	8b 55 08             	mov    0x8(%ebp),%edx
	_current->callee_saved.retval = -EAGAIN;
 804a6b2:	c7 40 30 f5 ff ff ff 	movl   $0xfffffff5,0x30(%eax)
	_current->callee_saved.key = key;
 804a6b9:	89 50 2c             	mov    %edx,0x2c(%eax)
	 * arch_thread_return_value_set()
	 */

	posix_thread_status_t *ready_thread_ptr =
		(posix_thread_status_t *)
		_kernel.ready_q.cache->callee_saved.thread_status;
 804a6bc:	8b 15 78 28 05 08    	mov    0x8052878,%edx

	posix_thread_status_t *this_thread_ptr  =
 804a6c2:	8b 40 34             	mov    0x34(%eax),%eax
	posix_thread_status_t *ready_thread_ptr =
 804a6c5:	8b 4a 34             	mov    0x34(%edx),%ecx
		(posix_thread_status_t *)
		_current->callee_saved.thread_status;


	_current = _kernel.ready_q.cache;
 804a6c8:	89 15 68 28 05 08    	mov    %edx,0x8052868
	 * Here a "real" arch would load all processor registers for the thread
	 * to run. In this arch case, we just block this thread until allowed
	 * to run later, and signal to whomever is allowed to run to
	 * continue.
	 */
	posix_swap(ready_thread_ptr->thread_idx,
 804a6ce:	ff 70 10             	pushl  0x10(%eax)
 804a6d1:	ff 71 10             	pushl  0x10(%ecx)
 804a6d4:	e8 f5 fc ff ff       	call   804a3ce <posix_swap>
 804a6d9:	58                   	pop    %eax
		this_thread_ptr->thread_idx);

	/* When we continue, _kernel->current points back to this thread */

	irq_unlock(_current->callee_saved.key);
 804a6da:	a1 68 28 05 08       	mov    0x8052868,%eax
}


static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	posix_irq_unlock(key);
 804a6df:	ff 70 2c             	pushl  0x2c(%eax)
 804a6e2:	e8 6b 0d 00 00       	call   804b452 <posix_irq_unlock>

	return _current->callee_saved.retval;
 804a6e7:	a1 68 28 05 08       	mov    0x8052868,%eax
 804a6ec:	83 c4 10             	add    $0x10,%esp
 804a6ef:	8b 40 30             	mov    0x30(%eax),%eax
}
 804a6f2:	c9                   	leave  
 804a6f3:	c3                   	ret    

0804a6f4 <arch_switch_to_main_thread>:
 * Note that we will never come back to this thread: posix_main_thread_start()
 * does never return.
 */
void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
 804a6f4:	f3 0f 1e fb          	endbr32 
	ARG_UNUSED(stack_ptr);
	ARG_UNUSED(_main);

	posix_thread_status_t *ready_thread_ptr =
			(posix_thread_status_t *)
			_kernel.ready_q.cache->callee_saved.thread_status;
 804a6f8:	a1 78 28 05 08       	mov    0x8052878,%eax
{
 804a6fd:	55                   	push   %ebp
	posix_thread_status_t *ready_thread_ptr =
 804a6fe:	8b 50 34             	mov    0x34(%eax),%edx

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_out();
#endif

	_current = _kernel.ready_q.cache;
 804a701:	a3 68 28 05 08       	mov    %eax,0x8052868
{
 804a706:	89 e5                	mov    %esp,%ebp

#ifdef CONFIG_INSTRUMENT_THREAD_SWITCHING
	z_thread_mark_switched_in();
#endif

	posix_main_thread_start(ready_thread_ptr->thread_idx);
 804a708:	8b 42 10             	mov    0x10(%edx),%eax
 804a70b:	89 45 08             	mov    %eax,0x8(%ebp)
} /* LCOV_EXCL_LINE */
 804a70e:	5d                   	pop    %ebp
	posix_main_thread_start(ready_thread_ptr->thread_idx);
 804a70f:	e9 05 fd ff ff       	jmp    804a419 <posix_main_thread_start>

0804a714 <arch_new_thread>:
 * pthreads stack and therefore we ignore the stack size
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
 804a714:	f3 0f 1e fb          	endbr32 
 804a718:	55                   	push   %ebp
 804a719:	89 e5                	mov    %esp,%ebp
 804a71b:	8b 45 10             	mov    0x10(%ebp),%eax
	 * "initial stack frame"
	 */
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);

	/* z_thread_entry() arguments */
	thread_status->entry_point = entry;
 804a71e:	8b 4d 14             	mov    0x14(%ebp),%ecx
 804a721:	89 48 e8             	mov    %ecx,-0x18(%eax)
	thread_status->arg1 = p1;
 804a724:	8b 4d 18             	mov    0x18(%ebp),%ecx
	thread_status = Z_STACK_PTR_TO_FRAME(posix_thread_status_t, stack_ptr);
 804a727:	8d 50 e8             	lea    -0x18(%eax),%edx
	thread_status->arg2 = p2;
	thread_status->arg3 = p3;
#if defined(CONFIG_ARCH_HAS_THREAD_ABORT)
	thread_status->aborted = 0;
 804a72a:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
	thread_status->arg1 = p1;
 804a731:	89 48 ec             	mov    %ecx,-0x14(%eax)
	thread_status->arg2 = p2;
 804a734:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
 804a737:	89 48 f0             	mov    %ecx,-0x10(%eax)
	thread_status->arg3 = p3;
 804a73a:	8b 4d 20             	mov    0x20(%ebp),%ecx
 804a73d:	89 48 f4             	mov    %ecx,-0xc(%eax)
#endif

	thread->callee_saved.thread_status = thread_status;
 804a740:	8b 45 08             	mov    0x8(%ebp),%eax
 804a743:	89 50 34             	mov    %edx,0x34(%eax)

	posix_new_thread(thread_status);
 804a746:	89 55 08             	mov    %edx,0x8(%ebp)
}
 804a749:	5d                   	pop    %ebp
	posix_new_thread(thread_status);
 804a74a:	e9 02 fd ff ff       	jmp    804a451 <posix_new_thread>

0804a74f <posix_new_thread_pre_start>:

void posix_new_thread_pre_start(void)
{
 804a74f:	f3 0f 1e fb          	endbr32 
	posix_irq_full_unlock();
 804a753:	e9 03 0d 00 00       	jmp    804b45b <posix_irq_full_unlock>

0804a758 <pc_safe_call>:
	if (unlikely(test)) {
 804a758:	85 c0                	test   %eax,%eax
 804a75a:	74 16                	je     804a772 <pc_safe_call+0x1a>
{
 804a75c:	55                   	push   %ebp
 804a75d:	89 e5                	mov    %esp,%ebp
 804a75f:	83 ec 10             	sub    $0x10,%esp
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804a762:	52                   	push   %edx
 804a763:	68 3f e2 04 08       	push   $0x804e23f
 804a768:	e8 81 11 00 00       	call   804b8ee <posix_print_error_and_exit>
 804a76d:	83 c4 10             	add    $0x10,%esp
}
 804a770:	c9                   	leave  
 804a771:	c3                   	ret    
 804a772:	c3                   	ret    

0804a773 <zephyr_wrapper>:
/**
 * Just a wrapper function to call Zephyr's z_cstart()
 * called from posix_boot_cpu()
 */
static void *zephyr_wrapper(void *a)
{
 804a773:	f3 0f 1e fb          	endbr32 
 804a777:	55                   	push   %ebp
 804a778:	89 e5                	mov    %esp,%ebp
 804a77a:	83 ec 14             	sub    $0x14,%esp
	/* Ensure posix_boot_cpu has reached the cond loop */
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804a77d:	68 50 29 05 08       	push   $0x8052950
 804a782:	e8 19 ec ff ff       	call   80493a0 <pthread_mutex_lock@plt>
 804a787:	ba ff e3 04 08       	mov    $0x804e3ff,%edx
 804a78c:	83 c4 10             	add    $0x10,%esp
 804a78f:	e8 c4 ff ff ff       	call   804a758 <pc_safe_call>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a794:	83 ec 0c             	sub    $0xc,%esp
 804a797:	68 50 29 05 08       	push   $0x8052950
 804a79c:	e8 2f eb ff ff       	call   80492d0 <pthread_mutex_unlock@plt>
 804a7a1:	83 c4 10             	add    $0x10,%esp
 804a7a4:	ba 1c e4 04 08       	mov    $0x804e41c,%edx
 804a7a9:	e8 aa ff ff ff       	call   804a758 <pc_safe_call>

		PS_DEBUG("Zephyr init started (%lu)\n",
			zephyr_thread);
#endif

	posix_init_multithreading();
 804a7ae:	e8 69 fd ff ff       	call   804a51c <posix_init_multithreading>

	/* Start Zephyr: */
	z_cstart();
 804a7b3:	e8 f2 1d 00 00       	call   804c5aa <z_cstart>

0804a7b8 <posix_is_cpu_running>:
{
 804a7b8:	f3 0f 1e fb          	endbr32 
	return !cpu_halted;
 804a7bc:	a0 90 12 05 08       	mov    0x8051290,%al
 804a7c1:	83 f0 01             	xor    $0x1,%eax
 804a7c4:	0f b6 c0             	movzbl %al,%eax
}
 804a7c7:	c3                   	ret    

0804a7c8 <posix_change_cpu_state_and_wait>:
{
 804a7c8:	f3 0f 1e fb          	endbr32 
 804a7cc:	55                   	push   %ebp
 804a7cd:	89 e5                	mov    %esp,%ebp
 804a7cf:	56                   	push   %esi
 804a7d0:	53                   	push   %ebx
 804a7d1:	8b 75 08             	mov    0x8(%ebp),%esi
 804a7d4:	89 f3                	mov    %esi,%ebx
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804a7d6:	83 ec 0c             	sub    $0xc,%esp
 804a7d9:	68 50 29 05 08       	push   $0x8052950
 804a7de:	e8 bd eb ff ff       	call   80493a0 <pthread_mutex_lock@plt>
 804a7e3:	ba ff e3 04 08       	mov    $0x804e3ff,%edx
 804a7e8:	83 c4 10             	add    $0x10,%esp
 804a7eb:	e8 68 ff ff ff       	call   804a758 <pc_safe_call>
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804a7f0:	83 ec 0c             	sub    $0xc,%esp
	cpu_halted = halted;
 804a7f3:	88 1d 90 12 05 08    	mov    %bl,0x8051290
	PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804a7f9:	68 20 25 05 08       	push   $0x8052520
 804a7fe:	e8 1d eb ff ff       	call   8049320 <pthread_cond_broadcast@plt>
 804a803:	83 c4 10             	add    $0x10,%esp
 804a806:	ba 3b e4 04 08       	mov    $0x804e43b,%edx
 804a80b:	e8 48 ff ff ff       	call   804a758 <pc_safe_call>
	while (cpu_halted == halted) {
 804a810:	38 1d 90 12 05 08    	cmp    %bl,0x8051290
 804a816:	75 16                	jne    804a82e <posix_change_cpu_state_and_wait+0x66>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
 804a818:	50                   	push   %eax
 804a819:	50                   	push   %eax
 804a81a:	68 50 29 05 08       	push   $0x8052950
 804a81f:	68 20 25 05 08       	push   $0x8052520
 804a824:	e8 47 eb ff ff       	call   8049370 <pthread_cond_wait@plt>
 804a829:	83 c4 10             	add    $0x10,%esp
 804a82c:	eb e2                	jmp    804a810 <posix_change_cpu_state_and_wait+0x48>
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a82e:	83 ec 0c             	sub    $0xc,%esp
 804a831:	68 50 29 05 08       	push   $0x8052950
 804a836:	e8 95 ea ff ff       	call   80492d0 <pthread_mutex_unlock@plt>
 804a83b:	83 c4 10             	add    $0x10,%esp
}
 804a83e:	8d 65 f8             	lea    -0x8(%ebp),%esp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a841:	ba 1c e4 04 08       	mov    $0x804e41c,%edx
}
 804a846:	5b                   	pop    %ebx
 804a847:	5e                   	pop    %esi
 804a848:	5d                   	pop    %ebp
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a849:	e9 0a ff ff ff       	jmp    804a758 <pc_safe_call>

0804a84e <posix_interrupt_raised>:
{
 804a84e:	f3 0f 1e fb          	endbr32 
 804a852:	55                   	push   %ebp
 804a853:	89 e5                	mov    %esp,%ebp
 804a855:	83 ec 14             	sub    $0x14,%esp
	posix_change_cpu_state_and_wait(false);
 804a858:	6a 00                	push   $0x0
 804a85a:	e8 69 ff ff ff       	call   804a7c8 <posix_change_cpu_state_and_wait>
 804a85f:	83 c4 10             	add    $0x10,%esp
	if (soc_terminate) {
 804a862:	80 3d 9e 29 05 08 00 	cmpb   $0x0,0x805299e
 804a869:	74 0d                	je     804a878 <posix_interrupt_raised+0x2a>
		posix_exit(0);
 804a86b:	83 ec 0c             	sub    $0xc,%esp
 804a86e:	6a 00                	push   $0x0
 804a870:	e8 3c 0f 00 00       	call   804b7b1 <posix_exit>
 804a875:	83 c4 10             	add    $0x10,%esp
}
 804a878:	c9                   	leave  
 804a879:	c3                   	ret    

0804a87a <posix_halt_cpu>:
{
 804a87a:	f3 0f 1e fb          	endbr32 
 804a87e:	55                   	push   %ebp
 804a87f:	89 e5                	mov    %esp,%ebp
 804a881:	83 ec 14             	sub    $0x14,%esp
	posix_change_cpu_state_and_wait(true);
 804a884:	6a 01                	push   $0x1
 804a886:	e8 3d ff ff ff       	call   804a7c8 <posix_change_cpu_state_and_wait>
 804a88b:	83 c4 10             	add    $0x10,%esp
}
 804a88e:	c9                   	leave  
	posix_irq_handler();
 804a88f:	e9 56 0a 00 00       	jmp    804b2ea <posix_irq_handler>

0804a894 <posix_boot_cpu>:
 * The HW models will call this function to "boot" the CPU
 * == spawn the Zephyr init thread, which will then spawn
 * anything it wants, and run until the CPU is set back to idle again
 */
void posix_boot_cpu(void)
{
 804a894:	f3 0f 1e fb          	endbr32 
 804a898:	55                   	push   %ebp
 804a899:	89 e5                	mov    %esp,%ebp
 804a89b:	83 ec 24             	sub    $0x24,%esp
 804a89e:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804a8a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804a8a7:	31 c0                	xor    %eax,%eax
	PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804a8a9:	68 50 29 05 08       	push   $0x8052950
 804a8ae:	e8 ed ea ff ff       	call   80493a0 <pthread_mutex_lock@plt>
 804a8b3:	83 c4 10             	add    $0x10,%esp
 804a8b6:	ba ff e3 04 08       	mov    $0x804e3ff,%edx
 804a8bb:	e8 98 fe ff ff       	call   804a758 <pc_safe_call>
	cpu_halted = false;

	pthread_t zephyr_thread;

	/* Create a thread for Zephyr init: */
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
 804a8c0:	8d 45 f0             	lea    -0x10(%ebp),%eax
 804a8c3:	6a 00                	push   $0x0
 804a8c5:	68 73 a7 04 08       	push   $0x804a773
 804a8ca:	6a 00                	push   $0x0
 804a8cc:	50                   	push   %eax
	cpu_halted = false;
 804a8cd:	c6 05 90 12 05 08 00 	movb   $0x0,0x8051290
	PC_SAFE_CALL(pthread_create(&zephyr_thread, NULL, zephyr_wrapper, NULL));
 804a8d4:	e8 17 ec ff ff       	call   80494f0 <pthread_create@plt>
 804a8d9:	83 c4 10             	add    $0x10,%esp
 804a8dc:	ba 5d e4 04 08       	mov    $0x804e45d,%edx
 804a8e1:	e8 72 fe ff ff       	call   804a758 <pc_safe_call>

	/* And we wait until Zephyr has run til completion (has gone to idle) */
	while (cpu_halted == false) {
 804a8e6:	80 3d 90 12 05 08 00 	cmpb   $0x0,0x8051290
 804a8ed:	75 16                	jne    804a905 <posix_boot_cpu+0x71>
		pthread_cond_wait(&cond_cpu, &mtx_cpu);
 804a8ef:	50                   	push   %eax
 804a8f0:	50                   	push   %eax
 804a8f1:	68 50 29 05 08       	push   $0x8052950
 804a8f6:	68 20 25 05 08       	push   $0x8052520
 804a8fb:	e8 70 ea ff ff       	call   8049370 <pthread_cond_wait@plt>
 804a900:	83 c4 10             	add    $0x10,%esp
 804a903:	eb e1                	jmp    804a8e6 <posix_boot_cpu+0x52>
	}
	PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a905:	83 ec 0c             	sub    $0xc,%esp
 804a908:	68 50 29 05 08       	push   $0x8052950
 804a90d:	e8 be e9 ff ff       	call   80492d0 <pthread_mutex_unlock@plt>
 804a912:	83 c4 10             	add    $0x10,%esp
 804a915:	ba 1c e4 04 08       	mov    $0x804e41c,%edx
 804a91a:	e8 39 fe ff ff       	call   804a758 <pc_safe_call>

	if (soc_terminate) {
 804a91f:	80 3d 9e 29 05 08 00 	cmpb   $0x0,0x805299e
 804a926:	74 0d                	je     804a935 <posix_boot_cpu+0xa1>
		posix_exit(0);
 804a928:	83 ec 0c             	sub    $0xc,%esp
 804a92b:	6a 00                	push   $0x0
 804a92d:	e8 7f 0e 00 00       	call   804b7b1 <posix_exit>
 804a932:	83 c4 10             	add    $0x10,%esp
	}
}
 804a935:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a938:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804a93f:	74 05                	je     804a946 <posix_boot_cpu+0xb2>
 804a941:	e8 4a ea ff ff       	call   8049390 <__stack_chk_fail@plt>
 804a946:	c9                   	leave  
 804a947:	c3                   	ret    

0804a948 <run_native_tasks>:
 * @brief Run the set of special native tasks corresponding to the given level
 *
 * @param level One of _NATIVE_*_LEVEL as defined in soc.h
 */
void run_native_tasks(int level)
{
 804a948:	f3 0f 1e fb          	endbr32 
 804a94c:	55                   	push   %ebp
 804a94d:	89 e5                	mov    %esp,%ebp
 804a94f:	56                   	push   %esi
 804a950:	8b 75 08             	mov    0x8(%ebp),%esi
 804a953:	53                   	push   %ebx
		__native_tasks_end
	};

	void (**fptr)(void);

	for (fptr = native_pre_tasks[level]; fptr < native_pre_tasks[level+1];
 804a954:	8b 1c b5 00 e1 04 08 	mov    0x804e100(,%esi,4),%ebx
 804a95b:	39 1c b5 04 e1 04 08 	cmp    %ebx,0x804e104(,%esi,4)
 804a962:	76 0d                	jbe    804a971 <run_native_tasks+0x29>
		fptr++) {
		if (*fptr) { /* LCOV_EXCL_BR_LINE */
 804a964:	8b 03                	mov    (%ebx),%eax
 804a966:	85 c0                	test   %eax,%eax
 804a968:	74 02                	je     804a96c <run_native_tasks+0x24>
			(*fptr)();
 804a96a:	ff d0                	call   *%eax
		fptr++) {
 804a96c:	83 c3 04             	add    $0x4,%ebx
 804a96f:	eb ea                	jmp    804a95b <run_native_tasks+0x13>
		}
	}
}
 804a971:	5b                   	pop    %ebx
 804a972:	5e                   	pop    %esi
 804a973:	5d                   	pop    %ebp
 804a974:	c3                   	ret    

0804a975 <posix_soc_clean_up>:
 * Clean up all memory allocated by the SOC and POSIX core
 *
 * This function can be called from both HW and SW threads
 */
void posix_soc_clean_up(void)
{
 804a975:	f3 0f 1e fb          	endbr32 
 804a979:	55                   	push   %ebp
 804a97a:	89 e5                	mov    %esp,%ebp
 804a97c:	83 ec 08             	sub    $0x8,%esp
	 * If we are being called from a HW thread we can cleanup
	 *
	 * Otherwise (!cpu_halted) we give back control to the HW thread and
	 * tell it to terminate ASAP
	 */
	if (cpu_halted) {
 804a97f:	80 3d 90 12 05 08 00 	cmpb   $0x0,0x8051290
 804a986:	74 14                	je     804a99c <posix_soc_clean_up+0x27>

		posix_core_clean_up();
 804a988:	e8 f7 fb ff ff       	call   804a584 <posix_core_clean_up>
		run_native_tasks(_NATIVE_ON_EXIT_LEVEL);
 804a98d:	83 ec 0c             	sub    $0xc,%esp
 804a990:	6a 04                	push   $0x4
 804a992:	e8 b1 ff ff ff       	call   804a948 <run_native_tasks>
 804a997:	83 c4 10             	add    $0x10,%esp
 804a99a:	eb 74                	jmp    804aa10 <posix_soc_clean_up+0x9b>

	} else if (soc_terminate == false) {
 804a99c:	80 3d 9e 29 05 08 00 	cmpb   $0x0,0x805299e
 804a9a3:	75 6b                	jne    804aa10 <posix_soc_clean_up+0x9b>

		soc_terminate = true;

		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804a9a5:	83 ec 0c             	sub    $0xc,%esp
		soc_terminate = true;
 804a9a8:	c6 05 9e 29 05 08 01 	movb   $0x1,0x805299e
		PC_SAFE_CALL(pthread_mutex_lock(&mtx_cpu));
 804a9af:	68 50 29 05 08       	push   $0x8052950
 804a9b4:	e8 e7 e9 ff ff       	call   80493a0 <pthread_mutex_lock@plt>
 804a9b9:	ba ff e3 04 08       	mov    $0x804e3ff,%edx
 804a9be:	83 c4 10             	add    $0x10,%esp
 804a9c1:	e8 92 fd ff ff       	call   804a758 <pc_safe_call>

		cpu_halted = true;

		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804a9c6:	83 ec 0c             	sub    $0xc,%esp
		cpu_halted = true;
 804a9c9:	c6 05 90 12 05 08 01 	movb   $0x1,0x8051290
		PC_SAFE_CALL(pthread_cond_broadcast(&cond_cpu));
 804a9d0:	68 20 25 05 08       	push   $0x8052520
 804a9d5:	e8 46 e9 ff ff       	call   8049320 <pthread_cond_broadcast@plt>
 804a9da:	ba 3b e4 04 08       	mov    $0x804e43b,%edx
 804a9df:	83 c4 10             	add    $0x10,%esp
 804a9e2:	e8 71 fd ff ff       	call   804a758 <pc_safe_call>
		PC_SAFE_CALL(pthread_mutex_unlock(&mtx_cpu));
 804a9e7:	83 ec 0c             	sub    $0xc,%esp
 804a9ea:	68 50 29 05 08       	push   $0x8052950
 804a9ef:	e8 dc e8 ff ff       	call   80492d0 <pthread_mutex_unlock@plt>
 804a9f4:	83 c4 10             	add    $0x10,%esp
 804a9f7:	ba 1c e4 04 08       	mov    $0x804e41c,%edx
 804a9fc:	e8 57 fd ff ff       	call   804a758 <pc_safe_call>

		while (1) {
			sleep(1);
 804aa01:	83 ec 0c             	sub    $0xc,%esp
 804aa04:	6a 01                	push   $0x1
 804aa06:	e8 75 e9 ff ff       	call   8049380 <sleep@plt>
 804aa0b:	83 c4 10             	add    $0x10,%esp
		while (1) {
 804aa0e:	eb f1                	jmp    804aa01 <posix_soc_clean_up+0x8c>
			 * won't really wait 1 second
			 */
		}
	}
	/* LCOV_EXCL_STOP */
}
 804aa10:	c9                   	leave  
 804aa11:	c3                   	ret    

0804aa12 <hwm_signal_end_handler>:

/**
 * Handler for SIGTERM and SIGINT
 */
void hwm_signal_end_handler(int sig)
{
 804aa12:	f3 0f 1e fb          	endbr32 
	signaled_end = 1;
 804aa16:	c7 05 68 29 05 08 01 	movl   $0x1,0x8052968
 804aa1d:	00 00 00 
}
 804aa20:	c3                   	ret    

0804aa21 <hwm_set_sig_handler>:
 *
 * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or
 * _XOPEN_SOURCE>=500
 */
void hwm_set_sig_handler(void)
{
 804aa21:	f3 0f 1e fb          	endbr32 
 804aa25:	55                   	push   %ebp
 804aa26:	89 e5                	mov    %esp,%ebp
 804aa28:	53                   	push   %ebx
 804aa29:	81 ec a0 00 00 00    	sub    $0xa0,%esp
 804aa2f:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804aa35:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804aa38:	31 c0                	xor    %eax,%eax
	struct sigaction act;

	act.sa_handler = hwm_signal_end_handler;
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
 804aa3a:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
	act.sa_handler = hwm_signal_end_handler;
 804aa40:	c7 85 68 ff ff ff 12 	movl   $0x804aa12,-0x98(%ebp)
 804aa47:	aa 04 08 
	PC_SAFE_CALL(sigemptyset(&act.sa_mask));
 804aa4a:	50                   	push   %eax
 804aa4b:	e8 60 ea ff ff       	call   80494b0 <sigemptyset@plt>
 804aa50:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
 804aa53:	85 c0                	test   %eax,%eax
 804aa55:	74 14                	je     804aa6b <hwm_set_sig_handler+0x4a>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804aa57:	50                   	push   %eax
 804aa58:	50                   	push   %eax
 804aa59:	68 98 e4 04 08       	push   $0x804e498
 804aa5e:	68 3f e2 04 08       	push   $0x804e23f
 804aa63:	e8 86 0e 00 00       	call   804b8ee <posix_print_error_and_exit>
 804aa68:	83 c4 10             	add    $0x10,%esp

	act.sa_flags = SA_RESETHAND;

	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
 804aa6b:	53                   	push   %ebx
 804aa6c:	8d 9d 68 ff ff ff    	lea    -0x98(%ebp),%ebx
 804aa72:	6a 00                	push   $0x0
 804aa74:	53                   	push   %ebx
 804aa75:	6a 0f                	push   $0xf
	act.sa_flags = SA_RESETHAND;
 804aa77:	c7 45 ec 00 00 00 80 	movl   $0x80000000,-0x14(%ebp)
	PC_SAFE_CALL(sigaction(SIGTERM, &act, NULL));
 804aa7e:	e8 7d ea ff ff       	call   8049500 <sigaction@plt>
 804aa83:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
 804aa86:	85 c0                	test   %eax,%eax
 804aa88:	74 14                	je     804aa9e <hwm_set_sig_handler+0x7d>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804aa8a:	51                   	push   %ecx
 804aa8b:	51                   	push   %ecx
 804aa8c:	68 b2 e4 04 08       	push   $0x804e4b2
 804aa91:	68 3f e2 04 08       	push   $0x804e23f
 804aa96:	e8 53 0e 00 00       	call   804b8ee <posix_print_error_and_exit>
 804aa9b:	83 c4 10             	add    $0x10,%esp
	PC_SAFE_CALL(sigaction(SIGINT, &act, NULL));
 804aa9e:	52                   	push   %edx
 804aa9f:	6a 00                	push   $0x0
 804aaa1:	53                   	push   %ebx
 804aaa2:	6a 02                	push   $0x2
 804aaa4:	e8 57 ea ff ff       	call   8049500 <sigaction@plt>
 804aaa9:	83 c4 10             	add    $0x10,%esp
	if (unlikely(test)) {
 804aaac:	85 c0                	test   %eax,%eax
 804aaae:	74 14                	je     804aac4 <hwm_set_sig_handler+0xa3>
		posix_print_error_and_exit("POSIX arch: Error on: %s\n",
 804aab0:	50                   	push   %eax
 804aab1:	50                   	push   %eax
 804aab2:	68 d1 e4 04 08       	push   $0x804e4d1
 804aab7:	68 3f e2 04 08       	push   $0x804e23f
 804aabc:	e8 2d 0e 00 00       	call   804b8ee <posix_print_error_and_exit>
 804aac1:	83 c4 10             	add    $0x10,%esp
}
 804aac4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804aac7:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804aace:	74 05                	je     804aad5 <hwm_set_sig_handler+0xb4>
 804aad0:	e8 bb e8 ff ff       	call   8049390 <__stack_chk_fail@plt>
 804aad5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804aad8:	c9                   	leave  
 804aad9:	c3                   	ret    

0804aada <hwm_find_next_timer>:
/**
 * Find in between all timers which is the next one
 * and update  next_timer_* accordingly
 */
void hwm_find_next_timer(void)
{
 804aada:	f3 0f 1e fb          	endbr32 
	next_timer_index = 0;
	next_timer_time  = *Timer_list[0];

	for (unsigned int i = 1; i < NUMBER_OF_TIMERS ; i++) {
		if (next_timer_time > *Timer_list[i]) {
 804aade:	8b 15 68 12 05 08    	mov    0x8051268,%edx
 804aae4:	a1 6c 12 05 08       	mov    0x805126c,%eax
{
 804aae9:	55                   	push   %ebp
	next_timer_time  = *Timer_list[0];
 804aaea:	8b 0d d4 28 05 08    	mov    0x80528d4,%ecx
	next_timer_index = 0;
 804aaf0:	c7 05 74 12 05 08 00 	movl   $0x0,0x8051274
 804aaf7:	00 00 00 
{
 804aafa:	89 e5                	mov    %esp,%ebp
 804aafc:	53                   	push   %ebx
	next_timer_time  = *Timer_list[0];
 804aafd:	8b 1d d0 28 05 08    	mov    0x80528d0,%ebx
 804ab03:	89 0d 8c 28 05 08    	mov    %ecx,0x805288c
		if (next_timer_time > *Timer_list[i]) {
 804ab09:	39 da                	cmp    %ebx,%edx
	next_timer_time  = *Timer_list[0];
 804ab0b:	89 1d 88 28 05 08    	mov    %ebx,0x8052888
		if (next_timer_time > *Timer_list[i]) {
 804ab11:	89 c3                	mov    %eax,%ebx
 804ab13:	19 cb                	sbb    %ecx,%ebx
 804ab15:	73 15                	jae    804ab2c <hwm_find_next_timer+0x52>
			next_timer_index = i;
 804ab17:	c7 05 74 12 05 08 01 	movl   $0x1,0x8051274
 804ab1e:	00 00 00 
			next_timer_time = *Timer_list[i];
 804ab21:	89 15 88 28 05 08    	mov    %edx,0x8052888
 804ab27:	a3 8c 28 05 08       	mov    %eax,0x805288c
		if (next_timer_time > *Timer_list[i]) {
 804ab2c:	a1 0c 29 05 08       	mov    0x805290c,%eax
 804ab31:	8b 15 08 29 05 08    	mov    0x8052908,%edx
 804ab37:	3b 15 88 28 05 08    	cmp    0x8052888,%edx
 804ab3d:	89 c1                	mov    %eax,%ecx
 804ab3f:	1b 0d 8c 28 05 08    	sbb    0x805288c,%ecx
 804ab45:	73 15                	jae    804ab5c <hwm_find_next_timer+0x82>
			next_timer_index = i;
 804ab47:	c7 05 74 12 05 08 02 	movl   $0x2,0x8051274
 804ab4e:	00 00 00 
			next_timer_time = *Timer_list[i];
 804ab51:	89 15 88 28 05 08    	mov    %edx,0x8052888
 804ab57:	a3 8c 28 05 08       	mov    %eax,0x805288c
		}
	}
}
 804ab5c:	5b                   	pop    %ebx
 804ab5d:	5d                   	pop    %ebp
 804ab5e:	c3                   	ret    

0804ab5f <hwm_main_loop>:
/**
 * Entry point for the HW models
 * The HW models execute in an infinite loop until terminated
 */
void hwm_main_loop(void)
{
 804ab5f:	f3 0f 1e fb          	endbr32 
 804ab63:	55                   	push   %ebp
 804ab64:	89 e5                	mov    %esp,%ebp
 804ab66:	56                   	push   %esi
 804ab67:	53                   	push   %ebx
 804ab68:	83 ec 10             	sub    $0x10,%esp
	if (next_timer_time >= simu_time) { /* LCOV_EXCL_BR_LINE */
 804ab6b:	a1 88 28 05 08       	mov    0x8052888,%eax
 804ab70:	8b 15 8c 28 05 08    	mov    0x805288c,%edx
 804ab76:	8b 0d 90 28 05 08    	mov    0x8052890,%ecx
 804ab7c:	8b 1d 94 28 05 08    	mov    0x8052894,%ebx
 804ab82:	89 d6                	mov    %edx,%esi
 804ab84:	39 c8                	cmp    %ecx,%eax
 804ab86:	19 de                	sbb    %ebx,%esi
 804ab88:	72 0d                	jb     804ab97 <hwm_main_loop+0x38>
		simu_time = next_timer_time;
 804ab8a:	a3 90 28 05 08       	mov    %eax,0x8052890
 804ab8f:	89 15 94 28 05 08    	mov    %edx,0x8052894
 804ab95:	eb 19                	jmp    804abb0 <hwm_main_loop+0x51>
		posix_print_warning("next_timer_time corrupted (%"PRIu64"<= %"
 804ab97:	56                   	push   %esi
 804ab98:	56                   	push   %esi
 804ab99:	ff 35 74 12 05 08    	pushl  0x8051274
 804ab9f:	53                   	push   %ebx
 804aba0:	51                   	push   %ecx
 804aba1:	52                   	push   %edx
 804aba2:	50                   	push   %eax
 804aba3:	68 ef e4 04 08       	push   $0x804e4ef
 804aba8:	e8 70 0d 00 00       	call   804b91d <posix_print_warning>
 804abad:	83 c4 20             	add    $0x20,%esp
	if (signaled_end || (simu_time > end_of_time)) {
 804abb0:	8b 0d 68 29 05 08    	mov    0x8052968,%ecx
 804abb6:	a1 90 28 05 08       	mov    0x8052890,%eax
 804abbb:	8b 15 94 28 05 08    	mov    0x8052894,%edx
 804abc1:	85 c9                	test   %ecx,%ecx
 804abc3:	75 10                	jne    804abd5 <hwm_main_loop+0x76>
 804abc5:	8b 0d 5c 12 05 08    	mov    0x805125c,%ecx
 804abcb:	39 05 58 12 05 08    	cmp    %eax,0x8051258
 804abd1:	19 d1                	sbb    %edx,%ecx
 804abd3:	73 38                	jae    804ac0d <hwm_main_loop+0xae>
				((long double)simu_time)/1.0e6L);
 804abd5:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804abd8:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804abdb:	df 6d f0             	fildll -0x10(%ebp)
 804abde:	85 d2                	test   %edx,%edx
 804abe0:	79 06                	jns    804abe8 <hwm_main_loop+0x89>
 804abe2:	d8 05 18 e1 04 08    	fadds  0x804e118
		posix_print_trace("\nStopped at %.3Lfs\n",
 804abe8:	d8 35 1c e1 04 08    	fdivs  0x804e11c
 804abee:	83 ec 0c             	sub    $0xc,%esp
 804abf1:	db 3c 24             	fstpt  (%esp)
 804abf4:	68 26 e5 04 08       	push   $0x804e526
 804abf9:	e8 42 0d 00 00       	call   804b940 <posix_print_trace>
		posix_exit(0);
 804abfe:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804ac05:	e8 a7 0b 00 00       	call   804b7b1 <posix_exit>
 804ac0a:	83 c4 10             	add    $0x10,%esp
	while (1) {
		hwm_sleep_until_next_timer();

		switch (next_timer_index) { /* LCOV_EXCL_BR_LINE */
 804ac0d:	a1 74 12 05 08       	mov    0x8051274,%eax
 804ac12:	83 f8 01             	cmp    $0x1,%eax
 804ac15:	74 10                	je     804ac27 <hwm_main_loop+0xc8>
 804ac17:	83 f8 02             	cmp    $0x2,%eax
 804ac1a:	74 12                	je     804ac2e <hwm_main_loop+0xcf>
 804ac1c:	85 c0                	test   %eax,%eax
 804ac1e:	75 15                	jne    804ac35 <hwm_main_loop+0xd6>
		case HWTIMER:
			hwtimer_timer_reached();
 804ac20:	e8 92 04 00 00       	call   804b0b7 <hwtimer_timer_reached>
			break;
 804ac25:	eb 1e                	jmp    804ac45 <hwm_main_loop+0xe6>
		case IRQCNT:
			hw_irq_ctrl_timer_triggered();
 804ac27:	e8 68 0b 00 00       	call   804b794 <hw_irq_ctrl_timer_triggered>
			break;
 804ac2c:	eb 17                	jmp    804ac45 <hwm_main_loop+0xe6>
		case HW_COUNTER:
			hw_counter_triggered();
 804ac2e:	e8 50 16 00 00       	call   804c283 <hw_counter_triggered>
			break;
 804ac33:	eb 10                	jmp    804ac45 <hwm_main_loop+0xe6>
			sdl_handle_events();
			break;
#endif
		default:
			/* LCOV_EXCL_START */
			posix_print_error_and_exit(
 804ac35:	83 ec 0c             	sub    $0xc,%esp
 804ac38:	68 3a e5 04 08       	push   $0x804e53a
 804ac3d:	e8 ac 0c 00 00       	call   804b8ee <posix_print_error_and_exit>
 804ac42:	83 c4 10             	add    $0x10,%esp
					"next_timer_index corrupted\n");
			break;
			/* LCOV_EXCL_STOP */
		}

		hwm_find_next_timer();
 804ac45:	e8 90 fe ff ff       	call   804aada <hwm_find_next_timer>
		hwm_sleep_until_next_timer();
 804ac4a:	e9 1c ff ff ff       	jmp    804ab6b <hwm_main_loop+0xc>

0804ac4f <hwm_set_end_of_time>:

/**
 * Set the simulated time when the process will stop
 */
void hwm_set_end_of_time(uint64_t new_end_of_time)
{
 804ac4f:	f3 0f 1e fb          	endbr32 
 804ac53:	55                   	push   %ebp
 804ac54:	89 e5                	mov    %esp,%ebp
	end_of_time = new_end_of_time;
 804ac56:	8b 45 08             	mov    0x8(%ebp),%eax
 804ac59:	8b 55 0c             	mov    0xc(%ebp),%edx
}
 804ac5c:	5d                   	pop    %ebp
	end_of_time = new_end_of_time;
 804ac5d:	a3 58 12 05 08       	mov    %eax,0x8051258
 804ac62:	89 15 5c 12 05 08    	mov    %edx,0x805125c
}
 804ac68:	c3                   	ret    

0804ac69 <hwm_get_time>:

/**
 * Return the current time as known by the device
 */
uint64_t hwm_get_time(void)
{
 804ac69:	f3 0f 1e fb          	endbr32 
	return simu_time;
}
 804ac6d:	a1 90 28 05 08       	mov    0x8052890,%eax
 804ac72:	8b 15 94 28 05 08    	mov    0x8052894,%edx
 804ac78:	c3                   	ret    

0804ac79 <hwm_init>:

/**
 * Function to initialize the HW models
 */
void hwm_init(void)
{
 804ac79:	f3 0f 1e fb          	endbr32 
 804ac7d:	55                   	push   %ebp
 804ac7e:	89 e5                	mov    %esp,%ebp
 804ac80:	83 ec 08             	sub    $0x8,%esp
	hwm_set_sig_handler();
 804ac83:	e8 99 fd ff ff       	call   804aa21 <hwm_set_sig_handler>
	hwtimer_init();
 804ac88:	e8 a4 02 00 00       	call   804af31 <hwtimer_init>
	hw_counter_init();
 804ac8d:	e8 95 15 00 00       	call   804c227 <hw_counter_init>
	hw_irq_ctrl_init();
 804ac92:	e8 a3 08 00 00       	call   804b53a <hw_irq_ctrl_init>

	hwm_find_next_timer();
}
 804ac97:	c9                   	leave  
	hwm_find_next_timer();
 804ac98:	e9 3d fe ff ff       	jmp    804aada <hwm_find_next_timer>

0804ac9d <hwm_cleanup>:
 * Function to free any resources allocated by the HW models
 * Note that this function needs to be designed so it is possible
 * to call it more than once during cleanup
 */
void hwm_cleanup(void)
{
 804ac9d:	f3 0f 1e fb          	endbr32 
 804aca1:	55                   	push   %ebp
 804aca2:	89 e5                	mov    %esp,%ebp
 804aca4:	83 ec 08             	sub    $0x8,%esp
	hwtimer_cleanup();
 804aca7:	e8 c4 03 00 00       	call   804b070 <hwtimer_cleanup>
	hw_irq_ctrl_cleanup();
}
 804acac:	c9                   	leave  
	hw_irq_ctrl_cleanup();
 804acad:	e9 d2 08 00 00       	jmp    804b584 <hw_irq_ctrl_cleanup>

0804acb2 <hwtimer_update_timer>:
	real_time_mode = new_rt;
}

static void hwtimer_update_timer(void)
{
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804acb2:	8b 0d cc 28 05 08    	mov    0x80528cc,%ecx
 804acb8:	a1 c4 28 05 08       	mov    0x80528c4,%eax
{
 804acbd:	55                   	push   %ebp
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804acbe:	8b 15 c0 28 05 08    	mov    0x80528c0,%edx
 804acc4:	39 15 c8 28 05 08    	cmp    %edx,0x80528c8
{
 804acca:	89 e5                	mov    %esp,%ebp
 804accc:	53                   	push   %ebx
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804accd:	89 cb                	mov    %ecx,%ebx
 804accf:	19 c3                	sbb    %eax,%ebx
 804acd1:	0f 42 15 c8 28 05 08 	cmovb  0x80528c8,%edx
}
 804acd8:	5b                   	pop    %ebx
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804acd9:	0f 42 c1             	cmovb  %ecx,%eax
}
 804acdc:	5d                   	pop    %ebp
	hw_timer_timer = MIN(hw_timer_tick_timer, hw_timer_awake_timer);
 804acdd:	89 15 d0 28 05 08    	mov    %edx,0x80528d0
 804ace3:	a3 d4 28 05 08       	mov    %eax,0x80528d4
}
 804ace8:	c3                   	ret    

0804ace9 <cmd_realtime_found>:
	}
	hwm_set_end_of_time(args.stop_at*1e6);
}

static void cmd_realtime_found(char *argv, int offset)
{
 804ace9:	f3 0f 1e fb          	endbr32 
	real_time_mode = new_rt;
 804aced:	c6 05 91 12 05 08 01 	movb   $0x1,0x8051291
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_real_time_mode(true);
}
 804acf4:	c3                   	ret    

0804acf5 <cmd_no_realtime_found>:

static void cmd_no_realtime_found(char *argv, int offset)
{
 804acf5:	f3 0f 1e fb          	endbr32 
	real_time_mode = new_rt;
 804acf9:	c6 05 91 12 05 08 00 	movb   $0x0,0x8051291
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_real_time_mode(false);
}
 804ad00:	c3                   	ret    

0804ad01 <cmd_rtcoffset_found>:

static void cmd_rtcoffset_found(char *argv, int offset)
{
 804ad01:	f3 0f 1e fb          	endbr32 
 804ad05:	55                   	push   %ebp
 804ad06:	89 e5                	mov    %esp,%ebp
 804ad08:	83 ec 08             	sub    $0x8,%esp
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_set_rtc_offset(args.rtc_offset*1e6);
 804ad0b:	d9 05 1c e1 04 08    	flds   0x804e11c
 804ad11:	d9 7d fe             	fnstcw -0x2(%ebp)
 804ad14:	dc 0d 68 25 05 08    	fmull  0x8052568
 804ad1a:	66 8b 45 fe          	mov    -0x2(%ebp),%ax
 804ad1e:	80 cc 0c             	or     $0xc,%ah
 804ad21:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
 804ad25:	d9 6d fc             	fldcw  -0x4(%ebp)
 804ad28:	df 3d a8 28 05 08    	fistpll 0x80528a8
 804ad2e:	d9 6d fe             	fldcw  -0x2(%ebp)
}
 804ad31:	c9                   	leave  
 804ad32:	c3                   	ret    

0804ad33 <cmd_rtcreset_found>:
	}
	hwtimer_set_rt_ratio(args.rt_ratio);
}

static void cmd_rtcreset_found(char *argv, int offset)
{
 804ad33:	f3 0f 1e fb          	endbr32 
	reset_rtc = true;
 804ad37:	c6 05 9f 29 05 08 01 	movb   $0x1,0x805299f
	ARG_UNUSED(argv);
	ARG_UNUSED(offset);
	hwtimer_reset_rtc();
}
 804ad3e:	c3                   	ret    

0804ad3f <native_add_time_options>:

static void native_add_time_options(void)
{
 804ad3f:	f3 0f 1e fb          	endbr32 
 804ad43:	55                   	push   %ebp
 804ad44:	89 e5                	mov    %esp,%ebp
 804ad46:	83 ec 14             	sub    $0x14,%esp
		(void *)&args.stop_at, cmd_stop_at_found,
		"In simulated seconds, when to stop automatically"},

		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(timer_options);
 804ad49:	68 c0 10 05 08       	push   $0x80510c0
 804ad4e:	e8 2a 13 00 00       	call   804c07d <native_add_command_line_opts>
 804ad53:	83 c4 10             	add    $0x10,%esp
}
 804ad56:	c9                   	leave  
 804ad57:	c3                   	ret    

0804ad58 <cmd_rt_ratio_found>:
{
 804ad58:	f3 0f 1e fb          	endbr32 
	if ((args.rt_ratio <= 0)) {
 804ad5c:	dd 05 78 25 05 08    	fldl   0x8052578
 804ad62:	d9 ee                	fldz   
 804ad64:	df f1                	fcomip %st(1),%st
 804ad66:	dd d8                	fstp   %st(0)
 804ad68:	72 21                	jb     804ad8b <cmd_rt_ratio_found+0x33>
{
 804ad6a:	55                   	push   %ebp
 804ad6b:	89 e5                	mov    %esp,%ebp
 804ad6d:	83 ec 14             	sub    $0x14,%esp
		posix_print_error_and_exit("The ratio needs to be > 0. "
 804ad70:	68 56 e5 04 08       	push   $0x804e556
 804ad75:	e8 74 0b 00 00       	call   804b8ee <posix_print_error_and_exit>
	clock_ratio = ratio;
 804ad7a:	dd 05 78 25 05 08    	fldl   0x8052578
		posix_print_error_and_exit("The ratio needs to be > 0. "
 804ad80:	83 c4 10             	add    $0x10,%esp
	clock_ratio = ratio;
 804ad83:	dd 1d 60 12 05 08    	fstpl  0x8051260
}
 804ad89:	c9                   	leave  
 804ad8a:	c3                   	ret    
	clock_ratio = ratio;
 804ad8b:	dd 05 78 25 05 08    	fldl   0x8052578
 804ad91:	dd 1d 60 12 05 08    	fstpl  0x8051260
 804ad97:	c3                   	ret    

0804ad98 <cmd_rt_drift_found>:
{
 804ad98:	f3 0f 1e fb          	endbr32 
 804ad9c:	55                   	push   %ebp
	if (!(args.rt_drift > -1)) {
 804ad9d:	d9 e8                	fld1   
 804ad9f:	d9 e0                	fchs   
{
 804ada1:	89 e5                	mov    %esp,%ebp
 804ada3:	83 ec 18             	sub    $0x18,%esp
	if (!(args.rt_drift > -1)) {
 804ada6:	dd 05 70 25 05 08    	fldl   0x8052570
 804adac:	df f1                	fcomip %st(1),%st
 804adae:	dd d8                	fstp   %st(0)
 804adb0:	77 10                	ja     804adc2 <cmd_rt_drift_found+0x2a>
		posix_print_error_and_exit("The drift needs to be > -1. "
 804adb2:	83 ec 0c             	sub    $0xc,%esp
 804adb5:	68 92 e5 04 08       	push   $0x804e592
 804adba:	e8 2f 0b 00 00       	call   804b8ee <posix_print_error_and_exit>
 804adbf:	83 c4 10             	add    $0x10,%esp
	args.rt_ratio = args.rt_drift + 1;
 804adc2:	d9 e8                	fld1   
 804adc4:	dc 05 70 25 05 08    	faddl  0x8052570
 804adca:	dd 5d f0             	fstpl  -0x10(%ebp)
 804adcd:	dd 45 f0             	fldl   -0x10(%ebp)
 804add0:	dd 15 78 25 05 08    	fstl   0x8052578
	clock_ratio = ratio;
 804add6:	dd 1d 60 12 05 08    	fstpl  0x8051260
}
 804addc:	c9                   	leave  
 804addd:	c3                   	ret    

0804adde <cmd_stop_at_found>:
{
 804adde:	f3 0f 1e fb          	endbr32 
 804ade2:	55                   	push   %ebp
	if (args.stop_at < 0) {
 804ade3:	d9 ee                	fldz   
{
 804ade5:	89 e5                	mov    %esp,%ebp
 804ade7:	53                   	push   %ebx
 804ade8:	83 ec 14             	sub    $0x14,%esp
	if (args.stop_at < 0) {
 804adeb:	dd 05 60 25 05 08    	fldl   0x8052560
 804adf1:	d9 c9                	fxch   %st(1)
{
 804adf3:	8b 45 08             	mov    0x8(%ebp),%eax
	if (args.stop_at < 0) {
 804adf6:	df f1                	fcomip %st(1),%st
 804adf8:	dd d8                	fstp   %st(0)
 804adfa:	76 10                	jbe    804ae0c <cmd_stop_at_found+0x2e>
		posix_print_error_and_exit("Error: stop-at must be positive "
 804adfc:	52                   	push   %edx
 804adfd:	52                   	push   %edx
 804adfe:	50                   	push   %eax
 804adff:	68 cf e5 04 08       	push   $0x804e5cf
 804ae04:	e8 e5 0a 00 00       	call   804b8ee <posix_print_error_and_exit>
 804ae09:	83 c4 10             	add    $0x10,%esp
	hwm_set_end_of_time(args.stop_at*1e6);
 804ae0c:	d9 05 1c e1 04 08    	flds   0x804e11c
 804ae12:	dc 0d 60 25 05 08    	fmull  0x8052560
 804ae18:	d9 05 20 e1 04 08    	flds   0x804e120
 804ae1e:	d9 c9                	fxch   %st(1)
 804ae20:	db f1                	fcomi  %st(1),%st
 804ae22:	73 21                	jae    804ae45 <cmd_stop_at_found+0x67>
 804ae24:	dd d9                	fstp   %st(1)
 804ae26:	d9 7d f6             	fnstcw -0xa(%ebp)
 804ae29:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
 804ae2d:	80 cc 0c             	or     $0xc,%ah
 804ae30:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
 804ae34:	d9 6d f4             	fldcw  -0xc(%ebp)
 804ae37:	df 7d e8             	fistpll -0x18(%ebp)
 804ae3a:	d9 6d f6             	fldcw  -0xa(%ebp)
 804ae3d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ae40:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804ae43:	eb 27                	jmp    804ae6c <cmd_stop_at_found+0x8e>
 804ae45:	d9 7d f6             	fnstcw -0xa(%ebp)
 804ae48:	de e1                	fsubp  %st,%st(1)
 804ae4a:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
 804ae4e:	80 cc 0c             	or     $0xc,%ah
 804ae51:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
 804ae55:	d9 6d f4             	fldcw  -0xc(%ebp)
 804ae58:	df 7d e8             	fistpll -0x18(%ebp)
 804ae5b:	d9 6d f6             	fldcw  -0xa(%ebp)
 804ae5e:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804ae61:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ae64:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
 804ae6a:	89 ca                	mov    %ecx,%edx
 804ae6c:	89 45 08             	mov    %eax,0x8(%ebp)
}
 804ae6f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
	hwm_set_end_of_time(args.stop_at*1e6);
 804ae72:	89 55 0c             	mov    %edx,0xc(%ebp)
}
 804ae75:	c9                   	leave  
	hwm_set_end_of_time(args.stop_at*1e6);
 804ae76:	e9 d4 fd ff ff       	jmp    804ac4f <hwm_set_end_of_time>

0804ae7b <get_host_us_time>:
{
 804ae7b:	f3 0f 1e fb          	endbr32 
 804ae7f:	55                   	push   %ebp
 804ae80:	89 e5                	mov    %esp,%ebp
 804ae82:	53                   	push   %ebx
 804ae83:	83 ec 2c             	sub    $0x2c,%esp
 804ae86:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804ae8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804ae8f:	31 c0                	xor    %eax,%eax
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
 804ae91:	8d 45 ec             	lea    -0x14(%ebp),%eax
 804ae94:	50                   	push   %eax
 804ae95:	6a 04                	push   $0x4
 804ae97:	e8 b4 e4 ff ff       	call   8049350 <clock_gettime@plt>
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804ae9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ae9f:	db 45 ec             	fildl  -0x14(%ebp)
	clock_gettime(CLOCK_MONOTONIC_RAW, tv);
 804aea2:	83 c4 10             	add    $0x10,%esp
	return (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804aea5:	99                   	cltd   
 804aea6:	85 d2                	test   %edx,%edx
 804aea8:	79 06                	jns    804aeb0 <get_host_us_time+0x35>
 804aeaa:	d8 05 18 e1 04 08    	fadds  0x804e118
 804aeb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804aeb3:	d8 0d 1c e1 04 08    	fmuls  0x804e11c
 804aeb9:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
 804aebe:	99                   	cltd   
 804aebf:	f7 f9                	idiv   %ecx
 804aec1:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804aec4:	da 45 d8             	fiaddl -0x28(%ebp)
 804aec7:	d9 05 20 e1 04 08    	flds   0x804e120
 804aecd:	d9 c9                	fxch   %st(1)
 804aecf:	db f1                	fcomi  %st(1),%st
 804aed1:	73 21                	jae    804aef4 <get_host_us_time+0x79>
 804aed3:	dd d9                	fstp   %st(1)
 804aed5:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804aed8:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804aedc:	80 cc 0c             	or     $0xc,%ah
 804aedf:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804aee3:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804aee6:	df 7d d8             	fistpll -0x28(%ebp)
 804aee9:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804aeec:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804aeef:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804aef2:	eb 27                	jmp    804af1b <get_host_us_time+0xa0>
 804aef4:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804aef7:	de e1                	fsubp  %st,%st(1)
 804aef9:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804aefd:	80 cc 0c             	or     $0xc,%ah
 804af00:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804af04:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804af07:	df 7d d8             	fistpll -0x28(%ebp)
 804af0a:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804af0d:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804af10:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804af13:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
 804af19:	89 ca                	mov    %ecx,%edx
}
 804af1b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
 804af1e:	65 33 1d 14 00 00 00 	xor    %gs:0x14,%ebx
 804af25:	74 05                	je     804af2c <get_host_us_time+0xb1>
 804af27:	e8 64 e4 ff ff       	call   8049390 <__stack_chk_fail@plt>
 804af2c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804af2f:	c9                   	leave  
 804af30:	c3                   	ret    

0804af31 <hwtimer_init>:
{
 804af31:	f3 0f 1e fb          	endbr32 
 804af35:	55                   	push   %ebp
 804af36:	89 e5                	mov    %esp,%ebp
 804af38:	53                   	push   %ebx
 804af39:	83 ec 24             	sub    $0x24,%esp
 804af3c:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804af42:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804af45:	31 c0                	xor    %eax,%eax
	silent_ticks = 0;
 804af47:	c7 05 b0 28 05 08 00 	movl   $0x0,0x80528b0
 804af4e:	00 00 00 
 804af51:	c7 05 b4 28 05 08 00 	movl   $0x0,0x80528b4
 804af58:	00 00 00 
	hw_timer_tick_timer = NEVER;
 804af5b:	c7 05 c8 28 05 08 ff 	movl   $0xffffffff,0x80528c8
 804af62:	ff ff ff 
 804af65:	c7 05 cc 28 05 08 ff 	movl   $0xffffffff,0x80528cc
 804af6c:	ff ff ff 
	hw_timer_awake_timer = NEVER;
 804af6f:	c7 05 c0 28 05 08 ff 	movl   $0xffffffff,0x80528c0
 804af76:	ff ff ff 
 804af79:	c7 05 c4 28 05 08 ff 	movl   $0xffffffff,0x80528c4
 804af80:	ff ff ff 
	hwtimer_update_timer();
 804af83:	e8 2a fd ff ff       	call   804acb2 <hwtimer_update_timer>
	if (real_time_mode) {
 804af88:	80 3d 91 12 05 08 00 	cmpb   $0x0,0x8051291
 804af8f:	74 24                	je     804afb5 <hwtimer_init+0x84>
		boot_time = get_host_us_time();
 804af91:	e8 e5 fe ff ff       	call   804ae7b <get_host_us_time>
		last_radj_stime = 0U;
 804af96:	c7 05 98 28 05 08 00 	movl   $0x0,0x8052898
 804af9d:	00 00 00 
		last_radj_rtime = boot_time;
 804afa0:	a3 a0 28 05 08       	mov    %eax,0x80528a0
 804afa5:	89 15 a4 28 05 08    	mov    %edx,0x80528a4
		last_radj_stime = 0U;
 804afab:	c7 05 9c 28 05 08 00 	movl   $0x0,0x805289c
 804afb2:	00 00 00 
	if (!reset_rtc) {
 804afb5:	80 3d 9f 29 05 08 00 	cmpb   $0x0,0x805299f
 804afbc:	0f 85 98 00 00 00    	jne    804b05a <hwtimer_init+0x129>
		clock_gettime(CLOCK_REALTIME, &tv);
 804afc2:	50                   	push   %eax
 804afc3:	50                   	push   %eax
 804afc4:	8d 45 ec             	lea    -0x14(%ebp),%eax
 804afc7:	50                   	push   %eax
 804afc8:	6a 00                	push   $0x0
 804afca:	e8 81 e3 ff ff       	call   8049350 <clock_gettime@plt>
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804afcf:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804afd2:	db 45 ec             	fildl  -0x14(%ebp)
		clock_gettime(CLOCK_REALTIME, &tv);
 804afd5:	83 c4 10             	add    $0x10,%esp
		realhosttime = (uint64_t)tv.tv_sec * 1e6 + tv.tv_nsec / 1000;
 804afd8:	99                   	cltd   
 804afd9:	85 d2                	test   %edx,%edx
 804afdb:	79 06                	jns    804afe3 <hwtimer_init+0xb2>
 804afdd:	d8 05 18 e1 04 08    	fadds  0x804e118
 804afe3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804afe6:	d8 0d 1c e1 04 08    	fmuls  0x804e11c
 804afec:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
 804aff1:	99                   	cltd   
 804aff2:	f7 f9                	idiv   %ecx
 804aff4:	89 45 d8             	mov    %eax,-0x28(%ebp)
 804aff7:	da 45 d8             	fiaddl -0x28(%ebp)
 804affa:	d9 05 20 e1 04 08    	flds   0x804e120
 804b000:	d9 c9                	fxch   %st(1)
 804b002:	db f1                	fcomi  %st(1),%st
 804b004:	73 21                	jae    804b027 <hwtimer_init+0xf6>
 804b006:	dd d9                	fstp   %st(1)
 804b008:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804b00b:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804b00f:	80 cc 0c             	or     $0xc,%ah
 804b012:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804b016:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804b019:	df 7d d8             	fistpll -0x28(%ebp)
 804b01c:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804b01f:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804b022:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804b025:	eb 27                	jmp    804b04e <hwtimer_init+0x11d>
 804b027:	d9 7d e6             	fnstcw -0x1a(%ebp)
 804b02a:	de e1                	fsubp  %st,%st(1)
 804b02c:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
 804b030:	80 cc 0c             	or     $0xc,%ah
 804b033:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
 804b037:	d9 6d e4             	fldcw  -0x1c(%ebp)
 804b03a:	df 7d d8             	fistpll -0x28(%ebp)
 804b03d:	d9 6d e6             	fldcw  -0x1a(%ebp)
 804b040:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804b043:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804b046:	8d 8a 00 00 00 80    	lea    -0x80000000(%edx),%ecx
 804b04c:	89 ca                	mov    %ecx,%edx
		rtc_offset += realhosttime;
 804b04e:	01 05 a8 28 05 08    	add    %eax,0x80528a8
 804b054:	11 15 ac 28 05 08    	adc    %edx,0x80528ac
}
 804b05a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b05d:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804b064:	74 05                	je     804b06b <hwtimer_init+0x13a>
 804b066:	e8 25 e3 ff ff       	call   8049390 <__stack_chk_fail@plt>
 804b06b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804b06e:	c9                   	leave  
 804b06f:	c3                   	ret    

0804b070 <hwtimer_cleanup>:
{
 804b070:	f3 0f 1e fb          	endbr32 
}
 804b074:	c3                   	ret    

0804b075 <hwtimer_enable>:
{
 804b075:	f3 0f 1e fb          	endbr32 
 804b079:	55                   	push   %ebp
 804b07a:	89 e5                	mov    %esp,%ebp
 804b07c:	83 ec 08             	sub    $0x8,%esp
	tick_p = period;
 804b07f:	8b 45 08             	mov    0x8(%ebp),%eax
 804b082:	8b 55 0c             	mov    0xc(%ebp),%edx
 804b085:	a3 b8 28 05 08       	mov    %eax,0x80528b8
 804b08a:	89 15 bc 28 05 08    	mov    %edx,0x80528bc
	hw_timer_tick_timer = hwm_get_time() + tick_p;
 804b090:	e8 d4 fb ff ff       	call   804ac69 <hwm_get_time>
 804b095:	03 05 b8 28 05 08    	add    0x80528b8,%eax
 804b09b:	13 15 bc 28 05 08    	adc    0x80528bc,%edx
 804b0a1:	a3 c8 28 05 08       	mov    %eax,0x80528c8
 804b0a6:	89 15 cc 28 05 08    	mov    %edx,0x80528cc
	hwtimer_update_timer();
 804b0ac:	e8 01 fc ff ff       	call   804acb2 <hwtimer_update_timer>
}
 804b0b1:	c9                   	leave  
	hwm_find_next_timer();
 804b0b2:	e9 23 fa ff ff       	jmp    804aada <hwm_find_next_timer>

0804b0b7 <hwtimer_timer_reached>:
{
 804b0b7:	f3 0f 1e fb          	endbr32 
 804b0bb:	55                   	push   %ebp
 804b0bc:	89 e5                	mov    %esp,%ebp
 804b0be:	56                   	push   %esi
 804b0bf:	53                   	push   %ebx
 804b0c0:	83 ec 30             	sub    $0x30,%esp
	uint64_t Now = hw_timer_timer;
 804b0c3:	8b 1d d0 28 05 08    	mov    0x80528d0,%ebx
 804b0c9:	8b 35 d4 28 05 08    	mov    0x80528d4,%esi
{
 804b0cf:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804b0d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804b0d8:	31 c0                	xor    %eax,%eax
	if (hw_timer_awake_timer == Now) {
 804b0da:	39 35 c4 28 05 08    	cmp    %esi,0x80528c4
 804b0e0:	75 31                	jne    804b113 <hwtimer_timer_reached+0x5c>
 804b0e2:	39 1d c0 28 05 08    	cmp    %ebx,0x80528c0
 804b0e8:	75 29                	jne    804b113 <hwtimer_timer_reached+0x5c>
	hw_timer_awake_timer = NEVER;
 804b0ea:	c7 05 c0 28 05 08 ff 	movl   $0xffffffff,0x80528c0
 804b0f1:	ff ff ff 
 804b0f4:	c7 05 c4 28 05 08 ff 	movl   $0xffffffff,0x80528c4
 804b0fb:	ff ff ff 
	hwtimer_update_timer();
 804b0fe:	e8 af fb ff ff       	call   804acb2 <hwtimer_update_timer>
	hw_irq_ctrl_set_irq(PHONY_HARD_IRQ);
 804b103:	83 ec 0c             	sub    $0xc,%esp
 804b106:	68 ff ff 00 00       	push   $0xffff
 804b10b:	e8 da 05 00 00       	call   804b6ea <hw_irq_ctrl_set_irq>
 804b110:	83 c4 10             	add    $0x10,%esp
	if (hw_timer_tick_timer == Now) {
 804b113:	8b 15 cc 28 05 08    	mov    0x80528cc,%edx
 804b119:	a1 c8 28 05 08       	mov    0x80528c8,%eax
 804b11e:	39 f2                	cmp    %esi,%edx
 804b120:	0f 85 5a 01 00 00    	jne    804b280 <hwtimer_timer_reached+0x1c9>
 804b126:	39 d8                	cmp    %ebx,%eax
 804b128:	0f 85 52 01 00 00    	jne    804b280 <hwtimer_timer_reached+0x1c9>
	if (real_time_mode) {
 804b12e:	80 3d 91 12 05 08 00 	cmpb   $0x0,0x8051291
 804b135:	0f 84 f6 00 00 00    	je     804b231 <hwtimer_timer_reached+0x17a>
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
 804b13b:	2b 05 98 28 05 08    	sub    0x8052898,%eax
 804b141:	1b 15 9c 28 05 08    	sbb    0x805289c,%edx
				    / clock_ratio
 804b147:	89 45 c8             	mov    %eax,-0x38(%ebp)
 804b14a:	89 55 cc             	mov    %edx,-0x34(%ebp)
 804b14d:	df 6d c8             	fildll -0x38(%ebp)
 804b150:	85 d2                	test   %edx,%edx
 804b152:	79 06                	jns    804b15a <hwtimer_timer_reached+0xa3>
 804b154:	d8 05 18 e1 04 08    	fadds  0x804e118
 804b15a:	dc 35 60 12 05 08    	fdivl  0x8051260
				    + last_radj_rtime;
 804b160:	83 3d a4 28 05 08 00 	cmpl   $0x0,0x80528a4
 804b167:	df 2d a0 28 05 08    	fildll 0x80528a0
 804b16d:	79 06                	jns    804b175 <hwtimer_timer_reached+0xbe>
 804b16f:	d8 05 18 e1 04 08    	fadds  0x804e118
 804b175:	de c1                	faddp  %st,%st(1)
		uint64_t expected_rt = (hw_timer_tick_timer - last_radj_stime)
 804b177:	d9 05 20 e1 04 08    	flds   0x804e120
 804b17d:	d9 c9                	fxch   %st(1)
 804b17f:	db f1                	fcomi  %st(1),%st
 804b181:	73 1b                	jae    804b19e <hwtimer_timer_reached+0xe7>
 804b183:	dd d9                	fstp   %st(1)
 804b185:	d9 7d d6             	fnstcw -0x2a(%ebp)
 804b188:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
 804b18c:	80 cc 0c             	or     $0xc,%ah
 804b18f:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
 804b193:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804b196:	df 7d c8             	fistpll -0x38(%ebp)
 804b199:	d9 6d d6             	fldcw  -0x2a(%ebp)
 804b19c:	eb 24                	jmp    804b1c2 <hwtimer_timer_reached+0x10b>
 804b19e:	d9 7d d6             	fnstcw -0x2a(%ebp)
 804b1a1:	de e1                	fsubp  %st,%st(1)
 804b1a3:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
 804b1a7:	80 cc 0c             	or     $0xc,%ah
 804b1aa:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
 804b1ae:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804b1b1:	df 7d c8             	fistpll -0x38(%ebp)
 804b1b4:	d9 6d d6             	fldcw  -0x2a(%ebp)
 804b1b7:	8b 45 cc             	mov    -0x34(%ebp),%eax
 804b1ba:	05 00 00 00 80       	add    $0x80000000,%eax
 804b1bf:	89 45 cc             	mov    %eax,-0x34(%ebp)
		uint64_t real_time = get_host_us_time();
 804b1c2:	e8 b4 fc ff ff       	call   804ae7b <get_host_us_time>
		int64_t diff = expected_rt - real_time;
 804b1c7:	8b 4d c8             	mov    -0x38(%ebp),%ecx
 804b1ca:	8b 5d cc             	mov    -0x34(%ebp),%ebx
 804b1cd:	29 c1                	sub    %eax,%ecx
 804b1cf:	19 d3                	sbb    %edx,%ebx
 804b1d1:	89 4d c8             	mov    %ecx,-0x38(%ebp)
		if (diff > 0) { /* we need to slow down */
 804b1d4:	31 c0                	xor    %eax,%eax
 804b1d6:	3b 45 c8             	cmp    -0x38(%ebp),%eax
		int64_t diff = expected_rt - real_time;
 804b1d9:	89 5d cc             	mov    %ebx,-0x34(%ebp)
		if (diff > 0) { /* we need to slow down */
 804b1dc:	1b 45 cc             	sbb    -0x34(%ebp),%eax
 804b1df:	7d 50                	jge    804b231 <hwtimer_timer_reached+0x17a>
			requested_time.tv_sec  = diff / 1e6;
 804b1e1:	d9 7d d6             	fnstcw -0x2a(%ebp)
 804b1e4:	df 6d c8             	fildll -0x38(%ebp)
 804b1e7:	d9 05 1c e1 04 08    	flds   0x804e11c
 804b1ed:	66 8b 45 d6          	mov    -0x2a(%ebp),%ax
 804b1f1:	d9 c1                	fld    %st(1)
 804b1f3:	d8 f1                	fdiv   %st(1),%st
 804b1f5:	80 cc 0c             	or     $0xc,%ah
 804b1f8:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
 804b1fc:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804b1ff:	db 5d c8             	fistpl -0x38(%ebp)
 804b202:	d9 6d d6             	fldcw  -0x2a(%ebp)
 804b205:	8b 45 c8             	mov    -0x38(%ebp),%eax
						 requested_time.tv_sec*1e6)*1e3;
 804b208:	da 4d c8             	fimull -0x38(%ebp)
			requested_time.tv_sec  = diff / 1e6;
 804b20b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			(void) nanosleep(&requested_time, &remaining);
 804b20e:	50                   	push   %eax
 804b20f:	50                   	push   %eax
			requested_time.tv_nsec = (diff -
 804b210:	de e9                	fsubrp %st,%st(1)
			(void) nanosleep(&requested_time, &remaining);
 804b212:	8d 45 ec             	lea    -0x14(%ebp),%eax
						 requested_time.tv_sec*1e6)*1e3;
 804b215:	d8 0d 24 e1 04 08    	fmuls  0x804e124
			(void) nanosleep(&requested_time, &remaining);
 804b21b:	50                   	push   %eax
 804b21c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 804b21f:	50                   	push   %eax
			requested_time.tv_nsec = (diff -
 804b220:	d9 6d d4             	fldcw  -0x2c(%ebp)
 804b223:	db 5d e8             	fistpl -0x18(%ebp)
 804b226:	d9 6d d6             	fldcw  -0x2a(%ebp)
			(void) nanosleep(&requested_time, &remaining);
 804b229:	e8 a2 e2 ff ff       	call   80494d0 <nanosleep@plt>
 804b22e:	83 c4 10             	add    $0x10,%esp
	hw_timer_tick_timer += tick_p;
 804b231:	a1 b8 28 05 08       	mov    0x80528b8,%eax
 804b236:	8b 15 bc 28 05 08    	mov    0x80528bc,%edx
 804b23c:	01 05 c8 28 05 08    	add    %eax,0x80528c8
 804b242:	11 15 cc 28 05 08    	adc    %edx,0x80528cc
	hwtimer_update_timer();
 804b248:	e8 65 fa ff ff       	call   804acb2 <hwtimer_update_timer>
	if (silent_ticks > 0) {
 804b24d:	a1 b0 28 05 08       	mov    0x80528b0,%eax
 804b252:	31 c9                	xor    %ecx,%ecx
 804b254:	8b 15 b4 28 05 08    	mov    0x80528b4,%edx
 804b25a:	39 c1                	cmp    %eax,%ecx
 804b25c:	19 d1                	sbb    %edx,%ecx
 804b25e:	7d 13                	jge    804b273 <hwtimer_timer_reached+0x1bc>
		silent_ticks -= 1;
 804b260:	83 c0 ff             	add    $0xffffffff,%eax
 804b263:	83 d2 ff             	adc    $0xffffffff,%edx
 804b266:	a3 b0 28 05 08       	mov    %eax,0x80528b0
 804b26b:	89 15 b4 28 05 08    	mov    %edx,0x80528b4
 804b271:	eb 0d                	jmp    804b280 <hwtimer_timer_reached+0x1c9>
		hw_irq_ctrl_set_irq(TIMER_TICK_IRQ);
 804b273:	83 ec 0c             	sub    $0xc,%esp
 804b276:	6a 00                	push   $0x0
 804b278:	e8 6d 04 00 00       	call   804b6ea <hw_irq_ctrl_set_irq>
 804b27d:	83 c4 10             	add    $0x10,%esp
}
 804b280:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b283:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804b28a:	74 05                	je     804b291 <hwtimer_timer_reached+0x1da>
 804b28c:	e8 ff e0 ff ff       	call   8049390 <__stack_chk_fail@plt>
 804b291:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804b294:	5b                   	pop    %ebx
 804b295:	5e                   	pop    %esi
 804b296:	5d                   	pop    %ebp
 804b297:	c3                   	ret    

0804b298 <hwtimer_wake_in_time>:
{
 804b298:	f3 0f 1e fb          	endbr32 
 804b29c:	55                   	push   %ebp
 804b29d:	89 e5                	mov    %esp,%ebp
 804b29f:	83 ec 08             	sub    $0x8,%esp
 804b2a2:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b2a5:	8b 55 08             	mov    0x8(%ebp),%edx
	if (hw_timer_awake_timer > time) {
 804b2a8:	3b 15 c0 28 05 08    	cmp    0x80528c0,%edx
 804b2ae:	89 c1                	mov    %eax,%ecx
 804b2b0:	1b 0d c4 28 05 08    	sbb    0x80528c4,%ecx
 804b2b6:	73 16                	jae    804b2ce <hwtimer_wake_in_time+0x36>
		hw_timer_awake_timer = time;
 804b2b8:	89 15 c0 28 05 08    	mov    %edx,0x80528c0
 804b2be:	a3 c4 28 05 08       	mov    %eax,0x80528c4
		hwtimer_update_timer();
 804b2c3:	e8 ea f9 ff ff       	call   804acb2 <hwtimer_update_timer>
}
 804b2c8:	c9                   	leave  
		hwm_find_next_timer();
 804b2c9:	e9 0c f8 ff ff       	jmp    804aada <hwm_find_next_timer>
}
 804b2ce:	c9                   	leave  
 804b2cf:	c3                   	ret    

0804b2d0 <hwtimer_set_silent_ticks>:
{
 804b2d0:	f3 0f 1e fb          	endbr32 
 804b2d4:	55                   	push   %ebp
 804b2d5:	89 e5                	mov    %esp,%ebp
	silent_ticks = sys_ticks;
 804b2d7:	8b 45 08             	mov    0x8(%ebp),%eax
 804b2da:	8b 55 0c             	mov    0xc(%ebp),%edx
}
 804b2dd:	5d                   	pop    %ebp
	silent_ticks = sys_ticks;
 804b2de:	a3 b0 28 05 08       	mov    %eax,0x80528b0
 804b2e3:	89 15 b4 28 05 08    	mov    %edx,0x80528b4
}
 804b2e9:	c3                   	ret    

0804b2ea <posix_irq_handler>:
 * Note that even that this function is executing in a Zephyr thread,  it is
 * effectively the model of the interrupt controller passing context to the IRQ
 * handler and therefore its priority handling
 */
void posix_irq_handler(void)
{
 804b2ea:	f3 0f 1e fb          	endbr32 
 804b2ee:	55                   	push   %ebp
 804b2ef:	89 e5                	mov    %esp,%ebp
 804b2f1:	57                   	push   %edi
 804b2f2:	56                   	push   %esi
 804b2f3:	53                   	push   %ebx
 804b2f4:	83 ec 0c             	sub    $0xc,%esp
	uint64_t irq_lock;
	int irq_nbr;
	static int may_swap;

	irq_lock = hw_irq_ctrl_get_current_lock();
 804b2f7:	e8 67 03 00 00       	call   804b663 <hw_irq_ctrl_get_current_lock>

	if (irq_lock) {
 804b2fc:	85 c0                	test   %eax,%eax
 804b2fe:	0f 85 f9 00 00 00    	jne    804b3fd <posix_irq_handler+0x113>
		/* "spurious" wakes can happen with interrupts locked */
		return;
	}

	if (_kernel.cpus[0].nested == 0) {
 804b304:	a1 60 28 05 08       	mov    0x8052860,%eax
 804b309:	85 c0                	test   %eax,%eax
 804b30b:	75 0a                	jne    804b317 <posix_irq_handler+0x2d>
		may_swap = 0;
 804b30d:	c7 05 6c 29 05 08 00 	movl   $0x0,0x805296c
 804b314:	00 00 00 
	}

	_kernel.cpus[0].nested++;
 804b317:	40                   	inc    %eax
 804b318:	a3 60 28 05 08       	mov    %eax,0x8052860

	while ((irq_nbr = hw_irq_ctrl_get_highest_prio_irq()) != -1) {
 804b31d:	e8 a9 02 00 00       	call   804b5cb <hw_irq_ctrl_get_highest_prio_irq>
 804b322:	89 c3                	mov    %eax,%ebx
 804b324:	83 f8 ff             	cmp    $0xffffffff,%eax
 804b327:	0f 84 9b 00 00 00    	je     804b3c8 <posix_irq_handler+0xde>
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
 804b32d:	e8 68 02 00 00       	call   804b59a <hw_irq_ctrl_get_cur_prio>
		int last_running_irq = currently_running_irq;

		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
 804b332:	83 ec 0c             	sub    $0xc,%esp
		int last_running_irq = currently_running_irq;
 804b335:	8b 3d 78 12 05 08    	mov    0x8051278,%edi
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
 804b33b:	53                   	push   %ebx
		int last_current_running_prio = hw_irq_ctrl_get_cur_prio();
 804b33c:	89 c6                	mov    %eax,%esi
		hw_irq_ctrl_set_cur_prio(hw_irq_ctrl_get_prio(irq_nbr));
 804b33e:	e8 76 02 00 00       	call   804b5b9 <hw_irq_ctrl_get_prio>
 804b343:	0f b6 c0             	movzbl %al,%eax
 804b346:	89 04 24             	mov    %eax,(%esp)
 804b349:	e8 3b 02 00 00       	call   804b589 <hw_irq_ctrl_set_cur_prio>
		hw_irq_ctrl_clear_irq(irq_nbr);
 804b34e:	89 1c 24             	mov    %ebx,(%esp)
 804b351:	e8 53 03 00 00       	call   804b6a9 <hw_irq_ctrl_clear_irq>
 804b356:	83 c4 10             	add    $0x10,%esp

		currently_running_irq = irq_nbr;
 804b359:	89 1d 78 12 05 08    	mov    %ebx,0x8051278
	sys_trace_isr_enter();
 804b35f:	e8 58 ee ff ff       	call   804a1bc <sys_trace_isr_enter>
	if (irq_vector_table[irq_nbr].func == NULL) { /* LCOV_EXCL_BR_LINE */
 804b364:	89 d8                	mov    %ebx,%eax
 804b366:	c1 e0 04             	shl    $0x4,%eax
 804b369:	05 80 25 05 08       	add    $0x8052580,%eax
 804b36e:	8b 50 08             	mov    0x8(%eax),%edx
 804b371:	85 d2                	test   %edx,%edx
 804b373:	75 12                	jne    804b387 <posix_irq_handler+0x9d>
		posix_print_error_and_exit("Received irq %i without a "
 804b375:	50                   	push   %eax
 804b376:	50                   	push   %eax
 804b377:	53                   	push   %ebx
 804b378:	68 ce e9 04 08       	push   $0x804e9ce
 804b37d:	e8 6c 05 00 00       	call   804b8ee <posix_print_error_and_exit>
 804b382:	83 c4 10             	add    $0x10,%esp
 804b385:	eb 25                	jmp    804b3ac <posix_irq_handler+0xc2>
		if (irq_vector_table[irq_nbr].flags & ISR_FLAG_DIRECT) {
 804b387:	f6 40 04 01          	testb  $0x1,0x4(%eax)
 804b38b:	74 0a                	je     804b397 <posix_irq_handler+0xad>
			*may_swap |= ((direct_irq_f_ptr)
 804b38d:	ff d2                	call   *%edx
 804b38f:	09 05 6c 29 05 08    	or     %eax,0x805296c
 804b395:	eb 15                	jmp    804b3ac <posix_irq_handler+0xc2>
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
 804b397:	83 ec 0c             	sub    $0xc,%esp
 804b39a:	ff 70 0c             	pushl  0xc(%eax)
 804b39d:	ff d2                	call   *%edx
			*may_swap = 1;
 804b39f:	c7 05 6c 29 05 08 01 	movl   $0x1,0x805296c
 804b3a6:	00 00 00 
			((normal_irq_f_ptr)irq_vector_table[irq_nbr].func)
 804b3a9:	83 c4 10             	add    $0x10,%esp
	sys_trace_isr_exit();
 804b3ac:	e8 10 ee ff ff       	call   804a1c1 <sys_trace_isr_exit>
		vector_to_irq(irq_nbr, &may_swap);
		currently_running_irq = last_running_irq;

		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
 804b3b1:	83 ec 0c             	sub    $0xc,%esp
		currently_running_irq = last_running_irq;
 804b3b4:	89 3d 78 12 05 08    	mov    %edi,0x8051278
		hw_irq_ctrl_set_cur_prio(last_current_running_prio);
 804b3ba:	56                   	push   %esi
 804b3bb:	e8 c9 01 00 00       	call   804b589 <hw_irq_ctrl_set_cur_prio>
 804b3c0:	83 c4 10             	add    $0x10,%esp
 804b3c3:	e9 55 ff ff ff       	jmp    804b31d <posix_irq_handler+0x33>
	}

	_kernel.cpus[0].nested--;
 804b3c8:	ff 0d 60 28 05 08    	decl   0x8052860
	/* Call swap if all the following is true:
	 * 1) may_swap was enabled
	 * 2) We are not nesting irq_handler calls (interrupts)
	 * 3) Next thread to run in the ready queue is not this thread
	 */
	if (may_swap
 804b3ce:	83 3d 6c 29 05 08 00 	cmpl   $0x0,0x805296c
 804b3d5:	74 26                	je     804b3fd <posix_irq_handler+0x113>
		&& (hw_irq_ctrl_get_cur_prio() == 256)
 804b3d7:	e8 be 01 00 00       	call   804b59a <hw_irq_ctrl_get_cur_prio>
 804b3dc:	3d 00 01 00 00       	cmp    $0x100,%eax
 804b3e1:	75 1a                	jne    804b3fd <posix_irq_handler+0x113>
		&& (_kernel.ready_q.cache != _current)) {
 804b3e3:	a1 68 28 05 08       	mov    0x8052868,%eax
 804b3e8:	39 05 78 28 05 08    	cmp    %eax,0x8052878
 804b3ee:	74 0d                	je     804b3fd <posix_irq_handler+0x113>

static inline int z_swap_irqlock(unsigned int key)
{
	int ret;
	z_check_stack_sentinel();
	ret = arch_swap(key);
 804b3f0:	83 ec 0c             	sub    $0xc,%esp
 804b3f3:	6a 00                	push   $0x0
 804b3f5:	e8 a6 f2 ff ff       	call   804a6a0 <arch_swap>
 804b3fa:	83 c4 10             	add    $0x10,%esp

		(void)z_swap_irqlock(irq_lock);
	}
}
 804b3fd:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b400:	5b                   	pop    %ebx
 804b401:	5e                   	pop    %esi
 804b402:	5f                   	pop    %edi
 804b403:	5d                   	pop    %ebp
 804b404:	c3                   	ret    

0804b405 <posix_irq_handler_im_from_sw>:
 * Thru this function the IRQ controller can raise an immediate  interrupt which
 * will interrupt the SW itself
 * (this function should only be called from the HW model code, from SW threads)
 */
void posix_irq_handler_im_from_sw(void)
{
 804b405:	f3 0f 1e fb          	endbr32 
 804b409:	55                   	push   %ebp
 804b40a:	89 e5                	mov    %esp,%ebp
 804b40c:	83 ec 08             	sub    $0x8,%esp
	/*
	 * if a higher priority interrupt than the possibly currently running is
	 * pending we go immediately into irq_handler() to vector into its
	 * handler
	 */
	if (hw_irq_ctrl_get_highest_prio_irq() != -1) {
 804b40f:	e8 b7 01 00 00       	call   804b5cb <hw_irq_ctrl_get_highest_prio_irq>
 804b414:	40                   	inc    %eax
 804b415:	74 23                	je     804b43a <posix_irq_handler_im_from_sw+0x35>
		if (!posix_is_cpu_running()) { /* LCOV_EXCL_BR_LINE */
 804b417:	e8 9c f3 ff ff       	call   804a7b8 <posix_is_cpu_running>
 804b41c:	85 c0                	test   %eax,%eax
 804b41e:	75 14                	jne    804b434 <posix_irq_handler_im_from_sw+0x2f>
			/* LCOV_EXCL_START */
			posix_print_error_and_exit("programming error: %s "
 804b420:	50                   	push   %eax
 804b421:	50                   	push   %eax
 804b422:	68 2c e1 04 08       	push   $0x804e12c
 804b427:	68 fc e9 04 08       	push   $0x804e9fc
 804b42c:	e8 bd 04 00 00       	call   804b8ee <posix_print_error_and_exit>
 804b431:	83 c4 10             	add    $0x10,%esp
					__func__);
			/* LCOV_EXCL_STOP */
		}
		posix_irq_handler();
	}
}
 804b434:	c9                   	leave  
		posix_irq_handler();
 804b435:	e9 b0 fe ff ff       	jmp    804b2ea <posix_irq_handler>
}
 804b43a:	c9                   	leave  
 804b43b:	c3                   	ret    

0804b43c <posix_irq_lock>:
 * @return An architecture-dependent lock-out key representing the
 * "interrupt disable state" prior to the call.
 *
 */
unsigned int posix_irq_lock(void)
{
 804b43c:	f3 0f 1e fb          	endbr32 
 804b440:	55                   	push   %ebp
 804b441:	89 e5                	mov    %esp,%ebp
 804b443:	83 ec 14             	sub    $0x14,%esp
	return hw_irq_ctrl_change_lock(true);
 804b446:	6a 01                	push   $0x1
 804b448:	e8 22 02 00 00       	call   804b66f <hw_irq_ctrl_change_lock>
 804b44d:	83 c4 10             	add    $0x10,%esp
}
 804b450:	c9                   	leave  
 804b451:	c3                   	ret    

0804b452 <posix_irq_unlock>:
 * board_irq_lock().
 *
 * This routine can be called from either interrupt, task or fiber level.
 */
void posix_irq_unlock(unsigned int key)
{
 804b452:	f3 0f 1e fb          	endbr32 
	hw_irq_ctrl_change_lock(key);
 804b456:	e9 14 02 00 00       	jmp    804b66f <hw_irq_ctrl_change_lock>

0804b45b <posix_irq_full_unlock>:
}

void posix_irq_full_unlock(void)
{
 804b45b:	f3 0f 1e fb          	endbr32 
 804b45f:	55                   	push   %ebp
 804b460:	89 e5                	mov    %esp,%ebp
 804b462:	83 ec 14             	sub    $0x14,%esp
	hw_irq_ctrl_change_lock(false);
 804b465:	6a 00                	push   $0x0
 804b467:	e8 03 02 00 00       	call   804b66f <hw_irq_ctrl_change_lock>
 804b46c:	83 c4 10             	add    $0x10,%esp
}
 804b46f:	c9                   	leave  
 804b470:	c3                   	ret    

0804b471 <posix_irq_enable>:

void posix_irq_enable(unsigned int irq)
{
 804b471:	f3 0f 1e fb          	endbr32 
	hw_irq_ctrl_enable_irq(irq);
 804b475:	e9 cf 02 00 00       	jmp    804b749 <hw_irq_ctrl_enable_irq>

0804b47a <posix_isr_declare>:
 * @param isr_param_p ISR parameter
 * @param flags_p IRQ options
 */
void posix_isr_declare(unsigned int irq_p, int flags, void isr_p(const void *),
		       const void *isr_param_p)
{
 804b47a:	f3 0f 1e fb          	endbr32 
 804b47e:	55                   	push   %ebp
 804b47f:	89 e5                	mov    %esp,%ebp
 804b481:	8b 4d 08             	mov    0x8(%ebp),%ecx
	irq_vector_table[irq_p].irq   = irq_p;
 804b484:	89 ca                	mov    %ecx,%edx
 804b486:	c1 e2 04             	shl    $0x4,%edx
 804b489:	8d 82 80 25 05 08    	lea    0x8052580(%edx),%eax
 804b48f:	89 8a 80 25 05 08    	mov    %ecx,0x8052580(%edx)
	irq_vector_table[irq_p].func  = isr_p;
 804b495:	8b 55 10             	mov    0x10(%ebp),%edx
 804b498:	89 50 08             	mov    %edx,0x8(%eax)
	irq_vector_table[irq_p].param = isr_param_p;
 804b49b:	8b 55 14             	mov    0x14(%ebp),%edx
 804b49e:	89 50 0c             	mov    %edx,0xc(%eax)
	irq_vector_table[irq_p].flags = flags;
 804b4a1:	8b 55 0c             	mov    0xc(%ebp),%edx
 804b4a4:	89 50 04             	mov    %edx,0x4(%eax)
}
 804b4a7:	5d                   	pop    %ebp
 804b4a8:	c3                   	ret    

0804b4a9 <posix_irq_priority_set>:
 * @brief Set an interrupt's priority
 *
 * Lower values take priority over higher values.
 */
void posix_irq_priority_set(unsigned int irq, unsigned int prio, uint32_t flags)
{
 804b4a9:	f3 0f 1e fb          	endbr32 
	hw_irq_ctrl_prio_set(irq, prio);
 804b4ad:	e9 f2 00 00 00       	jmp    804b5a4 <hw_irq_ctrl_prio_set>

0804b4b2 <irq_raising_from_hw_now>:
	/*
	 * We always awake the CPU even if the IRQ was masked,
	 * but not if irqs are locked unless this is due to a
	 * PHONY_HARD_IRQ
	 */
	if ((irqs_locked == false) || (lock_ignore)) {
 804b4b2:	80 3d a1 29 05 08 00 	cmpb   $0x0,0x80529a1
 804b4b9:	74 09                	je     804b4c4 <irq_raising_from_hw_now+0x12>
 804b4bb:	80 3d a0 29 05 08 00 	cmpb   $0x0,0x80529a0
 804b4c2:	74 0c                	je     804b4d0 <irq_raising_from_hw_now+0x1e>
		lock_ignore = false;
 804b4c4:	c6 05 a0 29 05 08 00 	movb   $0x0,0x80529a0
		posix_interrupt_raised();
 804b4cb:	e9 7e f3 ff ff       	jmp    804a84e <posix_interrupt_raised>
	}
}
 804b4d0:	c3                   	ret    

0804b4d1 <hw_irq_ctrl_irq_raise_prefix>:
{
 804b4d1:	89 c1                	mov    %eax,%ecx
	if (irq < N_IRQS) {
 804b4d3:	83 f8 1f             	cmp    $0x1f,%eax
 804b4d6:	77 4e                	ja     804b526 <hw_irq_ctrl_irq_raise_prefix+0x55>
{
 804b4d8:	55                   	push   %ebp
		irq_premask |= ((uint64_t)1<<irq);
 804b4d9:	31 c0                	xor    %eax,%eax
 804b4db:	31 d2                	xor    %edx,%edx
 804b4dd:	f6 c1 20             	test   $0x20,%cl
 804b4e0:	0f 94 c0             	sete   %al
 804b4e3:	0f 95 c2             	setne  %dl
 804b4e6:	d3 e2                	shl    %cl,%edx
 804b4e8:	d3 e0                	shl    %cl,%eax
 804b4ea:	09 15 e4 28 05 08    	or     %edx,0x80528e4
{
 804b4f0:	89 e5                	mov    %esp,%ebp
 804b4f2:	56                   	push   %esi
		if (irq_mask & (1 << irq)) {
 804b4f3:	be 01 00 00 00       	mov    $0x1,%esi
 804b4f8:	d3 e6                	shl    %cl,%esi
{
 804b4fa:	53                   	push   %ebx
		if (irq_mask & (1 << irq)) {
 804b4fb:	8b 0d dc 28 05 08    	mov    0x80528dc,%ecx
 804b501:	89 f3                	mov    %esi,%ebx
 804b503:	23 35 d8 28 05 08    	and    0x80528d8,%esi
		irq_premask |= ((uint64_t)1<<irq);
 804b509:	09 05 e0 28 05 08    	or     %eax,0x80528e0
		if (irq_mask & (1 << irq)) {
 804b50f:	c1 fb 1f             	sar    $0x1f,%ebx
 804b512:	21 d9                	and    %ebx,%ecx
 804b514:	09 f1                	or     %esi,%ecx
 804b516:	74 1d                	je     804b535 <hw_irq_ctrl_irq_raise_prefix+0x64>
			irq_status |= ((uint64_t)1<<irq);
 804b518:	09 05 e8 28 05 08    	or     %eax,0x80528e8
 804b51e:	09 15 ec 28 05 08    	or     %edx,0x80528ec
 804b524:	eb 0f                	jmp    804b535 <hw_irq_ctrl_irq_raise_prefix+0x64>
	} else if (irq == PHONY_HARD_IRQ) {
 804b526:	3d ff ff 00 00       	cmp    $0xffff,%eax
 804b52b:	75 0c                	jne    804b539 <hw_irq_ctrl_irq_raise_prefix+0x68>
		lock_ignore = true;
 804b52d:	c6 05 a0 29 05 08 01 	movb   $0x1,0x80529a0
}
 804b534:	c3                   	ret    
 804b535:	5b                   	pop    %ebx
 804b536:	5e                   	pop    %esi
 804b537:	5d                   	pop    %ebp
 804b538:	c3                   	ret    
 804b539:	c3                   	ret    

0804b53a <hw_irq_ctrl_init>:
{
 804b53a:	f3 0f 1e fb          	endbr32 
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
 804b53e:	c7 05 d8 28 05 08 00 	movl   $0x0,0x80528d8
 804b545:	00 00 00 
	for (int i = 0 ; i < N_IRQS; i++) {
 804b548:	31 c0                	xor    %eax,%eax
	irq_mask = 0U; /* Let's assume all interrupts are disable at boot */
 804b54a:	c7 05 dc 28 05 08 00 	movl   $0x0,0x80528dc
 804b551:	00 00 00 
	irq_premask = 0U;
 804b554:	c7 05 e0 28 05 08 00 	movl   $0x0,0x80528e0
 804b55b:	00 00 00 
 804b55e:	c7 05 e4 28 05 08 00 	movl   $0x0,0x80528e4
 804b565:	00 00 00 
	irqs_locked = false;
 804b568:	c6 05 a1 29 05 08 00 	movb   $0x0,0x80529a1
	lock_ignore = false;
 804b56f:	c6 05 a0 29 05 08 00 	movb   $0x0,0x80529a0
		irq_prio[i] = 255U;
 804b576:	c6 80 80 27 05 08 ff 	movb   $0xff,0x8052780(%eax)
	for (int i = 0 ; i < N_IRQS; i++) {
 804b57d:	40                   	inc    %eax
 804b57e:	83 f8 20             	cmp    $0x20,%eax
 804b581:	75 f3                	jne    804b576 <hw_irq_ctrl_init+0x3c>
}
 804b583:	c3                   	ret    

0804b584 <hw_irq_ctrl_cleanup>:
{
 804b584:	f3 0f 1e fb          	endbr32 
}
 804b588:	c3                   	ret    

0804b589 <hw_irq_ctrl_set_cur_prio>:
{
 804b589:	f3 0f 1e fb          	endbr32 
 804b58d:	55                   	push   %ebp
 804b58e:	89 e5                	mov    %esp,%ebp
	currently_running_prio = new;
 804b590:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804b593:	5d                   	pop    %ebp
	currently_running_prio = new;
 804b594:	a3 7c 12 05 08       	mov    %eax,0x805127c
}
 804b599:	c3                   	ret    

0804b59a <hw_irq_ctrl_get_cur_prio>:
{
 804b59a:	f3 0f 1e fb          	endbr32 
}
 804b59e:	a1 7c 12 05 08       	mov    0x805127c,%eax
 804b5a3:	c3                   	ret    

0804b5a4 <hw_irq_ctrl_prio_set>:
{
 804b5a4:	f3 0f 1e fb          	endbr32 
 804b5a8:	55                   	push   %ebp
 804b5a9:	89 e5                	mov    %esp,%ebp
	irq_prio[irq] = prio;
 804b5ab:	8b 45 08             	mov    0x8(%ebp),%eax
 804b5ae:	8b 55 0c             	mov    0xc(%ebp),%edx
}
 804b5b1:	5d                   	pop    %ebp
	irq_prio[irq] = prio;
 804b5b2:	88 90 80 27 05 08    	mov    %dl,0x8052780(%eax)
}
 804b5b8:	c3                   	ret    

0804b5b9 <hw_irq_ctrl_get_prio>:
{
 804b5b9:	f3 0f 1e fb          	endbr32 
 804b5bd:	55                   	push   %ebp
 804b5be:	89 e5                	mov    %esp,%ebp
	return irq_prio[irq];
 804b5c0:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804b5c3:	5d                   	pop    %ebp
	return irq_prio[irq];
 804b5c4:	8a 80 80 27 05 08    	mov    0x8052780(%eax),%al
}
 804b5ca:	c3                   	ret    

0804b5cb <hw_irq_ctrl_get_highest_prio_irq>:
{
 804b5cb:	f3 0f 1e fb          	endbr32 
		return -1;
 804b5cf:	83 ca ff             	or     $0xffffffff,%edx
	if (irqs_locked) {
 804b5d2:	80 3d a1 29 05 08 00 	cmpb   $0x0,0x80529a1
 804b5d9:	0f 85 81 00 00 00    	jne    804b660 <hw_irq_ctrl_get_highest_prio_irq+0x95>
{
 804b5df:	55                   	push   %ebp
 804b5e0:	89 e5                	mov    %esp,%ebp
 804b5e2:	57                   	push   %edi
 804b5e3:	56                   	push   %esi
 804b5e4:	53                   	push   %ebx
	int winner_prio = 256;
 804b5e5:	bb 00 01 00 00       	mov    $0x100,%ebx
{
 804b5ea:	83 ec 14             	sub    $0x14,%esp
	return irq_status;
 804b5ed:	8b 3d ec 28 05 08    	mov    0x80528ec,%edi
 804b5f3:	a1 e8 28 05 08       	mov    0x80528e8,%eax
 804b5f8:	89 7d e8             	mov    %edi,-0x18(%ebp)
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
 804b5fb:	8b 3d 7c 12 05 08    	mov    0x805127c,%edi
 804b601:	89 7d ec             	mov    %edi,-0x14(%ebp)
	while (irq_status != 0U) {
 804b604:	8b 4d e8             	mov    -0x18(%ebp),%ecx
 804b607:	09 c1                	or     %eax,%ecx
 804b609:	74 4b                	je     804b656 <hw_irq_ctrl_get_highest_prio_irq+0x8b>
 */

static ALWAYS_INLINE unsigned int find_lsb_set(uint32_t op)
{
#ifdef CONFIG_TOOLCHAIN_HAS_BUILTIN_FFS
	return __builtin_ffs(op);
 804b60b:	0f bc c8             	bsf    %eax,%ecx
		int irq_nbr = find_lsb_set(irq_status) - 1;
 804b60e:	bf ff ff ff ff       	mov    $0xffffffff,%edi
		irq_status &= ~((uint64_t) 1 << irq_nbr);
 804b613:	be 01 00 00 00       	mov    $0x1,%esi
		int irq_nbr = find_lsb_set(irq_status) - 1;
 804b618:	0f 44 cf             	cmove  %edi,%ecx
		irq_status &= ~((uint64_t) 1 << irq_nbr);
 804b61b:	31 ff                	xor    %edi,%edi
 804b61d:	0f a5 f7             	shld   %cl,%esi,%edi
 804b620:	d3 e6                	shl    %cl,%esi
 804b622:	f6 c1 20             	test   $0x20,%cl
 804b625:	74 04                	je     804b62b <hw_irq_ctrl_get_highest_prio_irq+0x60>
 804b627:	89 f7                	mov    %esi,%edi
 804b629:	31 f6                	xor    %esi,%esi
 804b62b:	89 75 e0             	mov    %esi,-0x20(%ebp)
 804b62e:	8b 75 e0             	mov    -0x20(%ebp),%esi
 804b631:	89 7d e4             	mov    %edi,-0x1c(%ebp)
 804b634:	8b 7d e4             	mov    -0x1c(%ebp),%edi
 804b637:	f7 d6                	not    %esi
 804b639:	21 f0                	and    %esi,%eax
		if ((winner_prio > (int)irq_prio[irq_nbr])
 804b63b:	0f b6 b1 80 27 05 08 	movzbl 0x8052780(%ecx),%esi
		irq_status &= ~((uint64_t) 1 << irq_nbr);
 804b642:	f7 d7                	not    %edi
 804b644:	21 7d e8             	and    %edi,-0x18(%ebp)
		if ((winner_prio > (int)irq_prio[irq_nbr])
 804b647:	39 de                	cmp    %ebx,%esi
 804b649:	7d b9                	jge    804b604 <hw_irq_ctrl_get_highest_prio_irq+0x39>
		   && (currently_running_prio > (int)irq_prio[irq_nbr])) {
 804b64b:	3b 75 ec             	cmp    -0x14(%ebp),%esi
 804b64e:	0f 4c de             	cmovl  %esi,%ebx
 804b651:	0f 4c d1             	cmovl  %ecx,%edx
 804b654:	eb ae                	jmp    804b604 <hw_irq_ctrl_get_highest_prio_irq+0x39>
}
 804b656:	83 c4 14             	add    $0x14,%esp
 804b659:	89 d0                	mov    %edx,%eax
 804b65b:	5b                   	pop    %ebx
 804b65c:	5e                   	pop    %esi
 804b65d:	5f                   	pop    %edi
 804b65e:	5d                   	pop    %ebp
 804b65f:	c3                   	ret    
 804b660:	89 d0                	mov    %edx,%eax
 804b662:	c3                   	ret    

0804b663 <hw_irq_ctrl_get_current_lock>:
{
 804b663:	f3 0f 1e fb          	endbr32 
	return irqs_locked;
 804b667:	0f b6 05 a1 29 05 08 	movzbl 0x80529a1,%eax
}
 804b66e:	c3                   	ret    

0804b66f <hw_irq_ctrl_change_lock>:
{
 804b66f:	f3 0f 1e fb          	endbr32 
 804b673:	55                   	push   %ebp
 804b674:	89 e5                	mov    %esp,%ebp
 804b676:	53                   	push   %ebx
 804b677:	51                   	push   %ecx
 804b678:	8b 55 08             	mov    0x8(%ebp),%edx
	uint32_t previous_lock = irqs_locked;
 804b67b:	0f b6 1d a1 29 05 08 	movzbl 0x80529a1,%ebx
	irqs_locked = new_lock;
 804b682:	85 d2                	test   %edx,%edx
 804b684:	0f 95 05 a1 29 05 08 	setne  0x80529a1
	if ((previous_lock == true) && (new_lock == false)) {
 804b68b:	75 16                	jne    804b6a3 <hw_irq_ctrl_change_lock+0x34>
 804b68d:	84 db                	test   %bl,%bl
 804b68f:	74 12                	je     804b6a3 <hw_irq_ctrl_change_lock+0x34>
		if (irq_status != 0U) {
 804b691:	a1 ec 28 05 08       	mov    0x80528ec,%eax
 804b696:	0b 05 e8 28 05 08    	or     0x80528e8,%eax
 804b69c:	74 05                	je     804b6a3 <hw_irq_ctrl_change_lock+0x34>
			posix_irq_handler_im_from_sw();
 804b69e:	e8 62 fd ff ff       	call   804b405 <posix_irq_handler_im_from_sw>
}
 804b6a3:	89 d8                	mov    %ebx,%eax
 804b6a5:	5a                   	pop    %edx
 804b6a6:	5b                   	pop    %ebx
 804b6a7:	5d                   	pop    %ebp
 804b6a8:	c3                   	ret    

0804b6a9 <hw_irq_ctrl_clear_irq>:
{
 804b6a9:	f3 0f 1e fb          	endbr32 
 804b6ad:	55                   	push   %ebp
 804b6ae:	89 e5                	mov    %esp,%ebp
 804b6b0:	57                   	push   %edi
	irq_status  &= ~((uint64_t)1<<irq);
 804b6b1:	8b 4d 08             	mov    0x8(%ebp),%ecx
{
 804b6b4:	56                   	push   %esi
	irq_status  &= ~((uint64_t)1<<irq);
 804b6b5:	89 cf                	mov    %ecx,%edi
 804b6b7:	c1 ef 05             	shr    $0x5,%edi
 804b6ba:	83 e7 01             	and    $0x1,%edi
 804b6bd:	89 fe                	mov    %edi,%esi
 804b6bf:	d3 e7                	shl    %cl,%edi
 804b6c1:	83 f6 01             	xor    $0x1,%esi
 804b6c4:	89 f8                	mov    %edi,%eax
 804b6c6:	d3 e6                	shl    %cl,%esi
 804b6c8:	f7 d0                	not    %eax
 804b6ca:	21 05 ec 28 05 08    	and    %eax,0x80528ec
 804b6d0:	89 f2                	mov    %esi,%edx
	irq_premask &= ~((uint64_t)1<<irq);
 804b6d2:	21 05 e4 28 05 08    	and    %eax,0x80528e4
}
 804b6d8:	5e                   	pop    %esi
	irq_status  &= ~((uint64_t)1<<irq);
 804b6d9:	f7 d2                	not    %edx
}
 804b6db:	5f                   	pop    %edi
	irq_status  &= ~((uint64_t)1<<irq);
 804b6dc:	21 15 e8 28 05 08    	and    %edx,0x80528e8
	irq_premask &= ~((uint64_t)1<<irq);
 804b6e2:	21 15 e0 28 05 08    	and    %edx,0x80528e0
}
 804b6e8:	5d                   	pop    %ebp
 804b6e9:	c3                   	ret    

0804b6ea <hw_irq_ctrl_set_irq>:
{
 804b6ea:	f3 0f 1e fb          	endbr32 
 804b6ee:	55                   	push   %ebp
 804b6ef:	89 e5                	mov    %esp,%ebp
 804b6f1:	83 ec 08             	sub    $0x8,%esp
	hw_irq_ctrl_irq_raise_prefix(irq);
 804b6f4:	8b 45 08             	mov    0x8(%ebp),%eax
 804b6f7:	e8 d5 fd ff ff       	call   804b4d1 <hw_irq_ctrl_irq_raise_prefix>
	if ((irqs_locked == false) || (lock_ignore)) {
 804b6fc:	80 3d a1 29 05 08 00 	cmpb   $0x0,0x80529a1
 804b703:	74 09                	je     804b70e <hw_irq_ctrl_set_irq+0x24>
 804b705:	80 3d a0 29 05 08 00 	cmpb   $0x0,0x80529a0
 804b70c:	74 16                	je     804b724 <hw_irq_ctrl_set_irq+0x3a>
		irq_ctrl_timer = hwm_get_time();
 804b70e:	e8 56 f5 ff ff       	call   804ac69 <hwm_get_time>
 804b713:	a3 68 12 05 08       	mov    %eax,0x8051268
 804b718:	89 15 6c 12 05 08    	mov    %edx,0x805126c
}
 804b71e:	c9                   	leave  
		hwm_find_next_timer();
 804b71f:	e9 b6 f3 ff ff       	jmp    804aada <hwm_find_next_timer>
}
 804b724:	c9                   	leave  
 804b725:	c3                   	ret    

0804b726 <hw_irq_ctrl_raise_im_from_sw>:
 * Like hw_irq_ctrl_raise_im() but for SW threads
 *
 * Call only from SW threads
 */
void hw_irq_ctrl_raise_im_from_sw(unsigned int irq)
{
 804b726:	f3 0f 1e fb          	endbr32 
 804b72a:	55                   	push   %ebp
 804b72b:	89 e5                	mov    %esp,%ebp
 804b72d:	83 ec 08             	sub    $0x8,%esp
	hw_irq_ctrl_irq_raise_prefix(irq);
 804b730:	8b 45 08             	mov    0x8(%ebp),%eax
 804b733:	e8 99 fd ff ff       	call   804b4d1 <hw_irq_ctrl_irq_raise_prefix>

	if (irqs_locked == false) {
 804b738:	80 3d a1 29 05 08 00 	cmpb   $0x0,0x80529a1
 804b73f:	75 06                	jne    804b747 <hw_irq_ctrl_raise_im_from_sw+0x21>
		posix_irq_handler_im_from_sw();
	}
}
 804b741:	c9                   	leave  
		posix_irq_handler_im_from_sw();
 804b742:	e9 be fc ff ff       	jmp    804b405 <posix_irq_handler_im_from_sw>
}
 804b747:	c9                   	leave  
 804b748:	c3                   	ret    

0804b749 <hw_irq_ctrl_enable_irq>:
{
 804b749:	f3 0f 1e fb          	endbr32 
 804b74d:	55                   	push   %ebp
	irq_mask |= ((uint64_t)1<<irq);
 804b74e:	31 c0                	xor    %eax,%eax
 804b750:	31 d2                	xor    %edx,%edx
{
 804b752:	89 e5                	mov    %esp,%ebp
 804b754:	8b 4d 08             	mov    0x8(%ebp),%ecx
	irq_mask |= ((uint64_t)1<<irq);
 804b757:	f6 c1 20             	test   $0x20,%cl
 804b75a:	0f 94 c0             	sete   %al
 804b75d:	0f 95 c2             	setne  %dl
 804b760:	d3 e2                	shl    %cl,%edx
 804b762:	d3 e0                	shl    %cl,%eax
 804b764:	09 15 dc 28 05 08    	or     %edx,0x80528dc
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
 804b76a:	8b 15 e4 28 05 08    	mov    0x80528e4,%edx
	irq_mask |= ((uint64_t)1<<irq);
 804b770:	09 05 d8 28 05 08    	or     %eax,0x80528d8
	if (irq_premask & ((uint64_t)1<<irq)) { /* if IRQ is pending */
 804b776:	a1 e0 28 05 08       	mov    0x80528e0,%eax
 804b77b:	0f ad d0             	shrd   %cl,%edx,%eax
 804b77e:	d3 ea                	shr    %cl,%edx
 804b780:	f6 c1 20             	test   $0x20,%cl
 804b783:	74 02                	je     804b787 <hw_irq_ctrl_enable_irq+0x3e>
 804b785:	89 d0                	mov    %edx,%eax
 804b787:	83 e0 01             	and    $0x1,%eax
 804b78a:	74 06                	je     804b792 <hw_irq_ctrl_enable_irq+0x49>
}
 804b78c:	5d                   	pop    %ebp
		hw_irq_ctrl_raise_im_from_sw(irq);
 804b78d:	e9 94 ff ff ff       	jmp    804b726 <hw_irq_ctrl_raise_im_from_sw>
}
 804b792:	5d                   	pop    %ebp
 804b793:	c3                   	ret    

0804b794 <hw_irq_ctrl_timer_triggered>:

void hw_irq_ctrl_timer_triggered(void)
{
 804b794:	f3 0f 1e fb          	endbr32 
	irq_ctrl_timer = NEVER;
 804b798:	c7 05 68 12 05 08 ff 	movl   $0xffffffff,0x8051268
 804b79f:	ff ff ff 
 804b7a2:	c7 05 6c 12 05 08 ff 	movl   $0xffffffff,0x805126c
 804b7a9:	ff ff ff 
	irq_raising_from_hw_now();
 804b7ac:	e9 01 fd ff ff       	jmp    804b4b2 <irq_raising_from_hw_now>

0804b7b1 <posix_exit>:
#include <stdlib.h>
#include <zephyr/sys/util.h>
#include "cmdline.h"

void posix_exit(int exit_code)
{
 804b7b1:	f3 0f 1e fb          	endbr32 
 804b7b5:	55                   	push   %ebp
 804b7b6:	89 e5                	mov    %esp,%ebp
 804b7b8:	83 ec 08             	sub    $0x8,%esp
 804b7bb:	8b 45 08             	mov    0x8(%ebp),%eax
	static int max_exit_code;

	max_exit_code = MAX(exit_code, max_exit_code);
 804b7be:	39 05 70 29 05 08    	cmp    %eax,0x8052970
 804b7c4:	0f 4d 05 70 29 05 08 	cmovge 0x8052970,%eax
 804b7cb:	a3 70 29 05 08       	mov    %eax,0x8052970
	/*
	 * posix_soc_clean_up may not return if this is called from a SW thread,
	 * but instead it would get posix_exit() recalled again
	 * ASAP from the HW thread
	 */
	posix_soc_clean_up();
 804b7d0:	e8 a0 f1 ff ff       	call   804a975 <posix_soc_clean_up>
	hwm_cleanup();
 804b7d5:	e8 c3 f4 ff ff       	call   804ac9d <hwm_cleanup>
	native_cleanup_cmd_line();
 804b7da:	e8 75 08 00 00       	call   804c054 <native_cleanup_cmd_line>
	exit(max_exit_code);
 804b7df:	83 ec 0c             	sub    $0xc,%esp
 804b7e2:	ff 35 70 29 05 08    	pushl  0x8052970
 804b7e8:	e8 e3 db ff ff       	call   80493d0 <exit@plt>

0804b7ed <main>:
/**
 * This is the actual main for the Linux process,
 * the Zephyr application main is renamed something else thru a define.
 */
int main(int argc, char *argv[])
{
 804b7ed:	f3 0f 1e fb          	endbr32 
 804b7f1:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 804b7f5:	83 e4 f0             	and    $0xfffffff0,%esp
 804b7f8:	ff 71 fc             	pushl  -0x4(%ecx)
 804b7fb:	55                   	push   %ebp
 804b7fc:	89 e5                	mov    %esp,%ebp
 804b7fe:	56                   	push   %esi
 804b7ff:	53                   	push   %ebx
 804b800:	51                   	push   %ecx
 804b801:	83 ec 18             	sub    $0x18,%esp
 804b804:	8b 71 04             	mov    0x4(%ecx),%esi
 804b807:	8b 19                	mov    (%ecx),%ebx
	run_native_tasks(_NATIVE_PRE_BOOT_1_LEVEL);
 804b809:	6a 00                	push   $0x0
 804b80b:	e8 38 f1 ff ff       	call   804a948 <run_native_tasks>
 804b810:	58                   	pop    %eax
 804b811:	5a                   	pop    %edx

	native_handle_cmd_line(argc, argv);
 804b812:	56                   	push   %esi
 804b813:	53                   	push   %ebx
 804b814:	e8 1a 09 00 00       	call   804c133 <native_handle_cmd_line>

	run_native_tasks(_NATIVE_PRE_BOOT_2_LEVEL);
 804b819:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804b820:	e8 23 f1 ff ff       	call   804a948 <run_native_tasks>
 804b825:	83 c4 10             	add    $0x10,%esp

	hwm_init();
 804b828:	e8 4c f4 ff ff       	call   804ac79 <hwm_init>

	run_native_tasks(_NATIVE_PRE_BOOT_3_LEVEL);
 804b82d:	83 ec 0c             	sub    $0xc,%esp
 804b830:	6a 02                	push   $0x2
 804b832:	e8 11 f1 ff ff       	call   804a948 <run_native_tasks>
 804b837:	83 c4 10             	add    $0x10,%esp

	posix_boot_cpu();
 804b83a:	e8 55 f0 ff ff       	call   804a894 <posix_boot_cpu>

	run_native_tasks(_NATIVE_FIRST_SLEEP_LEVEL);
 804b83f:	83 ec 0c             	sub    $0xc,%esp
 804b842:	6a 03                	push   $0x3
 804b844:	e8 ff f0 ff ff       	call   804a948 <run_native_tasks>
 804b849:	83 c4 10             	add    $0x10,%esp

	hwm_main_loop();
 804b84c:	e8 0e f3 ff ff       	call   804ab5f <hwm_main_loop>

	/* This line should be unreachable */
	return 1; /* LCOV_EXCL_LINE */
}
 804b851:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804b854:	b8 01 00 00 00       	mov    $0x1,%eax
 804b859:	59                   	pop    %ecx
 804b85a:	5b                   	pop    %ebx
 804b85b:	5e                   	pop    %esi
 804b85c:	5d                   	pop    %ebp
 804b85d:	8d 61 fc             	lea    -0x4(%ecx),%esp
 804b860:	c3                   	ret    

0804b861 <trace_disable_color>:
 * Indexed 0:stdout, 1:stderr
 */
static int is_a_tty[2] = {-1, -1};

void trace_disable_color(char *argv, int offset)
{
 804b861:	f3 0f 1e fb          	endbr32 
	is_a_tty[0] = 0;
 804b865:	c7 05 80 12 05 08 00 	movl   $0x0,0x8051280
 804b86c:	00 00 00 
	is_a_tty[1] = 0;
 804b86f:	c7 05 84 12 05 08 00 	movl   $0x0,0x8051284
 804b876:	00 00 00 
}
 804b879:	c3                   	ret    

0804b87a <trace_enable_color>:

void trace_enable_color(char *argv, int offset)
{
 804b87a:	f3 0f 1e fb          	endbr32 
	is_a_tty[0] = -1;
 804b87e:	c7 05 80 12 05 08 ff 	movl   $0xffffffff,0x8051280
 804b885:	ff ff ff 
	is_a_tty[1] = -1;
 804b888:	c7 05 84 12 05 08 ff 	movl   $0xffffffff,0x8051284
 804b88f:	ff ff ff 

}
 804b892:	c3                   	ret    

0804b893 <trace_force_color>:

void trace_force_color(char *argv, int offset)
{
 804b893:	f3 0f 1e fb          	endbr32 
	is_a_tty[0] = 1;
 804b897:	c7 05 80 12 05 08 01 	movl   $0x1,0x8051280
 804b89e:	00 00 00 
	is_a_tty[1] = 1;
 804b8a1:	c7 05 84 12 05 08 01 	movl   $0x1,0x8051284
 804b8a8:	00 00 00 
}
 804b8ab:	c3                   	ret    

0804b8ac <decide_about_color>:
{
	return is_a_tty[file_number];
}

static void decide_about_color(void)
{
 804b8ac:	f3 0f 1e fb          	endbr32 
 804b8b0:	55                   	push   %ebp
 804b8b1:	89 e5                	mov    %esp,%ebp
 804b8b3:	83 ec 08             	sub    $0x8,%esp
	if (is_a_tty[0] == -1) {
 804b8b6:	83 3d 80 12 05 08 ff 	cmpl   $0xffffffff,0x8051280
 804b8bd:	75 12                	jne    804b8d1 <decide_about_color+0x25>
		is_a_tty[0] = isatty(STDOUT_FILENO);
 804b8bf:	83 ec 0c             	sub    $0xc,%esp
 804b8c2:	6a 01                	push   $0x1
 804b8c4:	e8 57 dc ff ff       	call   8049520 <isatty@plt>
 804b8c9:	83 c4 10             	add    $0x10,%esp
 804b8cc:	a3 80 12 05 08       	mov    %eax,0x8051280
	}
	if (is_a_tty[1] == -1) {
 804b8d1:	83 3d 84 12 05 08 ff 	cmpl   $0xffffffff,0x8051284
 804b8d8:	75 12                	jne    804b8ec <decide_about_color+0x40>
		is_a_tty[1] = isatty(STDERR_FILENO);
 804b8da:	83 ec 0c             	sub    $0xc,%esp
 804b8dd:	6a 02                	push   $0x2
 804b8df:	e8 3c dc ff ff       	call   8049520 <isatty@plt>
 804b8e4:	83 c4 10             	add    $0x10,%esp
 804b8e7:	a3 84 12 05 08       	mov    %eax,0x8051284
	}
}
 804b8ec:	c9                   	leave  
 804b8ed:	c3                   	ret    

0804b8ee <posix_print_error_and_exit>:
{
 804b8ee:	f3 0f 1e fb          	endbr32 
 804b8f2:	55                   	push   %ebp
 804b8f3:	89 e5                	mov    %esp,%ebp
 804b8f5:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
 804b8f8:	8d 45 0c             	lea    0xc(%ebp),%eax

__fortify_function int
vfprintf (FILE *__restrict __stream,
	  const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt, __ap);
 804b8fb:	50                   	push   %eax
 804b8fc:	ff 75 08             	pushl  0x8(%ebp)
 804b8ff:	6a 01                	push   $0x1
 804b901:	ff 35 00 24 05 08    	pushl  0x8052400
 804b907:	e8 04 da ff ff       	call   8049310 <__vfprintf_chk@plt>
	posix_exit(1);
 804b90c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804b913:	e8 99 fe ff ff       	call   804b7b1 <posix_exit>
 804b918:	83 c4 10             	add    $0x10,%esp
}
 804b91b:	c9                   	leave  
 804b91c:	c3                   	ret    

0804b91d <posix_print_warning>:
{
 804b91d:	f3 0f 1e fb          	endbr32 
 804b921:	55                   	push   %ebp
 804b922:	89 e5                	mov    %esp,%ebp
 804b924:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
 804b927:	8d 45 0c             	lea    0xc(%ebp),%eax
 804b92a:	50                   	push   %eax
 804b92b:	ff 75 08             	pushl  0x8(%ebp)
 804b92e:	6a 01                	push   $0x1
 804b930:	ff 35 00 24 05 08    	pushl  0x8052400
 804b936:	e8 d5 d9 ff ff       	call   8049310 <__vfprintf_chk@plt>
 804b93b:	83 c4 10             	add    $0x10,%esp
}
 804b93e:	c9                   	leave  
 804b93f:	c3                   	ret    

0804b940 <posix_print_trace>:
{
 804b940:	f3 0f 1e fb          	endbr32 
 804b944:	55                   	push   %ebp
 804b945:	89 e5                	mov    %esp,%ebp
 804b947:	83 ec 08             	sub    $0x8,%esp
	va_start(variable_args, format);
 804b94a:	8d 45 0c             	lea    0xc(%ebp),%eax
 804b94d:	50                   	push   %eax
 804b94e:	ff 75 08             	pushl  0x8(%ebp)
 804b951:	6a 01                	push   $0x1
 804b953:	ff 35 04 24 05 08    	pushl  0x8052404
 804b959:	e8 b2 d9 ff ff       	call   8049310 <__vfprintf_chk@plt>
 804b95e:	83 c4 10             	add    $0x10,%esp
}
 804b961:	c9                   	leave  
 804b962:	c3                   	ret    

0804b963 <native_add_tracing_options>:

NATIVE_TASK(decide_about_color, PRE_BOOT_2, 0);

void native_add_tracing_options(void)
{
 804b963:	f3 0f 1e fb          	endbr32 
 804b967:	55                   	push   %ebp
 804b968:	89 e5                	mov    %esp,%ebp
 804b96a:	83 ec 14             	sub    $0x14,%esp
		"force-color", "force-color", 'b',
		NULL, trace_force_color,
		"Enable color in traces even if printing to files/pipes"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(trace_options);
 804b96d:	68 a0 11 05 08       	push   $0x80511a0
 804b972:	e8 06 07 00 00       	call   804c07d <native_add_command_line_opts>
 804b977:	83 c4 10             	add    $0x10,%esp
}
 804b97a:	c9                   	leave  
 804b97b:	c3                   	ret    

0804b97c <cmd_gen_switch_syntax.constprop.0>:
 * should be used
 *
 * The string is saved in <buf> which has been allocated <size> bytes by the
 * caller
 */
static void cmd_gen_switch_syntax(char *buf, int size,
 804b97c:	55                   	push   %ebp
 804b97d:	89 e5                	mov    %esp,%ebp
 804b97f:	57                   	push   %edi
 804b980:	89 d7                	mov    %edx,%edi
 804b982:	56                   	push   %esi
 804b983:	be 46 00 00 00       	mov    $0x46,%esi
 804b988:	53                   	push   %ebx
 804b989:	89 c3                	mov    %eax,%ebx
 804b98b:	83 ec 1c             	sub    $0x1c,%esp

	if (size <= 0) {
		return;
	}

	if (args_s_el->is_mandatory == false) {
 804b98e:	80 7a 01 00          	cmpb   $0x0,0x1(%edx)
 804b992:	75 09                	jne    804b99d <cmd_gen_switch_syntax.constprop.0+0x21>
		*buf++ = '[';
 804b994:	c6 00 5b             	movb   $0x5b,(%eax)
 804b997:	43                   	inc    %ebx
		size--;
 804b998:	be 45 00 00 00       	mov    $0x45,%esi
	}

	if (args_s_el->is_switch == true) {
 804b99d:	80 7f 02 00          	cmpb   $0x0,0x2(%edi)
 804b9a1:	8b 47 04             	mov    0x4(%edi),%eax
 804b9a4:	74 0a                	je     804b9b0 <cmd_gen_switch_syntax.constprop.0+0x34>
  return __builtin___snprintf_chk (__s, __n, __USE_FORTIFY_LEVEL - 1,
 804b9a6:	52                   	push   %edx
 804b9a7:	52                   	push   %edx
 804b9a8:	50                   	push   %eax
 804b9a9:	68 e9 ea 04 08       	push   $0x804eae9
 804b9ae:	eb 1b                	jmp    804b9cb <cmd_gen_switch_syntax.constprop.0+0x4f>
		ret = snprintf(buf, size, "-%s", args_s_el->option);
	} else {
		if (args_s_el->type != 'l') {
 804b9b0:	80 7f 0c 6c          	cmpb   $0x6c,0xc(%edi)
 804b9b4:	8b 57 08             	mov    0x8(%edi),%edx
 804b9b7:	74 0a                	je     804b9c3 <cmd_gen_switch_syntax.constprop.0+0x47>
 804b9b9:	51                   	push   %ecx
 804b9ba:	52                   	push   %edx
 804b9bb:	50                   	push   %eax
 804b9bc:	68 ed ea 04 08       	push   $0x804eaed
 804b9c1:	eb 08                	jmp    804b9cb <cmd_gen_switch_syntax.constprop.0+0x4f>
 804b9c3:	51                   	push   %ecx
 804b9c4:	52                   	push   %edx
 804b9c5:	50                   	push   %eax
 804b9c6:	68 f6 ea 04 08       	push   $0x804eaf6
 804b9cb:	6a ff                	push   $0xffffffff
 804b9cd:	6a 01                	push   $0x1
 804b9cf:	56                   	push   %esi
 804b9d0:	53                   	push   %ebx
 804b9d1:	e8 0a d9 ff ff       	call   80492e0 <__snprintf_chk@plt>
 804b9d6:	83 c4 20             	add    $0x20,%esp
			ret = snprintf(buf, size, "-%s <%s>...",
					args_s_el->option, args_s_el->name);
		}
	}

	if (ret < 0) {
 804b9d9:	85 c0                	test   %eax,%eax
 804b9db:	79 1e                	jns    804b9fb <cmd_gen_switch_syntax.constprop.0+0x7f>
 804b9dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		posix_print_error_and_exit("Unexpected error in %s %i\n",
 804b9e0:	50                   	push   %eax
 804b9e1:	68 07 01 00 00       	push   $0x107
 804b9e6:	68 02 eb 04 08       	push   $0x804eb02
 804b9eb:	68 40 eb 04 08       	push   $0x804eb40
 804b9f0:	e8 f9 fe ff ff       	call   804b8ee <posix_print_error_and_exit>
 804b9f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804b9f8:	83 c4 10             	add    $0x10,%esp
					   __FILE__, __LINE__);
	}
	if (size - ret < 0) {
 804b9fb:	29 c6                	sub    %eax,%esi
 804b9fd:	78 20                	js     804ba1f <cmd_gen_switch_syntax.constprop.0+0xa3>
		 * If we run out of space we can just stop,
		 * this is not critical
		 */
		return;
	}
	buf += ret;
 804b9ff:	01 d8                	add    %ebx,%eax
	size -= ret;

	if (args_s_el->is_mandatory == false) {
 804ba01:	80 7f 01 00          	cmpb   $0x0,0x1(%edi)
 804ba05:	75 08                	jne    804ba0f <cmd_gen_switch_syntax.constprop.0+0x93>
 804ba07:	51                   	push   %ecx
 804ba08:	68 5b eb 04 08       	push   $0x804eb5b
 804ba0d:	eb 06                	jmp    804ba15 <cmd_gen_switch_syntax.constprop.0+0x99>
 804ba0f:	52                   	push   %edx
 804ba10:	68 5c eb 04 08       	push   $0x804eb5c
 804ba15:	56                   	push   %esi
 804ba16:	50                   	push   %eax
 804ba17:	e8 14 da ff ff       	call   8049430 <snprintf@plt>
 804ba1c:	83 c4 10             	add    $0x10,%esp
		snprintf(buf, size, "] ");
	} else {
		snprintf(buf, size, " ");
	}
}
 804ba1f:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804ba22:	5b                   	pop    %ebx
 804ba23:	5e                   	pop    %esi
 804ba24:	5f                   	pop    %edi
 804ba25:	5d                   	pop    %ebp
 804ba26:	c3                   	ret    

0804ba27 <cmd_is_option>:
{
 804ba27:	f3 0f 1e fb          	endbr32 
 804ba2b:	55                   	push   %ebp
 804ba2c:	89 e5                	mov    %esp,%ebp
 804ba2e:	57                   	push   %edi
 804ba2f:	56                   	push   %esi
 804ba30:	53                   	push   %ebx
 804ba31:	83 ec 0c             	sub    $0xc,%esp
	if (arg[of] == '-') {
 804ba34:	8b 45 08             	mov    0x8(%ebp),%eax
{
 804ba37:	8b 7d 0c             	mov    0xc(%ebp),%edi
 804ba3a:	8b 5d 10             	mov    0x10(%ebp),%ebx
	if (arg[of] == '-') {
 804ba3d:	80 38 2d             	cmpb   $0x2d,(%eax)
	int of = 0;
 804ba40:	0f 94 c0             	sete   %al
 804ba43:	0f b6 c0             	movzbl %al,%eax
 804ba46:	89 c6                	mov    %eax,%esi
	if (arg[of] == '-') {
 804ba48:	8b 45 08             	mov    0x8(%ebp),%eax
 804ba4b:	80 3c 30 2d          	cmpb   $0x2d,(%eax,%esi,1)
 804ba4f:	75 01                	jne    804ba52 <cmd_is_option+0x2b>
		of++;
 804ba51:	46                   	inc    %esi
	if (!with_value) {
 804ba52:	85 db                	test   %ebx,%ebx
 804ba54:	75 24                	jne    804ba7a <cmd_is_option+0x53>
		if (strcmp(&arg[of], option) != 0) {
 804ba56:	52                   	push   %edx
 804ba57:	52                   	push   %edx
 804ba58:	8b 55 08             	mov    0x8(%ebp),%edx
 804ba5b:	57                   	push   %edi
 804ba5c:	01 f2                	add    %esi,%edx
 804ba5e:	52                   	push   %edx
 804ba5f:	e8 9c d8 ff ff       	call   8049300 <strcmp@plt>
 804ba64:	83 c4 10             	add    $0x10,%esp
 804ba67:	85 c0                	test   %eax,%eax
 804ba69:	75 57                	jne    804bac2 <cmd_is_option+0x9b>
	size_t to_match_len = strlen(option);
 804ba6b:	83 c9 ff             	or     $0xffffffff,%ecx
 804ba6e:	f2 ae                	repnz scas %es:(%edi),%al
 804ba70:	89 cf                	mov    %ecx,%edi
 804ba72:	f7 d7                	not    %edi
			return of + to_match_len;
 804ba74:	8d 5c 3e ff          	lea    -0x1(%esi,%edi,1),%ebx
 804ba78:	eb 48                	jmp    804bac2 <cmd_is_option+0x9b>
 804ba7a:	89 f3                	mov    %esi,%ebx
 804ba7c:	29 f7                	sub    %esi,%edi
	while (!(arg[of] == 0 && *option == 0)) {
 804ba7e:	8b 45 08             	mov    0x8(%ebp),%eax
 804ba81:	8a 0c 1f             	mov    (%edi,%ebx,1),%cl
 804ba84:	8a 04 18             	mov    (%eax,%ebx,1),%al
 804ba87:	89 c2                	mov    %eax,%edx
 804ba89:	08 ca                	or     %cl,%dl
 804ba8b:	74 1f                	je     804baac <cmd_is_option+0x85>
		if (*option == 0) {
 804ba8d:	84 c9                	test   %cl,%cl
 804ba8f:	75 14                	jne    804baa5 <cmd_is_option+0x7e>
			if ((arg[of] == ':') || (arg[of] == '=')) {
 804ba91:	3c 3a                	cmp    $0x3a,%al
 804ba93:	74 04                	je     804ba99 <cmd_is_option+0x72>
 804ba95:	3c 3d                	cmp    $0x3d,%al
 804ba97:	75 27                	jne    804bac0 <cmd_is_option+0x99>
	if (arg[of] == 0) { /* we need a value to follow */
 804ba99:	8b 45 08             	mov    0x8(%ebp),%eax
				of++;
 804ba9c:	43                   	inc    %ebx
	if (arg[of] == 0) { /* we need a value to follow */
 804ba9d:	80 3c 18 00          	cmpb   $0x0,(%eax,%ebx,1)
 804baa1:	75 1f                	jne    804bac2 <cmd_is_option+0x9b>
 804baa3:	eb 07                	jmp    804baac <cmd_is_option+0x85>
		if (arg[of] != *option) {
 804baa5:	38 c8                	cmp    %cl,%al
 804baa7:	75 17                	jne    804bac0 <cmd_is_option+0x99>
		of++;
 804baa9:	43                   	inc    %ebx
		option++;
 804baaa:	eb d2                	jmp    804ba7e <cmd_is_option+0x57>
		posix_print_error_and_exit("Incorrect option syntax '%s'. The "
 804baac:	50                   	push   %eax
 804baad:	50                   	push   %eax
 804baae:	ff 75 08             	pushl  0x8(%ebp)
 804bab1:	68 5e eb 04 08       	push   $0x804eb5e
 804bab6:	e8 33 fe ff ff       	call   804b8ee <posix_print_error_and_exit>
 804babb:	83 c4 10             	add    $0x10,%esp
 804babe:	eb 02                	jmp    804bac2 <cmd_is_option+0x9b>
			return 0;
 804bac0:	31 db                	xor    %ebx,%ebx
}
 804bac2:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804bac5:	89 d8                	mov    %ebx,%eax
 804bac7:	5b                   	pop    %ebx
 804bac8:	5e                   	pop    %esi
 804bac9:	5f                   	pop    %edi
 804baca:	5d                   	pop    %ebp
 804bacb:	c3                   	ret    

0804bacc <cmd_is_help_option>:
{
 804bacc:	f3 0f 1e fb          	endbr32 
 804bad0:	55                   	push   %ebp
 804bad1:	89 e5                	mov    %esp,%ebp
 804bad3:	53                   	push   %ebx
 804bad4:	53                   	push   %ebx
 804bad5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (arg[0] == '-') {
 804bad8:	80 3b 2d             	cmpb   $0x2d,(%ebx)
 804badb:	75 0c                	jne    804bae9 <cmd_is_help_option+0x1d>
	if (arg[0] == '-') {
 804badd:	80 7b 01 2d          	cmpb   $0x2d,0x1(%ebx)
 804bae1:	74 03                	je     804bae6 <cmd_is_help_option+0x1a>
		arg++;
 804bae3:	43                   	inc    %ebx
 804bae4:	eb 03                	jmp    804bae9 <cmd_is_help_option+0x1d>
		arg++;
 804bae6:	83 c3 02             	add    $0x2,%ebx
	if ((strcasecmp(arg, "?") == 0) ||
 804bae9:	51                   	push   %ecx
 804baea:	51                   	push   %ecx
 804baeb:	68 b8 eb 04 08       	push   $0x804ebb8
 804baf0:	53                   	push   %ebx
 804baf1:	e8 1a d9 ff ff       	call   8049410 <strcasecmp@plt>
 804baf6:	83 c4 10             	add    $0x10,%esp
 804baf9:	89 c2                	mov    %eax,%edx
		return 1;
 804bafb:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
 804bb00:	85 d2                	test   %edx,%edx
 804bb02:	74 33                	je     804bb37 <cmd_is_help_option+0x6b>
	    (strcasecmp(arg, "h") == 0) ||
 804bb04:	52                   	push   %edx
 804bb05:	52                   	push   %edx
 804bb06:	68 ba eb 04 08       	push   $0x804ebba
 804bb0b:	53                   	push   %ebx
 804bb0c:	e8 ff d8 ff ff       	call   8049410 <strcasecmp@plt>
 804bb11:	83 c4 10             	add    $0x10,%esp
 804bb14:	89 c2                	mov    %eax,%edx
		return 1;
 804bb16:	b8 01 00 00 00       	mov    $0x1,%eax
	if ((strcasecmp(arg, "?") == 0) ||
 804bb1b:	85 d2                	test   %edx,%edx
 804bb1d:	74 18                	je     804bb37 <cmd_is_help_option+0x6b>
	    (strcasecmp(arg, "help") == 0)) {
 804bb1f:	50                   	push   %eax
 804bb20:	50                   	push   %eax
 804bb21:	68 5c ec 04 08       	push   $0x804ec5c
 804bb26:	53                   	push   %ebx
 804bb27:	e8 e4 d8 ff ff       	call   8049410 <strcasecmp@plt>
 804bb2c:	83 c4 10             	add    $0x10,%esp
	    (strcasecmp(arg, "h") == 0) ||
 804bb2f:	85 c0                	test   %eax,%eax
 804bb31:	0f 94 c0             	sete   %al
 804bb34:	0f b6 c0             	movzbl %al,%eax
}
 804bb37:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804bb3a:	c9                   	leave  
 804bb3b:	c3                   	ret    

0804bb3c <cmd_read_option_value>:
{
 804bb3c:	f3 0f 1e fb          	endbr32 
 804bb40:	55                   	push   %ebp
 804bb41:	89 e5                	mov    %esp,%ebp
 804bb43:	57                   	push   %edi
 804bb44:	56                   	push   %esi
 804bb45:	53                   	push   %ebx
 804bb46:	83 ec 1c             	sub    $0x1c,%esp
 804bb49:	8b 45 10             	mov    0x10(%ebp),%eax
 804bb4c:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804bb4f:	65 8b 15 14 00 00 00 	mov    %gs:0x14,%edx
 804bb56:	89 55 e4             	mov    %edx,-0x1c(%ebp)
 804bb59:	31 d2                	xor    %edx,%edx
 804bb5b:	8b 7d 0c             	mov    0xc(%ebp),%edi
 804bb5e:	8b 75 14             	mov    0x14(%ebp),%esi
	char *endptr = NULL;
 804bb61:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	switch (type) {
 804bb68:	3c 64                	cmp    $0x64,%al
 804bb6a:	0f 84 19 01 00 00    	je     804bc89 <cmd_read_option_value+0x14d>
 804bb70:	7f 26                	jg     804bb98 <cmd_read_option_value+0x5c>
 804bb72:	3c 55                	cmp    $0x55,%al
 804bb74:	0f 84 ef 00 00 00    	je     804bc69 <cmd_read_option_value+0x12d>
 804bb7a:	3c 62                	cmp    $0x62,%al
 804bb7c:	74 44                	je     804bbc2 <cmd_read_option_value+0x86>
 804bb7e:	3c 49                	cmp    $0x49,%al
 804bb80:	0f 85 16 01 00 00    	jne    804bc9c <cmd_read_option_value+0x160>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
 804bb86:	50                   	push   %eax
 804bb87:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804bb8a:	6a 00                	push   $0x0
 804bb8c:	50                   	push   %eax
 804bb8d:	53                   	push   %ebx
 804bb8e:	e8 1d d8 ff ff       	call   80493b0 <strtoll@plt>
 804bb93:	e9 e7 00 00 00       	jmp    804bc7f <cmd_read_option_value+0x143>
	switch (type) {
 804bb98:	3c 73                	cmp    $0x73,%al
 804bb9a:	0f 84 a7 00 00 00    	je     804bc47 <cmd_read_option_value+0x10b>
 804bba0:	3c 75                	cmp    $0x75,%al
 804bba2:	0f 84 b2 00 00 00    	je     804bc5a <cmd_read_option_value+0x11e>
 804bba8:	3c 69                	cmp    $0x69,%al
 804bbaa:	0f 85 ec 00 00 00    	jne    804bc9c <cmd_read_option_value+0x160>
		*(int32_t *)dest = strtol(str, &endptr, 0);
 804bbb0:	50                   	push   %eax
 804bbb1:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804bbb4:	6a 00                	push   $0x0
 804bbb6:	50                   	push   %eax
 804bbb7:	53                   	push   %ebx
 804bbb8:	e8 73 d9 ff ff       	call   8049530 <strtol@plt>
 804bbbd:	e9 b6 00 00 00       	jmp    804bc78 <cmd_read_option_value+0x13c>
		if (strcasecmp(str, "false") == 0) {
 804bbc2:	50                   	push   %eax
 804bbc3:	50                   	push   %eax
 804bbc4:	68 bc eb 04 08       	push   $0x804ebbc
 804bbc9:	53                   	push   %ebx
 804bbca:	e8 41 d8 ff ff       	call   8049410 <strcasecmp@plt>
 804bbcf:	83 c4 10             	add    $0x10,%esp
 804bbd2:	85 c0                	test   %eax,%eax
 804bbd4:	75 08                	jne    804bbde <cmd_read_option_value+0xa2>
			*(bool *)dest = false;
 804bbd6:	c6 07 00             	movb   $0x0,(%edi)
			endptr = (char *)str + 5;
 804bbd9:	8d 43 05             	lea    0x5(%ebx),%eax
 804bbdc:	eb 1a                	jmp    804bbf8 <cmd_read_option_value+0xbc>
		} else if (strcmp(str, "0") == 0) {
 804bbde:	50                   	push   %eax
 804bbdf:	50                   	push   %eax
 804bbe0:	68 c2 eb 04 08       	push   $0x804ebc2
 804bbe5:	53                   	push   %ebx
 804bbe6:	e8 15 d7 ff ff       	call   8049300 <strcmp@plt>
 804bbeb:	83 c4 10             	add    $0x10,%esp
 804bbee:	85 c0                	test   %eax,%eax
 804bbf0:	75 0e                	jne    804bc00 <cmd_read_option_value+0xc4>
			*(bool *)dest = false;
 804bbf2:	c6 07 00             	movb   $0x0,(%edi)
			endptr = (char *)str + 1;
 804bbf5:	8d 43 01             	lea    0x1(%ebx),%eax
 804bbf8:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (!error && endptr && *endptr != 0) {
 804bbfb:	e9 af 00 00 00       	jmp    804bcaf <cmd_read_option_value+0x173>
		} else if (strcasecmp(str, "true") == 0) {
 804bc00:	51                   	push   %ecx
 804bc01:	51                   	push   %ecx
 804bc02:	68 c4 eb 04 08       	push   $0x804ebc4
 804bc07:	53                   	push   %ebx
 804bc08:	e8 03 d8 ff ff       	call   8049410 <strcasecmp@plt>
 804bc0d:	83 c4 10             	add    $0x10,%esp
 804bc10:	85 c0                	test   %eax,%eax
 804bc12:	75 08                	jne    804bc1c <cmd_read_option_value+0xe0>
			*(bool *)dest = true;
 804bc14:	c6 07 01             	movb   $0x1,(%edi)
			endptr = (char *)str + 4;
 804bc17:	8d 43 04             	lea    0x4(%ebx),%eax
 804bc1a:	eb dc                	jmp    804bbf8 <cmd_read_option_value+0xbc>
		} else if (strcmp(str, "1") == 0) {
 804bc1c:	52                   	push   %edx
 804bc1d:	52                   	push   %edx
 804bc1e:	68 c9 eb 04 08       	push   $0x804ebc9
 804bc23:	53                   	push   %ebx
 804bc24:	e8 d7 d6 ff ff       	call   8049300 <strcmp@plt>
 804bc29:	83 c4 10             	add    $0x10,%esp
 804bc2c:	85 c0                	test   %eax,%eax
 804bc2e:	74 12                	je     804bc42 <cmd_read_option_value+0x106>
		posix_print_error_and_exit("Error reading value of %s '%s'. Use"
 804bc30:	50                   	push   %eax
 804bc31:	53                   	push   %ebx
 804bc32:	56                   	push   %esi
 804bc33:	68 cb eb 04 08       	push   $0x804ebcb
 804bc38:	e8 b1 fc ff ff       	call   804b8ee <posix_print_error_and_exit>
 804bc3d:	83 c4 10             	add    $0x10,%esp
 804bc40:	eb 7d                	jmp    804bcbf <cmd_read_option_value+0x183>
			*(bool *)dest = true;
 804bc42:	c6 07 01             	movb   $0x1,(%edi)
			endptr = (char *)str + 1;
 804bc45:	eb ae                	jmp    804bbf5 <cmd_read_option_value+0xb9>
		*(char **)dest = (char *)str;
 804bc47:	89 1f                	mov    %ebx,(%edi)
		endptr = (char *)str + strlen(str);
 804bc49:	31 c0                	xor    %eax,%eax
 804bc4b:	83 c9 ff             	or     $0xffffffff,%ecx
 804bc4e:	89 df                	mov    %ebx,%edi
 804bc50:	f2 ae                	repnz scas %es:(%edi),%al
 804bc52:	f7 d1                	not    %ecx
 804bc54:	8d 44 0b ff          	lea    -0x1(%ebx,%ecx,1),%eax
 804bc58:	eb 9e                	jmp    804bbf8 <cmd_read_option_value+0xbc>
		*(uint32_t *)dest = strtoul(str, &endptr, 0);
 804bc5a:	50                   	push   %eax
 804bc5b:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804bc5e:	6a 00                	push   $0x0
 804bc60:	50                   	push   %eax
 804bc61:	53                   	push   %ebx
 804bc62:	e8 89 d7 ff ff       	call   80493f0 <strtoul@plt>
 804bc67:	eb 0f                	jmp    804bc78 <cmd_read_option_value+0x13c>
		*(uint64_t *)dest = strtoull(str, &endptr, 0);
 804bc69:	50                   	push   %eax
 804bc6a:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804bc6d:	6a 00                	push   $0x0
 804bc6f:	50                   	push   %eax
 804bc70:	53                   	push   %ebx
 804bc71:	e8 ea d7 ff ff       	call   8049460 <strtoull@plt>
 804bc76:	eb 07                	jmp    804bc7f <cmd_read_option_value+0x143>
		*(int32_t *)dest = strtol(str, &endptr, 0);
 804bc78:	89 07                	mov    %eax,(%edi)
 804bc7a:	83 c4 10             	add    $0x10,%esp
 804bc7d:	eb 30                	jmp    804bcaf <cmd_read_option_value+0x173>
		*(int64_t *)dest = strtoll(str, &endptr, 0);
 804bc7f:	89 07                	mov    %eax,(%edi)
 804bc81:	83 c4 10             	add    $0x10,%esp
 804bc84:	89 57 04             	mov    %edx,0x4(%edi)
	if (!error && endptr && *endptr != 0) {
 804bc87:	eb 26                	jmp    804bcaf <cmd_read_option_value+0x173>
		*(double *)dest = strtod(str, &endptr);
 804bc89:	8d 45 e0             	lea    -0x20(%ebp),%eax
 804bc8c:	51                   	push   %ecx
 804bc8d:	51                   	push   %ecx
 804bc8e:	50                   	push   %eax
 804bc8f:	53                   	push   %ebx
 804bc90:	e8 db d7 ff ff       	call   8049470 <strtod@plt>
 804bc95:	83 c4 10             	add    $0x10,%esp
 804bc98:	dd 1f                	fstpl  (%edi)
	if (!error && endptr && *endptr != 0) {
 804bc9a:	eb 13                	jmp    804bcaf <cmd_read_option_value+0x173>
	switch (type) {
 804bc9c:	0f be c0             	movsbl %al,%eax
		posix_print_error_and_exit(CMD_TYPE_ERROR, type);
 804bc9f:	52                   	push   %edx
 804bca0:	52                   	push   %edx
 804bca1:	50                   	push   %eax
 804bca2:	68 0d ec 04 08       	push   $0x804ec0d
 804bca7:	e8 42 fc ff ff       	call   804b8ee <posix_print_error_and_exit>
 804bcac:	83 c4 10             	add    $0x10,%esp
	if (!error && endptr && *endptr != 0) {
 804bcaf:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804bcb2:	85 c0                	test   %eax,%eax
 804bcb4:	74 09                	je     804bcbf <cmd_read_option_value+0x183>
 804bcb6:	80 38 00             	cmpb   $0x0,(%eax)
 804bcb9:	0f 85 71 ff ff ff    	jne    804bc30 <cmd_read_option_value+0xf4>
}
 804bcbf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804bcc2:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804bcc9:	74 05                	je     804bcd0 <cmd_read_option_value+0x194>
 804bccb:	e8 c0 d6 ff ff       	call   8049390 <__stack_chk_fail@plt>
 804bcd0:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804bcd3:	5b                   	pop    %ebx
 804bcd4:	5e                   	pop    %esi
 804bcd5:	5f                   	pop    %edi
 804bcd6:	5d                   	pop    %ebp
 804bcd7:	c3                   	ret    

0804bcd8 <cmd_args_set_defaults>:
{
 804bcd8:	f3 0f 1e fb          	endbr32 
 804bcdc:	55                   	push   %ebp
 804bcdd:	89 e5                	mov    %esp,%ebp
 804bcdf:	53                   	push   %ebx
 804bce0:	51                   	push   %ecx
 804bce1:	8b 45 08             	mov    0x8(%ebp),%eax
 804bce4:	8d 58 04             	lea    0x4(%eax),%ebx
	while (args_struct[count].option != NULL) {
 804bce7:	83 3b 00             	cmpl   $0x0,(%ebx)
 804bcea:	0f 84 8c 00 00 00    	je     804bd7c <cmd_args_set_defaults+0xa4>
		if (args_struct[count].dest == NULL) {
 804bcf0:	8b 53 0c             	mov    0xc(%ebx),%edx
 804bcf3:	85 d2                	test   %edx,%edx
 804bcf5:	74 7d                	je     804bd74 <cmd_args_set_defaults+0x9c>
		switch (args_struct[count].type) {
 804bcf7:	0f be 43 08          	movsbl 0x8(%ebx),%eax
 804bcfb:	3c 64                	cmp    $0x64,%al
 804bcfd:	74 5b                	je     804bd5a <cmd_args_set_defaults+0x82>
 804bcff:	7f 26                	jg     804bd27 <cmd_args_set_defaults+0x4f>
 804bd01:	3c 55                	cmp    $0x55,%al
 804bd03:	74 46                	je     804bd4b <cmd_args_set_defaults+0x73>
 804bd05:	7f 17                	jg     804bd1e <cmd_args_set_defaults+0x46>
 804bd07:	84 c0                	test   %al,%al
 804bd09:	74 69                	je     804bd74 <cmd_args_set_defaults+0x9c>
 804bd0b:	3c 49                	cmp    $0x49,%al
 804bd0d:	75 55                	jne    804bd64 <cmd_args_set_defaults+0x8c>
			*(int64_t *)args_struct[count].dest = INT64_MAX;
 804bd0f:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
 804bd15:	c7 42 04 ff ff ff 7f 	movl   $0x7fffffff,0x4(%edx)
			break;
 804bd1c:	eb 56                	jmp    804bd74 <cmd_args_set_defaults+0x9c>
		switch (args_struct[count].type) {
 804bd1e:	3c 62                	cmp    $0x62,%al
 804bd20:	75 42                	jne    804bd64 <cmd_args_set_defaults+0x8c>
			*(bool *)args_struct[count].dest = false;
 804bd22:	c6 02 00             	movb   $0x0,(%edx)
			break;
 804bd25:	eb 4d                	jmp    804bd74 <cmd_args_set_defaults+0x9c>
		switch (args_struct[count].type) {
 804bd27:	3c 73                	cmp    $0x73,%al
 804bd29:	74 10                	je     804bd3b <cmd_args_set_defaults+0x63>
 804bd2b:	3c 75                	cmp    $0x75,%al
 804bd2d:	74 14                	je     804bd43 <cmd_args_set_defaults+0x6b>
 804bd2f:	3c 69                	cmp    $0x69,%al
 804bd31:	75 31                	jne    804bd64 <cmd_args_set_defaults+0x8c>
			*(int32_t *)args_struct[count].dest = INT32_MAX;
 804bd33:	c7 02 ff ff ff 7f    	movl   $0x7fffffff,(%edx)
			break;
 804bd39:	eb 39                	jmp    804bd74 <cmd_args_set_defaults+0x9c>
			*(char **)args_struct[count].dest = NULL;
 804bd3b:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
			break;
 804bd41:	eb 31                	jmp    804bd74 <cmd_args_set_defaults+0x9c>
			*(uint32_t *)args_struct[count].dest = UINT32_MAX;
 804bd43:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
			break;
 804bd49:	eb 29                	jmp    804bd74 <cmd_args_set_defaults+0x9c>
			*(uint64_t *)args_struct[count].dest = UINT64_MAX;
 804bd4b:	c7 02 ff ff ff ff    	movl   $0xffffffff,(%edx)
 804bd51:	c7 42 04 ff ff ff ff 	movl   $0xffffffff,0x4(%edx)
			break;
 804bd58:	eb 1a                	jmp    804bd74 <cmd_args_set_defaults+0x9c>
			*(double *)args_struct[count].dest = (double)NAN;
 804bd5a:	d9 05 4c e1 04 08    	flds   0x804e14c
 804bd60:	dd 1a                	fstpl  (%edx)
			break;
 804bd62:	eb 10                	jmp    804bd74 <cmd_args_set_defaults+0x9c>
			posix_print_error_and_exit(CMD_TYPE_ERROR,
 804bd64:	52                   	push   %edx
 804bd65:	52                   	push   %edx
 804bd66:	50                   	push   %eax
 804bd67:	68 0d ec 04 08       	push   $0x804ec0d
 804bd6c:	e8 7d fb ff ff       	call   804b8ee <posix_print_error_and_exit>
 804bd71:	83 c4 10             	add    $0x10,%esp
		count++;
 804bd74:	83 c3 1c             	add    $0x1c,%ebx
 804bd77:	e9 6b ff ff ff       	jmp    804bce7 <cmd_args_set_defaults+0xf>
}
 804bd7c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804bd7f:	c9                   	leave  
 804bd80:	c3                   	ret    

0804bd81 <cmd_print_switches_help>:

/**
 * Print short list of available switches
 */
void cmd_print_switches_help(struct args_struct_t args_struct[])
{
 804bd81:	f3 0f 1e fb          	endbr32 
 804bd85:	55                   	push   %ebp
 804bd86:	89 e5                	mov    %esp,%ebp
 804bd88:	57                   	push   %edi
 804bd89:	56                   	push   %esi
	int count = 0;
	int printed_in_line = strlen(_HELP_SWITCH) + 1;
 804bd8a:	be 19 00 00 00       	mov    $0x19,%esi
{
 804bd8f:	53                   	push   %ebx
 804bd90:	83 ec 5c             	sub    $0x5c,%esp
 804bd93:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804bd96:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804bd9c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804bd9f:	31 c0                	xor    %eax,%eax
  return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
 804bda1:	68 32 ec 04 08       	push   $0x804ec32
 804bda6:	68 4b ec 04 08       	push   $0x804ec4b
 804bdab:	6a 01                	push   $0x1
 804bdad:	ff 35 04 24 05 08    	pushl  0x8052404
 804bdb3:	e8 28 d7 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804bdb8:	83 c4 10             	add    $0x10,%esp

	fprintf(stdout, "%s ", _HELP_SWITCH);

	while (args_struct[count].option != NULL) {
 804bdbb:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
 804bdbf:	74 67                	je     804be28 <cmd_print_switches_help+0xa7>
		char stringy[_MAX_STRINGY_LEN];

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
 804bdc1:	8d 45 9e             	lea    -0x62(%ebp),%eax
 804bdc4:	89 da                	mov    %ebx,%edx
				      &args_struct[count]);

		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
 804bdc6:	8d 7d 9e             	lea    -0x62(%ebp),%edi
		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
 804bdc9:	e8 ae fb ff ff       	call   804b97c <cmd_gen_switch_syntax.constprop.0>
		if (printed_in_line + strlen(stringy) > _MAX_LINE_WIDTH) {
 804bdce:	31 c0                	xor    %eax,%eax
 804bdd0:	83 c9 ff             	or     $0xffffffff,%ecx
 804bdd3:	f2 ae                	repnz scas %es:(%edi),%al
 804bdd5:	f7 d1                	not    %ecx
 804bdd7:	8d 44 0e ff          	lea    -0x1(%esi,%ecx,1),%eax
 804bddb:	83 f8 64             	cmp    $0x64,%eax
 804bdde:	76 18                	jbe    804bdf8 <cmd_print_switches_help+0x77>
 804bde0:	52                   	push   %edx
			fprintf(stdout, "\n");
			printed_in_line = 0;
 804bde1:	31 f6                	xor    %esi,%esi
 804bde3:	68 cb ec 04 08       	push   $0x804eccb
 804bde8:	6a 01                	push   $0x1
 804bdea:	ff 35 04 24 05 08    	pushl  0x8052404
 804bdf0:	e8 eb d6 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804bdf5:	83 c4 10             	add    $0x10,%esp
 804bdf8:	8d 45 9e             	lea    -0x62(%ebp),%eax
		}

		fprintf(stdout, "%s", stringy);
		printed_in_line += strlen(stringy);
 804bdfb:	8d 7d 9e             	lea    -0x62(%ebp),%edi
 804bdfe:	83 c3 1c             	add    $0x1c,%ebx
 804be01:	50                   	push   %eax
 804be02:	68 ea ea 04 08       	push   $0x804eaea
 804be07:	6a 01                	push   $0x1
 804be09:	ff 35 04 24 05 08    	pushl  0x8052404
 804be0f:	e8 cc d6 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804be14:	31 c0                	xor    %eax,%eax
 804be16:	83 c9 ff             	or     $0xffffffff,%ecx
 804be19:	83 c4 10             	add    $0x10,%esp
 804be1c:	f2 ae                	repnz scas %es:(%edi),%al
 804be1e:	89 c8                	mov    %ecx,%eax
 804be20:	f7 d0                	not    %eax
 804be22:	8d 74 06 ff          	lea    -0x1(%esi,%eax,1),%esi
		count++;
 804be26:	eb 93                	jmp    804bdbb <cmd_print_switches_help+0x3a>
 804be28:	50                   	push   %eax
 804be29:	68 cb ec 04 08       	push   $0x804eccb
 804be2e:	6a 01                	push   $0x1
 804be30:	ff 35 04 24 05 08    	pushl  0x8052404
 804be36:	e8 a5 d6 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804be3b:	83 c4 10             	add    $0x10,%esp
	}

	fprintf(stdout, "\n");
}
 804be3e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804be41:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804be48:	74 05                	je     804be4f <cmd_print_switches_help+0xce>
 804be4a:	e8 41 d5 ff ff       	call   8049390 <__stack_chk_fail@plt>
 804be4f:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804be52:	5b                   	pop    %ebx
 804be53:	5e                   	pop    %esi
 804be54:	5f                   	pop    %edi
 804be55:	5d                   	pop    %ebp
 804be56:	c3                   	ret    

0804be57 <cmd_print_long_help>:

/**
 * Print the long help message of the program
 */
void cmd_print_long_help(struct args_struct_t args_struct[])
{
 804be57:	f3 0f 1e fb          	endbr32 
 804be5b:	55                   	push   %ebp
 804be5c:	89 e5                	mov    %esp,%ebp
 804be5e:	57                   	push   %edi
 804be5f:	56                   	push   %esi
 804be60:	53                   	push   %ebx
 804be61:	83 ec 78             	sub    $0x78,%esp
 804be64:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804be67:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804be6d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804be70:	31 c0                	xor    %eax,%eax
	int ret;
	int count = 0;
	int printed_in_line = 0;
	char stringy[_MAX_STRINGY_LEN];

	cmd_print_switches_help(args_struct);
 804be72:	53                   	push   %ebx
 804be73:	e8 09 ff ff ff       	call   804bd81 <cmd_print_switches_help>
 804be78:	5a                   	pop    %edx
 804be79:	59                   	pop    %ecx
 804be7a:	68 4f ec 04 08       	push   $0x804ec4f
 804be7f:	68 32 ec 04 08       	push   $0x804ec32
 804be84:	6a 1d                	push   $0x1d
 804be86:	68 61 ec 04 08       	push   $0x804ec61
 804be8b:	6a 01                	push   $0x1
 804be8d:	ff 35 04 24 05 08    	pushl  0x8052404
 804be93:	e8 48 d6 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804be98:	83 c4 20             	add    $0x20,%esp

	fprintf(stdout, "\n %-*s:%s\n", _LONG_HELP_ALIGN-1,
		_HELP_SWITCH, _HELP_DESCR);

	while (args_struct[count].option != NULL) {
 804be9b:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
 804be9f:	0f 84 ab 00 00 00    	je     804bf50 <cmd_print_long_help+0xf9>
		int printed_right;
		char *toprint;
		int total_to_print;

		cmd_gen_switch_syntax(stringy, _MAX_STRINGY_LEN,
 804bea5:	8d 75 9e             	lea    -0x62(%ebp),%esi
 804bea8:	89 da                	mov    %ebx,%edx
 804beaa:	89 f0                	mov    %esi,%eax
 804beac:	e8 cb fa ff ff       	call   804b97c <cmd_gen_switch_syntax.constprop.0>
 804beb1:	83 ec 0c             	sub    $0xc,%esp
 804beb4:	56                   	push   %esi
 804beb5:	6a 1d                	push   $0x1d
 804beb7:	68 6c ec 04 08       	push   $0x804ec6c
 804bebc:	6a 01                	push   $0x1
 804bebe:	ff 35 04 24 05 08    	pushl  0x8052404
 804bec4:	e8 17 d6 ff ff       	call   80494e0 <__fprintf_chk@plt>
				      &args_struct[count]);

		ret = fprintf(stdout, " %-*s:", _LONG_HELP_ALIGN-1, stringy);
		printed_in_line = ret;
		printed_right = 0;
		toprint = args_struct[count].descript;
 804bec9:	8b 73 18             	mov    0x18(%ebx),%esi
		total_to_print = strlen(toprint);
 804becc:	83 c9 ff             	or     $0xffffffff,%ecx
 804becf:	83 c4 14             	add    $0x14,%esp
 804bed2:	89 c2                	mov    %eax,%edx
 804bed4:	31 c0                	xor    %eax,%eax
 804bed6:	89 f7                	mov    %esi,%edi
 804bed8:	f2 ae                	repnz scas %es:(%edi),%al
 804beda:	56                   	push   %esi
 804bedb:	f7 d1                	not    %ecx
 804bedd:	8d 41 ff             	lea    -0x1(%ecx),%eax
 804bee0:	89 45 94             	mov    %eax,-0x6c(%ebp)
		ret = fprintf(stdout, "%.*s\n",
 804bee3:	b8 64 00 00 00       	mov    $0x64,%eax
 804bee8:	29 d0                	sub    %edx,%eax
 804beea:	50                   	push   %eax
 804beeb:	68 73 ec 04 08       	push   $0x804ec73
 804bef0:	6a 01                	push   $0x1
 804bef2:	ff 35 04 24 05 08    	pushl  0x8052404
 804bef8:	e8 e3 d5 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804befd:	83 c4 20             	add    $0x20,%esp
				_MAX_LINE_WIDTH - printed_in_line,
				&toprint[printed_right]);
		printed_right += ret - 1;
 804bf00:	8d 78 ff             	lea    -0x1(%eax),%edi

		while (printed_right < total_to_print) {
 804bf03:	3b 7d 94             	cmp    -0x6c(%ebp),%edi
 804bf06:	7d 40                	jge    804bf48 <cmd_print_long_help+0xf1>
 804bf08:	83 ec 0c             	sub    $0xc,%esp
 804bf0b:	68 cc ec 04 08       	push   $0x804eccc
 804bf10:	6a 1e                	push   $0x1e
 804bf12:	68 79 ec 04 08       	push   $0x804ec79
 804bf17:	6a 01                	push   $0x1
 804bf19:	ff 35 04 24 05 08    	pushl  0x8052404
 804bf1f:	e8 bc d5 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804bf24:	83 c4 14             	add    $0x14,%esp
			fprintf(stdout, "%*s", _LONG_HELP_ALIGN, "");
			ret = fprintf(stdout, "%.*s\n",
 804bf27:	8d 04 3e             	lea    (%esi,%edi,1),%eax
 804bf2a:	50                   	push   %eax
 804bf2b:	6a 46                	push   $0x46
 804bf2d:	68 73 ec 04 08       	push   $0x804ec73
 804bf32:	6a 01                	push   $0x1
 804bf34:	ff 35 04 24 05 08    	pushl  0x8052404
 804bf3a:	e8 a1 d5 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804bf3f:	83 c4 20             	add    $0x20,%esp
				      _MAX_LINE_WIDTH - _LONG_HELP_ALIGN,
				      &toprint[printed_right]);
			printed_right += ret - 1;
 804bf42:	8d 7c 07 ff          	lea    -0x1(%edi,%eax,1),%edi
 804bf46:	eb bb                	jmp    804bf03 <cmd_print_long_help+0xac>
		}
		count++;
 804bf48:	83 c3 1c             	add    $0x1c,%ebx
 804bf4b:	e9 4b ff ff ff       	jmp    804be9b <cmd_print_long_help+0x44>
 804bf50:	50                   	push   %eax
 804bf51:	68 cb ec 04 08       	push   $0x804eccb
 804bf56:	6a 01                	push   $0x1
 804bf58:	ff 35 04 24 05 08    	pushl  0x8052404
 804bf5e:	e8 7d d5 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804bf63:	83 c4 0c             	add    $0xc,%esp
 804bf66:	68 7d ec 04 08       	push   $0x804ec7d
 804bf6b:	6a 01                	push   $0x1
 804bf6d:	ff 35 04 24 05 08    	pushl  0x8052404
 804bf73:	e8 68 d5 ff ff       	call   80494e0 <__fprintf_chk@plt>
 804bf78:	83 c4 10             	add    $0x10,%esp
	}
	fprintf(stdout, "\n");
	fprintf(stdout, "Note that which options are available depends on the "
		"enabled features/drivers\n\n");
}
 804bf7b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804bf7e:	65 33 05 14 00 00 00 	xor    %gs:0x14,%eax
 804bf85:	74 05                	je     804bf8c <cmd_print_long_help+0x135>
 804bf87:	e8 04 d4 ff ff       	call   8049390 <__stack_chk_fail@plt>
 804bf8c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804bf8f:	5b                   	pop    %ebx
 804bf90:	5e                   	pop    %esi
 804bf91:	5f                   	pop    %edi
 804bf92:	5d                   	pop    %ebp
 804bf93:	c3                   	ret    

0804bf94 <cmd_parse_one_arg>:
 * Try to find if this argument is in the list (and it is not manual)
 * if it does, try to parse it, set its dest accordingly, and return true
 * if it is not found, return false
 */
bool cmd_parse_one_arg(char *argv, struct args_struct_t args_struct[])
{
 804bf94:	f3 0f 1e fb          	endbr32 
 804bf98:	55                   	push   %ebp
 804bf99:	89 e5                	mov    %esp,%ebp
 804bf9b:	57                   	push   %edi
 804bf9c:	56                   	push   %esi
 804bf9d:	53                   	push   %ebx
 804bf9e:	83 ec 18             	sub    $0x18,%esp
 804bfa1:	8b 7d 08             	mov    0x8(%ebp),%edi
 804bfa4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int count = 0;
	int ret;

	if (cmd_is_help_option(argv)) {
 804bfa7:	57                   	push   %edi
 804bfa8:	e8 1f fb ff ff       	call   804bacc <cmd_is_help_option>
 804bfad:	83 c4 10             	add    $0x10,%esp
 804bfb0:	85 c0                	test   %eax,%eax
 804bfb2:	74 22                	je     804bfd6 <cmd_parse_one_arg+0x42>
		cmd_print_long_help(args_struct);
 804bfb4:	83 ec 0c             	sub    $0xc,%esp
 804bfb7:	53                   	push   %ebx
 804bfb8:	e8 9a fe ff ff       	call   804be57 <cmd_print_long_help>
		posix_exit(0);
 804bfbd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804bfc4:	e8 e8 f7 ff ff       	call   804b7b1 <posix_exit>
 804bfc9:	83 c4 10             	add    $0x10,%esp
 804bfcc:	eb 08                	jmp    804bfd6 <cmd_parse_one_arg+0x42>
	}

	while (args_struct[count].option != NULL) {
		if (args_struct[count].manual) {
 804bfce:	80 3b 00             	cmpb   $0x0,(%ebx)
 804bfd1:	74 0c                	je     804bfdf <cmd_parse_one_arg+0x4b>
 804bfd3:	83 c3 1c             	add    $0x1c,%ebx
	while (args_struct[count].option != NULL) {
 804bfd6:	8b 53 04             	mov    0x4(%ebx),%edx
 804bfd9:	85 d2                	test   %edx,%edx
 804bfdb:	75 f1                	jne    804bfce <cmd_parse_one_arg+0x3a>
 804bfdd:	eb 6b                	jmp    804c04a <cmd_parse_one_arg+0xb6>
			count++;
			continue;
		}
		ret = cmd_is_option(argv, args_struct[count].option,
 804bfdf:	51                   	push   %ecx
				    !args_struct[count].is_switch);
 804bfe0:	8a 43 02             	mov    0x2(%ebx),%al
 804bfe3:	83 f0 01             	xor    $0x1,%eax
		ret = cmd_is_option(argv, args_struct[count].option,
 804bfe6:	0f b6 c0             	movzbl %al,%eax
 804bfe9:	50                   	push   %eax
 804bfea:	52                   	push   %edx
 804bfeb:	57                   	push   %edi
 804bfec:	e8 36 fa ff ff       	call   804ba27 <cmd_is_option>
 804bff1:	83 c4 10             	add    $0x10,%esp
 804bff4:	89 c6                	mov    %eax,%esi
		if (ret) {
 804bff6:	85 c0                	test   %eax,%eax
 804bff8:	74 d9                	je     804bfd3 <cmd_parse_one_arg+0x3f>
	if (arg_element->dest != NULL) {
 804bffa:	8b 53 10             	mov    0x10(%ebx),%edx
 804bffd:	85 d2                	test   %edx,%edx
 804bfff:	74 33                	je     804c034 <cmd_parse_one_arg+0xa0>
		if (arg_element->is_switch) {
 804c001:	80 7b 02 00          	cmpb   $0x0,0x2(%ebx)
 804c005:	0f be 43 0c          	movsbl 0xc(%ebx),%eax
 804c009:	74 18                	je     804c023 <cmd_parse_one_arg+0x8f>
			if (arg_element->type == 'b') {
 804c00b:	3c 62                	cmp    $0x62,%al
 804c00d:	75 05                	jne    804c014 <cmd_parse_one_arg+0x80>
				*(bool *)arg_element->dest = true;
 804c00f:	c6 02 01             	movb   $0x1,(%edx)
 804c012:	eb 20                	jmp    804c034 <cmd_parse_one_arg+0xa0>
				posix_print_error_and_exit(CMD_ERR_BOOL_SWI);
 804c014:	83 ec 0c             	sub    $0xc,%esp
 804c017:	68 cd ec 04 08       	push   $0x804eccd
 804c01c:	e8 cd f8 ff ff       	call   804b8ee <posix_print_error_and_exit>
 804c021:	eb 0e                	jmp    804c031 <cmd_parse_one_arg+0x9d>
			cmd_read_option_value(&argv[offset],
 804c023:	ff 73 04             	pushl  0x4(%ebx)
 804c026:	50                   	push   %eax
 804c027:	8d 04 37             	lea    (%edi,%esi,1),%eax
 804c02a:	52                   	push   %edx
 804c02b:	50                   	push   %eax
 804c02c:	e8 0b fb ff ff       	call   804bb3c <cmd_read_option_value>
 804c031:	83 c4 10             	add    $0x10,%esp
	if (arg_element->call_when_found) {
 804c034:	8b 53 14             	mov    0x14(%ebx),%edx
			cmd_handle_this_matched_arg(argv,
						    ret,
						    &args_struct[count]);
			return true;
 804c037:	b0 01                	mov    $0x1,%al
	if (arg_element->call_when_found) {
 804c039:	85 d2                	test   %edx,%edx
 804c03b:	74 0f                	je     804c04c <cmd_parse_one_arg+0xb8>
		arg_element->call_when_found(argv, offset);
 804c03d:	50                   	push   %eax
 804c03e:	50                   	push   %eax
 804c03f:	56                   	push   %esi
 804c040:	57                   	push   %edi
 804c041:	ff d2                	call   *%edx
			return true;
 804c043:	b0 01                	mov    $0x1,%al
		arg_element->call_when_found(argv, offset);
 804c045:	83 c4 10             	add    $0x10,%esp
 804c048:	eb 02                	jmp    804c04c <cmd_parse_one_arg+0xb8>
		}
		count++;
	}
	return false;
 804c04a:	31 c0                	xor    %eax,%eax
}
 804c04c:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c04f:	5b                   	pop    %ebx
 804c050:	5e                   	pop    %esi
 804c051:	5f                   	pop    %edi
 804c052:	5d                   	pop    %ebp
 804c053:	c3                   	ret    

0804c054 <native_cleanup_cmd_line>:
static int used_args;
static int args_aval;
#define ARGS_ALLOC_CHUNK_SIZE 20

void native_cleanup_cmd_line(void)
{
 804c054:	f3 0f 1e fb          	endbr32 
	if (args_struct != NULL) { /* LCOV_EXCL_BR_LINE */
 804c058:	a1 7c 29 05 08       	mov    0x805297c,%eax
 804c05d:	85 c0                	test   %eax,%eax
 804c05f:	74 1b                	je     804c07c <native_cleanup_cmd_line+0x28>
{
 804c061:	55                   	push   %ebp
 804c062:	89 e5                	mov    %esp,%ebp
 804c064:	83 ec 14             	sub    $0x14,%esp
		free(args_struct);
 804c067:	50                   	push   %eax
 804c068:	e8 c3 d2 ff ff       	call   8049330 <free@plt>
 804c06d:	83 c4 10             	add    $0x10,%esp
		args_struct = NULL;
 804c070:	c7 05 7c 29 05 08 00 	movl   $0x0,0x805297c
 804c077:	00 00 00 
	}
}
 804c07a:	c9                   	leave  
 804c07b:	c3                   	ret    
 804c07c:	c3                   	ret    

0804c07d <native_add_command_line_opts>:
 *
 * Each option to be added is described in one entry of the input <args>
 * This input must be terminated with an entry containing ARG_TABLE_ENDMARKER.
 */
void native_add_command_line_opts(struct args_struct_t *args)
{
 804c07d:	f3 0f 1e fb          	endbr32 
 804c081:	55                   	push   %ebp
 804c082:	89 e5                	mov    %esp,%ebp
 804c084:	57                   	push   %edi
	int count = 0;
 804c085:	31 ff                	xor    %edi,%edi
{
 804c087:	56                   	push   %esi
 804c088:	53                   	push   %ebx
 804c089:	83 ec 1c             	sub    $0x1c,%esp
 804c08c:	8b 75 08             	mov    0x8(%ebp),%esi

	while (args[count].option != NULL) {
 804c08f:	6b c7 1c             	imul   $0x1c,%edi,%eax
 804c092:	89 7d e4             	mov    %edi,-0x1c(%ebp)
 804c095:	47                   	inc    %edi
 804c096:	83 7c 06 04 00       	cmpl   $0x0,0x4(%esi,%eax,1)
 804c09b:	75 f2                	jne    804c08f <native_add_command_line_opts+0x12>
		count++;
	}
	count++; /*for the end marker*/

	if (used_args + count >= args_aval) {
 804c09d:	8b 15 78 29 05 08    	mov    0x8052978,%edx
 804c0a3:	a1 74 29 05 08       	mov    0x8052974,%eax
 804c0a8:	01 fa                	add    %edi,%edx
 804c0aa:	39 c2                	cmp    %eax,%edx
 804c0ac:	7c 43                	jl     804c0f1 <native_add_command_line_opts+0x74>
		if (growby < ARGS_ALLOC_CHUNK_SIZE) {
			growby = ARGS_ALLOC_CHUNK_SIZE;
		}

		struct args_struct_t *new_args_struct = realloc(args_struct,
				      (args_aval + growby)*
 804c0ae:	83 ff 14             	cmp    $0x14,%edi
 804c0b1:	ba 14 00 00 00       	mov    $0x14,%edx
 804c0b6:	0f 4d d7             	cmovge %edi,%edx
 804c0b9:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
		struct args_struct_t *new_args_struct = realloc(args_struct,
 804c0bc:	50                   	push   %eax
 804c0bd:	50                   	push   %eax
 804c0be:	6b c3 1c             	imul   $0x1c,%ebx,%eax
 804c0c1:	50                   	push   %eax
 804c0c2:	ff 35 7c 29 05 08    	pushl  0x805297c
 804c0c8:	e8 f3 d2 ff ff       	call   80493c0 <realloc@plt>
				      sizeof(struct args_struct_t));
		args_aval += growby;
 804c0cd:	89 1d 74 29 05 08    	mov    %ebx,0x8052974
		struct args_struct_t *new_args_struct = realloc(args_struct,
 804c0d3:	83 c4 10             	add    $0x10,%esp
		/* LCOV_EXCL_START */
		if (new_args_struct == NULL) {
 804c0d6:	85 c0                	test   %eax,%eax
 804c0d8:	75 12                	jne    804c0ec <native_add_command_line_opts+0x6f>
			posix_print_error_and_exit("Could not allocate memory");
 804c0da:	83 ec 0c             	sub    $0xc,%esp
 804c0dd:	68 18 ed 04 08       	push   $0x804ed18
 804c0e2:	e8 07 f8 ff ff       	call   804b8ee <posix_print_error_and_exit>
 804c0e7:	83 c4 10             	add    $0x10,%esp
 804c0ea:	eb 05                	jmp    804c0f1 <native_add_command_line_opts+0x74>
		} else {
			args_struct = new_args_struct;
 804c0ec:	a3 7c 29 05 08       	mov    %eax,0x805297c
		}
		/* LCOV_EXCL_STOP */
	}

	memcpy(&args_struct[used_args], args,
 804c0f1:	8b 15 78 29 05 08    	mov    0x8052978,%edx
		count*sizeof(struct args_struct_t));

	used_args += count - 1;
 804c0f7:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
	memcpy(&args_struct[used_args], args,
 804c0fa:	6b cf 1c             	imul   $0x1c,%edi,%ecx
 804c0fd:	6b c2 1c             	imul   $0x1c,%edx,%eax
 804c100:	03 05 7c 29 05 08    	add    0x805297c,%eax
	used_args += count - 1;
 804c106:	01 d3                	add    %edx,%ebx
  return __builtin___memcpy_chk (__dest, __src, __len, __bos0 (__dest));
 804c108:	89 c7                	mov    %eax,%edi
 804c10a:	89 1d 78 29 05 08    	mov    %ebx,0x8052978
 804c110:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	/*
	 * -1 as the end marker should be overwritten next time something
	 * is added
	 */
}
 804c112:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c115:	5b                   	pop    %ebx
 804c116:	5e                   	pop    %esi
 804c117:	5f                   	pop    %edi
 804c118:	5d                   	pop    %ebp
 804c119:	c3                   	ret    

0804c11a <native_add_testargs_option>:

void native_add_testargs_option(void)
{
 804c11a:	f3 0f 1e fb          	endbr32 
 804c11e:	55                   	push   %ebp
 804c11f:	89 e5                	mov    %esp,%ebp
 804c121:	83 ec 14             	sub    $0x14,%esp
		(void *)NULL, NULL,
		"Any argument that follows will be ignored by the top level, "
		"and made available for possible tests"},
		ARG_TABLE_ENDMARKER};

	native_add_command_line_opts(testargs_options);
 804c124:	68 20 12 05 08       	push   $0x8051220
 804c129:	e8 4f ff ff ff       	call   804c07d <native_add_command_line_opts>
 804c12e:	83 c4 10             	add    $0x10,%esp
}
 804c131:	c9                   	leave  
 804c132:	c3                   	ret    

0804c133 <native_handle_cmd_line>:
 * Handle possible command line arguments.
 *
 * We also store them for later use by possible test applications
 */
void native_handle_cmd_line(int argc, char *argv[])
{
 804c133:	f3 0f 1e fb          	endbr32 
 804c137:	55                   	push   %ebp
 804c138:	89 e5                	mov    %esp,%ebp
 804c13a:	57                   	push   %edi
 804c13b:	56                   	push   %esi
 804c13c:	53                   	push   %ebx
	s_argv = argv;
	s_argc = argc;

	cmd_args_set_defaults(args_struct);

	for (i = 1; i < argc; i++) {
 804c13d:	bb 01 00 00 00       	mov    $0x1,%ebx
{
 804c142:	83 ec 0c             	sub    $0xc,%esp
 804c145:	8b 75 0c             	mov    0xc(%ebp),%esi
	native_add_tracing_options();
 804c148:	e8 16 f8 ff ff       	call   804b963 <native_add_tracing_options>
	native_add_testargs_option();
 804c14d:	e8 c8 ff ff ff       	call   804c11a <native_add_testargs_option>
	cmd_args_set_defaults(args_struct);
 804c152:	83 ec 0c             	sub    $0xc,%esp
	s_argc = argc;
 804c155:	8b 45 08             	mov    0x8(%ebp),%eax
	cmd_args_set_defaults(args_struct);
 804c158:	ff 35 7c 29 05 08    	pushl  0x805297c
	s_argv = argv;
 804c15e:	89 35 84 29 05 08    	mov    %esi,0x8052984
	s_argc = argc;
 804c164:	a3 8c 29 05 08       	mov    %eax,0x805298c
	cmd_args_set_defaults(args_struct);
 804c169:	e8 6a fb ff ff       	call   804bcd8 <cmd_args_set_defaults>
 804c16e:	83 c4 10             	add    $0x10,%esp
	for (i = 1; i < argc; i++) {
 804c171:	3b 5d 08             	cmp    0x8(%ebp),%ebx
 804c174:	7d 6d                	jge    804c1e3 <native_handle_cmd_line+0xb0>

		if ((cmd_is_option(argv[i], "testargs", 0))) {
 804c176:	57                   	push   %edi
 804c177:	8d 7b 01             	lea    0x1(%ebx),%edi
 804c17a:	6a 00                	push   $0x0
 804c17c:	68 32 ed 04 08       	push   $0x804ed32
 804c181:	ff 34 9e             	pushl  (%esi,%ebx,4)
 804c184:	e8 9e f8 ff ff       	call   804ba27 <cmd_is_option>
 804c189:	83 c4 10             	add    $0x10,%esp
 804c18c:	85 c0                	test   %eax,%eax
 804c18e:	74 18                	je     804c1a8 <native_handle_cmd_line+0x75>
			test_argc = argc - i - 1;
 804c190:	8b 45 08             	mov    0x8(%ebp),%eax
 804c193:	29 d8                	sub    %ebx,%eax
 804c195:	89 c3                	mov    %eax,%ebx
			test_argv = &argv[i+1];
 804c197:	8d 04 be             	lea    (%esi,%edi,4),%eax
			test_argc = argc - i - 1;
 804c19a:	4b                   	dec    %ebx
			test_argv = &argv[i+1];
 804c19b:	a3 80 29 05 08       	mov    %eax,0x8052980
			test_argc = argc - i - 1;
 804c1a0:	89 1d 88 29 05 08    	mov    %ebx,0x8052988
			break;
 804c1a6:	eb 3b                	jmp    804c1e3 <native_handle_cmd_line+0xb0>
		}

		if (!cmd_parse_one_arg(argv[i], args_struct)) {
 804c1a8:	51                   	push   %ecx
 804c1a9:	51                   	push   %ecx
 804c1aa:	ff 35 7c 29 05 08    	pushl  0x805297c
 804c1b0:	ff 34 9e             	pushl  (%esi,%ebx,4)
 804c1b3:	e8 dc fd ff ff       	call   804bf94 <cmd_parse_one_arg>
 804c1b8:	83 c4 10             	add    $0x10,%esp
 804c1bb:	84 c0                	test   %al,%al
 804c1bd:	75 20                	jne    804c1df <native_handle_cmd_line+0xac>
			cmd_print_switches_help(args_struct);
 804c1bf:	83 ec 0c             	sub    $0xc,%esp
 804c1c2:	ff 35 7c 29 05 08    	pushl  0x805297c
 804c1c8:	e8 b4 fb ff ff       	call   804bd81 <cmd_print_switches_help>
 804c1cd:	58                   	pop    %eax
 804c1ce:	5a                   	pop    %edx
	posix_print_error_and_exit("Incorrect option '%s'. Did you misspell it?"
 804c1cf:	ff 34 9e             	pushl  (%esi,%ebx,4)
 804c1d2:	68 3b ed 04 08       	push   $0x804ed3b
 804c1d7:	e8 12 f7 ff ff       	call   804b8ee <posix_print_error_and_exit>
 804c1dc:	83 c4 10             	add    $0x10,%esp
	for (i = 1; i < argc; i++) {
 804c1df:	89 fb                	mov    %edi,%ebx
 804c1e1:	eb 8e                	jmp    804c171 <native_handle_cmd_line+0x3e>
			print_invalid_opt_error(argv[i]);
		}
	}
}
 804c1e3:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c1e6:	5b                   	pop    %ebx
 804c1e7:	5e                   	pop    %esi
 804c1e8:	5f                   	pop    %edi
 804c1e9:	5d                   	pop    %ebp
 804c1ea:	c3                   	ret    

0804c1eb <arch_busy_wait>:
 *
 * (*1) In reality simulated time is simply not advanced just due to the "MCU"
 * running. Meaning, the SW running on the MCU is assumed to take 0 time.
 */
void arch_busy_wait(uint32_t usec_to_wait)
{
 804c1eb:	f3 0f 1e fb          	endbr32 
 804c1ef:	55                   	push   %ebp
 804c1f0:	89 e5                	mov    %esp,%ebp
 804c1f2:	57                   	push   %edi
	uint64_t time_end = hwm_get_time() + usec_to_wait;
 804c1f3:	31 ff                	xor    %edi,%edi
{
 804c1f5:	56                   	push   %esi
	uint64_t time_end = hwm_get_time() + usec_to_wait;
 804c1f6:	e8 6e ea ff ff       	call   804ac69 <hwm_get_time>
 804c1fb:	8b 75 08             	mov    0x8(%ebp),%esi
 804c1fe:	01 c6                	add    %eax,%esi
 804c200:	11 d7                	adc    %edx,%edi

	while (hwm_get_time() < time_end) {
 804c202:	e8 62 ea ff ff       	call   804ac69 <hwm_get_time>
 804c207:	39 f0                	cmp    %esi,%eax
 804c209:	19 fa                	sbb    %edi,%edx
 804c20b:	73 13                	jae    804c220 <arch_busy_wait+0x35>
		/*
		 * There may be wakes due to other interrupts including
		 * other threads calling arch_busy_wait
		 */
		hwtimer_wake_in_time(time_end);
 804c20d:	50                   	push   %eax
 804c20e:	50                   	push   %eax
 804c20f:	57                   	push   %edi
 804c210:	56                   	push   %esi
 804c211:	e8 82 f0 ff ff       	call   804b298 <hwtimer_wake_in_time>
 804c216:	83 c4 10             	add    $0x10,%esp
		posix_halt_cpu();
 804c219:	e8 5c e6 ff ff       	call   804a87a <posix_halt_cpu>
 804c21e:	eb e2                	jmp    804c202 <arch_busy_wait+0x17>
	}
}
 804c220:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804c223:	5e                   	pop    %esi
 804c224:	5f                   	pop    %edi
 804c225:	5d                   	pop    %ebp
 804c226:	c3                   	ret    

0804c227 <hw_counter_init>:

/**
 * Initialize the counter with prescaler of HW
 */
void hw_counter_init(void)
{
 804c227:	f3 0f 1e fb          	endbr32 
	hw_counter_timer = NEVER;
 804c22b:	c7 05 08 29 05 08 ff 	movl   $0xffffffff,0x8052908
 804c232:	ff ff ff 
 804c235:	c7 05 0c 29 05 08 ff 	movl   $0xffffffff,0x805290c
 804c23c:	ff ff ff 
	counter_target = NEVER;
 804c23f:	c7 05 f8 28 05 08 ff 	movl   $0xffffffff,0x80528f8
 804c246:	ff ff ff 
 804c249:	c7 05 fc 28 05 08 ff 	movl   $0xffffffff,0x80528fc
 804c250:	ff ff ff 
	counter_value = 0;
 804c253:	c7 05 00 29 05 08 00 	movl   $0x0,0x8052900
 804c25a:	00 00 00 
 804c25d:	c7 05 04 29 05 08 00 	movl   $0x0,0x8052904
 804c264:	00 00 00 
	counter_running = false;
 804c267:	c6 05 a2 29 05 08 00 	movb   $0x0,0x80529a2
	counter_period = NEVER;
 804c26e:	c7 05 f0 28 05 08 ff 	movl   $0xffffffff,0x80528f0
 804c275:	ff ff ff 
 804c278:	c7 05 f4 28 05 08 ff 	movl   $0xffffffff,0x80528f4
 804c27f:	ff ff ff 
}
 804c282:	c3                   	ret    

0804c283 <hw_counter_triggered>:

void hw_counter_triggered(void)
{
 804c283:	f3 0f 1e fb          	endbr32 
	if (!counter_running) {
 804c287:	80 3d a2 29 05 08 00 	cmpb   $0x0,0x80529a2
 804c28e:	75 15                	jne    804c2a5 <hw_counter_triggered+0x22>
		hw_counter_timer = NEVER;
 804c290:	c7 05 08 29 05 08 ff 	movl   $0xffffffff,0x8052908
 804c297:	ff ff ff 
 804c29a:	c7 05 0c 29 05 08 ff 	movl   $0xffffffff,0x805290c
 804c2a1:	ff ff ff 
		return;
 804c2a4:	c3                   	ret    
{
 804c2a5:	55                   	push   %ebp
 804c2a6:	89 e5                	mov    %esp,%ebp
 804c2a8:	83 ec 08             	sub    $0x8,%esp
	}

	hw_counter_timer = hwm_get_time() + counter_period;
 804c2ab:	e8 b9 e9 ff ff       	call   804ac69 <hwm_get_time>
 804c2b0:	03 05 f0 28 05 08    	add    0x80528f0,%eax
 804c2b6:	13 15 f4 28 05 08    	adc    0x80528f4,%edx
 804c2bc:	a3 08 29 05 08       	mov    %eax,0x8052908
	counter_value = counter_value + 1;
 804c2c1:	a1 00 29 05 08       	mov    0x8052900,%eax
	hw_counter_timer = hwm_get_time() + counter_period;
 804c2c6:	89 15 0c 29 05 08    	mov    %edx,0x805290c
	counter_value = counter_value + 1;
 804c2cc:	8b 15 04 29 05 08    	mov    0x8052904,%edx
 804c2d2:	83 c0 01             	add    $0x1,%eax
 804c2d5:	83 d2 00             	adc    $0x0,%edx
 804c2d8:	a3 00 29 05 08       	mov    %eax,0x8052900
 804c2dd:	89 15 04 29 05 08    	mov    %edx,0x8052904

	if (counter_value == counter_target) {
 804c2e3:	3b 15 fc 28 05 08    	cmp    0x80528fc,%edx
 804c2e9:	75 15                	jne    804c300 <hw_counter_triggered+0x7d>
 804c2eb:	3b 05 f8 28 05 08    	cmp    0x80528f8,%eax
 804c2f1:	75 0d                	jne    804c300 <hw_counter_triggered+0x7d>
		hw_irq_ctrl_set_irq(COUNTER_EVENT_IRQ);
 804c2f3:	83 ec 0c             	sub    $0xc,%esp
 804c2f6:	6a 02                	push   $0x2
 804c2f8:	e8 ed f3 ff ff       	call   804b6ea <hw_irq_ctrl_set_irq>
 804c2fd:	83 c4 10             	add    $0x10,%esp
	}
}
 804c300:	c9                   	leave  
 804c301:	c3                   	ret    

0804c302 <native_posix_console_init>:
	}
}
#endif /* CONFIG_NATIVE_POSIX_STDIN_CONSOLE */

static int native_posix_console_init(const struct device *arg)
{
 804c302:	f3 0f 1e fb          	endbr32 
 804c306:	55                   	push   %ebp
 804c307:	89 e5                	mov    %esp,%ebp
 804c309:	83 ec 08             	sub    $0x8,%esp
	setvbuf(stdout, NULL, _IOLBF, 512);
 804c30c:	68 00 02 00 00       	push   $0x200
 804c311:	6a 01                	push   $0x1
 804c313:	6a 00                	push   $0x0
 804c315:	ff 35 04 24 05 08    	pushl  0x8052404
 804c31b:	e8 00 d1 ff ff       	call   8049420 <setvbuf@plt>
 804c320:	83 c4 10             	add    $0x10,%esp
	setvbuf(stderr, NULL, _IOLBF, 512);
 804c323:	68 00 02 00 00       	push   $0x200
 804c328:	6a 01                	push   $0x1
 804c32a:	6a 00                	push   $0x0
 804c32c:	ff 35 00 24 05 08    	pushl  0x8052400
 804c332:	e8 e9 d0 ff ff       	call   8049420 <setvbuf@plt>
	__printk_hook_install(putchar);
 804c337:	c7 04 24 40 94 04 08 	movl   $0x8049440,(%esp)
 804c33e:	e8 5d d4 ff ff       	call   80497a0 <__printk_hook_install>
 804c343:	83 c4 10             	add    $0x10,%esp
#if defined(CONFIG_NATIVE_POSIX_STDOUT_CONSOLE)
	native_posix_stdout_init();
#endif

	return 0;
}
 804c346:	31 c0                	xor    %eax,%eax
 804c348:	c9                   	leave  
 804c349:	c3                   	ret    

0804c34a <np_timer_isr>:
/**
 * Interrupt handler for the timer interrupt
 * Announce to the kernel that a number of ticks have passed
 */
static void np_timer_isr(const void *arg)
{
 804c34a:	f3 0f 1e fb          	endbr32 
 804c34e:	55                   	push   %ebp
 804c34f:	89 e5                	mov    %esp,%ebp
 804c351:	57                   	push   %edi
 804c352:	56                   	push   %esi
 804c353:	83 ec 10             	sub    $0x10,%esp
	ARG_UNUSED(arg);

	uint64_t now = hwm_get_time();
 804c356:	e8 0e e9 ff ff       	call   804ac69 <hwm_get_time>
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
 804c35b:	8b 35 10 29 05 08    	mov    0x8052910,%esi
 804c361:	8b 3d 14 29 05 08    	mov    0x8052914,%edi
 804c367:	89 75 e8             	mov    %esi,-0x18(%ebp)
 804c36a:	8b 35 18 29 05 08    	mov    0x8052918,%esi
 804c370:	89 7d ec             	mov    %edi,-0x14(%ebp)
 804c373:	8b 3d 1c 29 05 08    	mov    0x805291c,%edi
 804c379:	2b 45 e8             	sub    -0x18(%ebp),%eax
 804c37c:	1b 55 ec             	sbb    -0x14(%ebp),%edx
 804c37f:	89 75 f0             	mov    %esi,-0x10(%ebp)
 804c382:	57                   	push   %edi
 804c383:	56                   	push   %esi
 804c384:	52                   	push   %edx
 804c385:	50                   	push   %eax
 804c386:	89 7d f4             	mov    %edi,-0xc(%ebp)
 804c389:	e8 62 cf ff ff       	call   80492f0 <__udivdi3@plt>

	last_tick_time += elapsed_ticks*tick_period;
 804c38e:	8b 7d f4             	mov    -0xc(%ebp),%edi
	int32_t elapsed_ticks = (now - last_tick_time)/tick_period;
 804c391:	83 c4 10             	add    $0x10,%esp
 804c394:	89 c1                	mov    %eax,%ecx
	last_tick_time += elapsed_ticks*tick_period;
 804c396:	99                   	cltd   
 804c397:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c39a:	0f af f9             	imul   %ecx,%edi
	sys_clock_announce(elapsed_ticks);
 804c39d:	89 4d 08             	mov    %ecx,0x8(%ebp)
	last_tick_time += elapsed_ticks*tick_period;
 804c3a0:	0f af c2             	imul   %edx,%eax
 804c3a3:	01 c7                	add    %eax,%edi
 804c3a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804c3a8:	f7 e1                	mul    %ecx
 804c3aa:	01 fa                	add    %edi,%edx
 804c3ac:	03 45 e8             	add    -0x18(%ebp),%eax
 804c3af:	13 55 ec             	adc    -0x14(%ebp),%edx
 804c3b2:	a3 10 29 05 08       	mov    %eax,0x8052910
 804c3b7:	89 15 14 29 05 08    	mov    %edx,0x8052914
}
 804c3bd:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804c3c0:	5e                   	pop    %esi
 804c3c1:	5f                   	pop    %edi
 804c3c2:	5d                   	pop    %ebp
	sys_clock_announce(elapsed_ticks);
 804c3c3:	e9 7a 0e 00 00       	jmp    804d242 <sys_clock_announce>

0804c3c8 <sys_clock_driver_init>:
 * @brief Initialize system timer driver
 *
 * Enable the hw timer, setting its tick period, and setup its interrupt
 */
static int sys_clock_driver_init(const struct device *dev)
{
 804c3c8:	f3 0f 1e fb          	endbr32 
 804c3cc:	55                   	push   %ebp
 804c3cd:	89 e5                	mov    %esp,%ebp
 804c3cf:	83 ec 08             	sub    $0x8,%esp
	ARG_UNUSED(dev);

	tick_period = 1000000ul / CONFIG_SYS_CLOCK_TICKS_PER_SEC;
 804c3d2:	c7 05 18 29 05 08 10 	movl   $0x2710,0x8052918
 804c3d9:	27 00 00 
 804c3dc:	c7 05 1c 29 05 08 00 	movl   $0x0,0x805291c
 804c3e3:	00 00 00 

	last_tick_time = hwm_get_time();
 804c3e6:	e8 7e e8 ff ff       	call   804ac69 <hwm_get_time>
 804c3eb:	89 15 14 29 05 08    	mov    %edx,0x8052914
	hwtimer_enable(tick_period);
 804c3f1:	52                   	push   %edx
 804c3f2:	52                   	push   %edx
 804c3f3:	ff 35 1c 29 05 08    	pushl  0x805291c
 804c3f9:	ff 35 18 29 05 08    	pushl  0x8052918
	last_tick_time = hwm_get_time();
 804c3ff:	a3 10 29 05 08       	mov    %eax,0x8052910
	hwtimer_enable(tick_period);
 804c404:	e8 6c ec ff ff       	call   804b075 <hwtimer_enable>
 804c409:	83 c4 10             	add    $0x10,%esp

	IRQ_CONNECT(TIMER_TICK_IRQ, 1, np_timer_isr, 0, 0);
 804c40c:	6a 00                	push   $0x0
 804c40e:	68 4a c3 04 08       	push   $0x804c34a
 804c413:	6a 00                	push   $0x0
 804c415:	6a 00                	push   $0x0
 804c417:	e8 5e f0 ff ff       	call   804b47a <posix_isr_declare>
 804c41c:	83 c4 0c             	add    $0xc,%esp
 804c41f:	6a 00                	push   $0x0
 804c421:	6a 01                	push   $0x1
 804c423:	6a 00                	push   $0x0
 804c425:	e8 7f f0 ff ff       	call   804b4a9 <posix_irq_priority_set>
	irq_enable(TIMER_TICK_IRQ);
 804c42a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804c431:	e8 da dd ff ff       	call   804a210 <arch_irq_enable>
 804c436:	83 c4 10             	add    $0x10,%esp

	return 0;
}
 804c439:	31 c0                	xor    %eax,%eax
 804c43b:	c9                   	leave  
 804c43c:	c3                   	ret    

0804c43d <sys_clock_set_timeout>:
{
 804c43d:	f3 0f 1e fb          	endbr32 
 804c441:	55                   	push   %ebp
		silent_ticks = INT64_MAX;
 804c442:	83 c9 ff             	or     $0xffffffff,%ecx
{
 804c445:	89 e5                	mov    %esp,%ebp
 804c447:	53                   	push   %ebx
		silent_ticks = INT64_MAX;
 804c448:	bb ff ff ff 7f       	mov    $0x7fffffff,%ebx
{
 804c44d:	8b 45 08             	mov    0x8(%ebp),%eax
	if (ticks == K_TICKS_FOREVER) {
 804c450:	83 f8 ff             	cmp    $0xffffffff,%eax
 804c453:	74 10                	je     804c465 <sys_clock_set_timeout+0x28>
		silent_ticks = 0;
 804c455:	31 c9                	xor    %ecx,%ecx
 804c457:	31 db                	xor    %ebx,%ebx
	} else if (ticks > 0) {
 804c459:	85 c0                	test   %eax,%eax
 804c45b:	7e 08                	jle    804c465 <sys_clock_set_timeout+0x28>
		silent_ticks = ticks - 1;
 804c45d:	48                   	dec    %eax
 804c45e:	89 c3                	mov    %eax,%ebx
 804c460:	89 c1                	mov    %eax,%ecx
 804c462:	c1 fb 1f             	sar    $0x1f,%ebx
	hwtimer_set_silent_ticks(silent_ticks);
 804c465:	89 5d 0c             	mov    %ebx,0xc(%ebp)
}
 804c468:	5b                   	pop    %ebx
	hwtimer_set_silent_ticks(silent_ticks);
 804c469:	89 4d 08             	mov    %ecx,0x8(%ebp)
}
 804c46c:	5d                   	pop    %ebp
	hwtimer_set_silent_ticks(silent_ticks);
 804c46d:	e9 5e ee ff ff       	jmp    804b2d0 <hwtimer_set_silent_ticks>

0804c472 <sys_clock_elapsed>:
{
 804c472:	f3 0f 1e fb          	endbr32 
 804c476:	55                   	push   %ebp
 804c477:	89 e5                	mov    %esp,%ebp
 804c479:	83 ec 08             	sub    $0x8,%esp
	return (hwm_get_time() - last_tick_time)/tick_period;
 804c47c:	e8 e8 e7 ff ff       	call   804ac69 <hwm_get_time>
 804c481:	2b 05 10 29 05 08    	sub    0x8052910,%eax
 804c487:	1b 15 14 29 05 08    	sbb    0x8052914,%edx
 804c48d:	ff 35 1c 29 05 08    	pushl  0x805291c
 804c493:	ff 35 18 29 05 08    	pushl  0x8052918
 804c499:	52                   	push   %edx
 804c49a:	50                   	push   %eax
 804c49b:	e8 50 ce ff ff       	call   80492f0 <__udivdi3@plt>
 804c4a0:	83 c4 10             	add    $0x10,%esp
}
 804c4a3:	c9                   	leave  
 804c4a4:	c3                   	ret    

0804c4a5 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
 804c4a5:	f3 0f 1e fb          	endbr32 
 804c4a9:	55                   	push   %ebp
 804c4aa:	89 e5                	mov    %esp,%ebp
 804c4ac:	83 ec 14             	sub    $0x14,%esp
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
 804c4af:	ff 75 08             	pushl  0x8(%ebp)
 804c4b2:	e8 2e dd ff ff       	call   804a1e5 <arch_system_halt>

0804c4b7 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
 804c4b7:	f3 0f 1e fb          	endbr32 
 804c4bb:	55                   	push   %ebp
 804c4bc:	89 e5                	mov    %esp,%ebp
 804c4be:	57                   	push   %edi
 804c4bf:	56                   	push   %esi
 804c4c0:	53                   	push   %ebx
 804c4c1:	83 ec 1c             	sub    $0x1c,%esp
 804c4c4:	8b 55 0c             	mov    0xc(%ebp),%edx
 804c4c7:	8b 7d 08             	mov    0x8(%ebp),%edi
 804c4ca:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	return posix_irq_lock();
 804c4cd:	e8 6a ef ff ff       	call   804b43c <posix_irq_lock>
 804c4d2:	89 c6                	mov    %eax,%esi
	return z_impl_z_current_get();
 804c4d4:	e8 af 09 00 00       	call   804ce88 <z_impl_z_current_get>
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
 804c4d9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804c4dc:	89 c3                	mov    %eax,%ebx
 804c4de:	50                   	push   %eax
 804c4df:	50                   	push   %eax
 804c4e0:	52                   	push   %edx
 804c4e1:	57                   	push   %edi
 804c4e2:	e8 be ff ff ff       	call   804c4a5 <k_sys_fatal_error_handler>
	posix_irq_unlock(key);
 804c4e7:	89 34 24             	mov    %esi,(%esp)
 804c4ea:	e8 63 ef ff ff       	call   804b452 <posix_irq_unlock>
 804c4ef:	83 c4 10             	add    $0x10,%esp
	z_impl_k_thread_abort(thread);
 804c4f2:	89 5d 08             	mov    %ebx,0x8(%ebp)
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
 804c4f5:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c4f8:	5b                   	pop    %ebx
 804c4f9:	5e                   	pop    %esi
 804c4fa:	5f                   	pop    %edi
 804c4fb:	5d                   	pop    %ebp
 804c4fc:	e9 14 e1 ff ff       	jmp    804a615 <z_impl_k_thread_abort>

0804c501 <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
 804c501:	f3 0f 1e fb          	endbr32 
 804c505:	55                   	push   %ebp
 804c506:	89 e5                	mov    %esp,%ebp
 804c508:	83 ec 14             	sub    $0x14,%esp
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
 804c50b:	c6 05 a3 29 05 08 01 	movb   $0x1,0x80529a3

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
 804c512:	6a 02                	push   $0x2
 804c514:	e8 bc 0e 00 00       	call   804d3d5 <z_sys_init_run_level>
 804c519:	83 c4 10             	add    $0x10,%esp
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
 804c51c:	e8 8c 0e 00 00       	call   804d3ad <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
 804c521:	83 ec 0c             	sub    $0xc,%esp
 804c524:	6a 03                	push   $0x3
 804c526:	e8 aa 0e 00 00       	call   804d3d5 <z_sys_init_run_level>
 804c52b:	83 c4 10             	add    $0x10,%esp

	z_init_static_threads();
 804c52e:	e8 cf 01 00 00       	call   804c702 <z_init_static_threads>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern void main(void);

	main();
 804c533:	e8 19 d2 ff ff       	call   8049751 <zephyr_app_main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
 804c538:	80 25 0c 28 05 08 fe 	andb   $0xfe,0x805280c

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 804c53f:	c9                   	leave  
 804c540:	c3                   	ret    

0804c541 <z_init_cpu>:
	thread->base.is_idle = 1U;
#endif
}

void z_init_cpu(int id)
{
 804c541:	f3 0f 1e fb          	endbr32 
 804c545:	55                   	push   %ebp
 804c546:	89 e5                	mov    %esp,%ebp
 804c548:	57                   	push   %edi
 804c549:	56                   	push   %esi
 804c54a:	53                   	push   %ebx
 804c54b:	83 ec 14             	sub    $0x14,%esp
 804c54e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	z_setup_new_thread(thread, stack,
 804c551:	6a 00                	push   $0x0
	struct k_thread *thread = &z_idle_threads[i];
 804c553:	6b fb 50             	imul   $0x50,%ebx,%edi
	k_thread_stack_t *stack = z_idle_stacks[i];
 804c556:	89 d8                	mov    %ebx,%eax
	z_setup_new_thread(thread, stack,
 804c558:	6a 01                	push   $0x1
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
 804c55a:	6b f3 18             	imul   $0x18,%ebx,%esi
	k_thread_stack_t *stack = z_idle_stacks[i];
 804c55d:	c1 e0 08             	shl    $0x8,%eax
	z_setup_new_thread(thread, stack,
 804c560:	6a 0f                	push   $0xf
	k_thread_stack_t *stack = z_idle_stacks[i];
 804c562:	05 7c 1e 05 08       	add    $0x8051e7c,%eax
	z_setup_new_thread(thread, stack,
 804c567:	6a 00                	push   $0x0
	struct k_thread *thread = &z_idle_threads[i];
 804c569:	81 c7 a0 27 05 08    	add    $0x80527a0,%edi
	z_setup_new_thread(thread, stack,
 804c56f:	6a 00                	push   $0x0
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
 804c571:	81 c6 60 28 05 08    	add    $0x8052860,%esi
	z_setup_new_thread(thread, stack,
 804c577:	56                   	push   %esi
 804c578:	68 bb c7 04 08       	push   $0x804c7bb
 804c57d:	68 00 01 00 00       	push   $0x100
 804c582:	50                   	push   %eax
 804c583:	57                   	push   %edi
 804c584:	e8 f2 00 00 00       	call   804c67b <z_setup_new_thread>
	init_idle_thread(id);
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
	_kernel.cpus[id].id = id;
 804c589:	88 5e 14             	mov    %bl,0x14(%esi)
	_kernel.cpus[id].irq_stack =
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 804c58c:	c1 e3 0b             	shl    $0xb,%ebx
	z_setup_new_thread(thread, stack,
 804c58f:	83 c4 30             	add    $0x30,%esp
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 804c592:	8d 83 7c 1e 05 08    	lea    0x8051e7c(%ebx),%eax
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
 804c598:	80 67 0d fb          	andb   $0xfb,0xd(%edi)
	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
 804c59c:	89 7e 0c             	mov    %edi,0xc(%esi)
		(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 804c59f:	89 46 04             	mov    %eax,0x4(%esi)
		 K_KERNEL_STACK_SIZEOF(z_interrupt_stacks[id]));
#ifdef CONFIG_SCHED_THREAD_USAGE_ALL
	_kernel.cpus[id].usage.track_usage =
		CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE;
#endif
}
 804c5a2:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c5a5:	5b                   	pop    %ebx
 804c5a6:	5e                   	pop    %esi
 804c5a7:	5f                   	pop    %edi
 804c5a8:	5d                   	pop    %ebp
 804c5a9:	c3                   	ret    

0804c5aa <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
 804c5aa:	f3 0f 1e fb          	endbr32 
 804c5ae:	55                   	push   %ebp
 804c5af:	89 e5                	mov    %esp,%ebp
 804c5b1:	53                   	push   %ebx
 804c5b2:	83 ec 64             	sub    $0x64,%esp
 804c5b5:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
 804c5bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804c5be:	31 c0                	xor    %eax,%eax
	k_thread_system_pool_assign(dummy_thread);
#else
	dummy_thread->resource_pool = NULL;
#endif

	_current_cpu->current = dummy_thread;
 804c5c0:	8d 45 a4             	lea    -0x5c(%ebp),%eax
	dummy_thread->base.user_options = K_ESSENTIAL;
 804c5c3:	66 c7 45 b0 01 01    	movw   $0x101,-0x50(%ebp)
	_current_cpu->current = dummy_thread;
 804c5c9:	a3 68 28 05 08       	mov    %eax,0x8052868
	dummy_thread->resource_pool = NULL;
 804c5ce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
 804c5d5:	e8 f6 0d 00 00       	call   804d3d0 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
 804c5da:	83 ec 0c             	sub    $0xc,%esp
 804c5dd:	6a 00                	push   $0x0
 804c5df:	e8 f1 0d 00 00       	call   804d3d5 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
 804c5e4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804c5eb:	e8 e5 0d 00 00       	call   804d3d5 <z_sys_init_run_level>
 804c5f0:	83 c4 10             	add    $0x10,%esp
	z_sched_init();
 804c5f3:	e8 df 06 00 00       	call   804ccd7 <z_sched_init>
	_kernel.ready_q.cache = &z_main_thread;
 804c5f8:	c7 05 78 28 05 08 00 	movl   $0x8052800,0x8052878
 804c5ff:	28 05 08 
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 804c602:	50                   	push   %eax
 804c603:	50                   	push   %eax
 804c604:	68 f7 ed 04 08       	push   $0x804edf7
 804c609:	6a 01                	push   $0x1
 804c60b:	6a 00                	push   $0x0
 804c60d:	6a 00                	push   $0x0
 804c60f:	6a 00                	push   $0x0
 804c611:	6a 00                	push   $0x0
 804c613:	68 01 c5 04 08       	push   $0x804c501
 804c618:	68 00 04 00 00       	push   $0x400
 804c61d:	68 7c 1f 05 08       	push   $0x8051f7c
 804c622:	68 00 28 05 08       	push   $0x8052800
 804c627:	e8 4f 00 00 00       	call   804c67b <z_setup_new_thread>
 804c62c:	83 c4 24             	add    $0x24,%esp
 804c62f:	80 25 0d 28 05 08 fb 	andb   $0xfb,0x805280d
	z_ready_thread(&z_main_thread);
 804c636:	68 00 28 05 08       	push   $0x8052800
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 804c63b:	89 c3                	mov    %eax,%ebx
	z_ready_thread(&z_main_thread);
 804c63d:	e8 1b 05 00 00       	call   804cb5d <z_ready_thread>
	z_init_cpu(0);
 804c642:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 804c649:	e8 f3 fe ff ff       	call   804c541 <z_init_cpu>
 804c64e:	83 c4 0c             	add    $0xc,%esp
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
 804c651:	68 01 c5 04 08       	push   $0x804c501
 804c656:	53                   	push   %ebx
 804c657:	68 00 28 05 08       	push   $0x8052800
 804c65c:	e8 93 e0 ff ff       	call   804a6f4 <arch_switch_to_main_thread>
 804c661:	83 c4 0c             	add    $0xc,%esp
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 804c664:	68 69 01 00 00       	push   $0x169
 804c669:	68 fc ed 04 08       	push   $0x804edfc
 804c66e:	68 cd e1 04 08       	push   $0x804e1cd
 804c673:	e8 76 f2 ff ff       	call   804b8ee <posix_print_error_and_exit>
 804c678:	83 c4 10             	add    $0x10,%esp

0804c67b <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
 804c67b:	f3 0f 1e fb          	endbr32 
 804c67f:	55                   	push   %ebp
 804c680:	89 e5                	mov    %esp,%ebp
 804c682:	53                   	push   %ebx
 804c683:	83 ec 18             	sub    $0x18,%esp
 804c686:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804c689:	8b 55 0c             	mov    0xc(%ebp),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
 804c68c:	8d 43 3c             	lea    0x3c(%ebx),%eax

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
 804c68f:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
 * @param list the doubly-linked list
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
 804c696:	89 43 3c             	mov    %eax,0x3c(%ebx)
	list->tail = (sys_dnode_t *)list;
 804c699:	89 43 40             	mov    %eax,0x40(%ebx)
	thread_base->user_options = (uint8_t)options;
 804c69c:	8b 45 28             	mov    0x28(%ebp),%eax
	thread_base->thread_state = (uint8_t)initial_state;
 804c69f:	c6 43 0d 04          	movb   $0x4,0xd(%ebx)
	thread_base->user_options = (uint8_t)options;
 804c6a3:	88 43 0c             	mov    %al,0xc(%ebx)

	thread_base->prio = priority;
 804c6a6:	8b 45 24             	mov    0x24(%ebp),%eax

	thread_base->sched_locked = 0U;
 804c6a9:	c6 43 0f 00          	movb   $0x0,0xf(%ebx)
	thread_base->prio = priority;
 804c6ad:	88 43 0e             	mov    %al,0xe(%ebx)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
 804c6b0:	8b 45 10             	mov    0x10(%ebp),%eax
 * @param node the node
 */

static inline void sys_dnode_init(sys_dnode_t *node)
{
	node->next = NULL;
 804c6b3:	c7 43 18 00 00 00 00 	movl   $0x0,0x18(%ebx)
 804c6ba:	83 c0 03             	add    $0x3,%eax
	node->prev = NULL;
 804c6bd:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
 804c6c4:	83 e0 fc             	and    $0xfffffffc,%eax
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 804c6c7:	ff 75 20             	pushl  0x20(%ebp)
	stack_ptr = (char *)stack + stack_obj_size;
 804c6ca:	01 d0                	add    %edx,%eax
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 804c6cc:	ff 75 1c             	pushl  0x1c(%ebp)
 804c6cf:	ff 75 18             	pushl  0x18(%ebp)
 804c6d2:	ff 75 14             	pushl  0x14(%ebp)
 804c6d5:	50                   	push   %eax
 804c6d6:	52                   	push   %edx
 804c6d7:	53                   	push   %ebx
 804c6d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804c6db:	e8 34 e0 ff ff       	call   804a714 <arch_new_thread>
	if (!_current) {
 804c6e0:	8b 15 68 28 05 08    	mov    0x8052868,%edx
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 804c6e6:	83 c4 20             	add    $0x20,%esp
	if (!_current) {
 804c6e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
	new_thread->init_data = NULL;
 804c6ec:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
	if (!_current) {
 804c6f3:	85 d2                	test   %edx,%edx
 804c6f5:	74 03                	je     804c6fa <z_setup_new_thread+0x7f>
	new_thread->resource_pool = _current->resource_pool;
 804c6f7:	8b 52 48             	mov    0x48(%edx),%edx
	return stack_ptr;
 804c6fa:	89 53 48             	mov    %edx,0x48(%ebx)
}
 804c6fd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804c700:	c9                   	leave  
 804c701:	c3                   	ret    

0804c702 <z_init_static_threads>:
{
 804c702:	f3 0f 1e fb          	endbr32 
 804c706:	55                   	push   %ebp
 804c707:	89 e5                	mov    %esp,%ebp
 804c709:	56                   	push   %esi
 804c70a:	53                   	push   %ebx
	_FOREACH_STATIC_THREAD(thread_data) {
 804c70b:	bb 98 23 05 08       	mov    $0x8052398,%ebx
 804c710:	81 fb f8 23 05 08    	cmp    $0x80523f8,%ebx
 804c716:	73 31                	jae    804c749 <z_init_static_threads+0x47>
		z_setup_new_thread(
 804c718:	50                   	push   %eax
 804c719:	50                   	push   %eax
 804c71a:	ff 73 2c             	pushl  0x2c(%ebx)
 804c71d:	ff 73 20             	pushl  0x20(%ebx)
 804c720:	ff 73 1c             	pushl  0x1c(%ebx)
 804c723:	ff 73 18             	pushl  0x18(%ebx)
 804c726:	ff 73 14             	pushl  0x14(%ebx)
 804c729:	ff 73 10             	pushl  0x10(%ebx)
 804c72c:	ff 73 0c             	pushl  0xc(%ebx)
 804c72f:	ff 73 08             	pushl  0x8(%ebx)
 804c732:	ff 73 04             	pushl  0x4(%ebx)
 804c735:	ff 33                	pushl  (%ebx)
 804c737:	e8 3f ff ff ff       	call   804c67b <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
 804c73c:	8b 03                	mov    (%ebx),%eax
		z_setup_new_thread(
 804c73e:	83 c4 30             	add    $0x30,%esp
		thread_data->init_thread->init_data = thread_data;
 804c741:	89 58 38             	mov    %ebx,0x38(%eax)
	_FOREACH_STATIC_THREAD(thread_data) {
 804c744:	83 c3 30             	add    $0x30,%ebx
 804c747:	eb c7                	jmp    804c710 <z_init_static_threads+0xe>
	k_sched_lock();
 804c749:	e8 f3 01 00 00       	call   804c941 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
 804c74e:	bb 98 23 05 08       	mov    $0x8052398,%ebx
 804c753:	81 fb f8 23 05 08    	cmp    $0x80523f8,%ebx
 804c759:	73 55                	jae    804c7b0 <z_init_static_threads+0xae>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
 804c75b:	8b 43 24             	mov    0x24(%ebx),%eax
 804c75e:	83 f8 ff             	cmp    $0xffffffff,%eax
 804c761:	74 48                	je     804c7ab <z_init_static_threads+0xa9>
					    K_MSEC(thread_data->init_delay));
 804c763:	85 c0                	test   %eax,%eax
 804c765:	ba 00 00 00 00       	mov    $0x0,%edx
			schedule_new_thread(thread_data->init_thread,
 804c76a:	8b 33                	mov    (%ebx),%esi
					    K_MSEC(thread_data->init_delay));
 804c76c:	0f 48 c2             	cmovs  %edx,%eax
 804c76f:	99                   	cltd   
	 * the same mathematical relationship, each expressed with and
	 * without truncation to 32 bits (I couldn't find a way to make
	 * the compiler correctly guess at the 32 bit result otherwise).
	 */
	if (div_ratio) {
		t += off;
 804c770:	83 c0 09             	add    $0x9,%eax
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 804c773:	89 c1                	mov    %eax,%ecx
 804c775:	83 d2 00             	adc    $0x0,%edx
 804c778:	83 f1 09             	xor    $0x9,%ecx
 804c77b:	09 d1                	or     %edx,%ecx
 804c77d:	75 0b                	jne    804c78a <z_init_static_threads+0x88>
	z_sched_start(thread);
 804c77f:	83 ec 0c             	sub    $0xc,%esp
 804c782:	56                   	push   %esi
 804c783:	e8 fa 03 00 00       	call   804cb82 <z_sched_start>
 804c788:	eb 1e                	jmp    804c7a8 <z_init_static_threads+0xa6>
		if (result32 && (t < BIT64(32))) {
			return ((uint32_t)t) / (from_hz / to_hz);
		} else {
			return t / ((uint64_t)from_hz / to_hz);
 804c78a:	6a 00                	push   $0x0

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 804c78c:	83 c6 18             	add    $0x18,%esi
 804c78f:	6a 0a                	push   $0xa
 804c791:	52                   	push   %edx
 804c792:	50                   	push   %eax
 804c793:	e8 58 cb ff ff       	call   80492f0 <__udivdi3@plt>
 804c798:	83 c4 10             	add    $0x10,%esp
 804c79b:	52                   	push   %edx
 804c79c:	50                   	push   %eax
 804c79d:	68 ce cb 04 08       	push   $0x804cbce
 804c7a2:	56                   	push   %esi
 804c7a3:	e8 98 08 00 00       	call   804d040 <z_add_timeout>
 804c7a8:	83 c4 10             	add    $0x10,%esp
	_FOREACH_STATIC_THREAD(thread_data) {
 804c7ab:	83 c3 30             	add    $0x30,%ebx
 804c7ae:	eb a3                	jmp    804c753 <z_init_static_threads+0x51>
}
 804c7b0:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804c7b3:	5b                   	pop    %ebx
 804c7b4:	5e                   	pop    %esi
 804c7b5:	5d                   	pop    %ebp
	k_sched_unlock();
 804c7b6:	e9 e8 04 00 00       	jmp    804cca3 <k_sched_unlock>

0804c7bb <idle>:
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
}

void idle(void *unused1, void *unused2, void *unused3)
{
 804c7bb:	f3 0f 1e fb          	endbr32 
 804c7bf:	55                   	push   %ebp
 804c7c0:	89 e5                	mov    %esp,%ebp
 804c7c2:	83 ec 08             	sub    $0x8,%esp
	return posix_irq_lock();
 804c7c5:	e8 72 ec ff ff       	call   804b43c <posix_irq_lock>
 * @note In some architectures, before returning, the function unmasks interrupts
 * unconditionally.
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
 804c7ca:	e8 fc d9 ff ff       	call   804a1cb <arch_cpu_idle>
 804c7cf:	eb f4                	jmp    804c7c5 <idle+0xa>

0804c7d1 <sys_dlist_remove>:
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
 804c7d1:	8b 48 04             	mov    0x4(%eax),%ecx
	sys_dnode_t *const next = node->next;
 804c7d4:	8b 10                	mov    (%eax),%edx

	prev->next = next;
 804c7d6:	89 11                	mov    %edx,(%ecx)
	next->prev = prev;
 804c7d8:	89 4a 04             	mov    %ecx,0x4(%edx)
	node->next = NULL;
 804c7db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	node->prev = NULL;
 804c7e1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	sys_dnode_init(node);
}
 804c7e8:	c3                   	ret    

0804c7e9 <unpend_thread_no_timeout>:
	__ASSERT_NO_MSG(thread == _current || is_thread_dummy(thread));
	pend(thread, wait_q, timeout);
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
 804c7e9:	55                   	push   %ebp
 804c7ea:	89 e5                	mov    %esp,%ebp
 804c7ec:	83 ec 08             	sub    $0x8,%esp

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
 804c7ef:	e8 dd ff ff ff       	call   804c7d1 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_PENDING;
}

static inline void z_mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
 804c7f4:	80 60 0d fd          	andb   $0xfd,0xd(%eax)
	thread->base.pended_on = NULL;
 804c7f8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
 804c7ff:	c9                   	leave  
 804c800:	c3                   	ret    

0804c801 <z_reset_time_slice>:
{
 804c801:	f3 0f 1e fb          	endbr32 
 804c805:	55                   	push   %ebp
 804c806:	89 e5                	mov    %esp,%ebp
 804c808:	53                   	push   %ebx
 804c809:	52                   	push   %edx
	int ret = slice_ticks;
 804c80a:	8b 1d 94 29 05 08    	mov    0x8052994,%ebx
	if (slice_time(curr) != 0) {
 804c810:	85 db                	test   %ebx,%ebx
 804c812:	74 1f                	je     804c833 <z_reset_time_slice+0x32>
		_current_cpu->slice_ticks = slice_time(curr) + sys_clock_elapsed();
 804c814:	e8 59 fc ff ff       	call   804c472 <sys_clock_elapsed>
 804c819:	01 c3                	add    %eax,%ebx
		z_set_timeout_expiry(slice_time(curr), false);
 804c81b:	50                   	push   %eax
 804c81c:	50                   	push   %eax
 804c81d:	6a 00                	push   $0x0
 804c81f:	ff 35 94 29 05 08    	pushl  0x8052994
		_current_cpu->slice_ticks = slice_time(curr) + sys_clock_elapsed();
 804c825:	89 1d 70 28 05 08    	mov    %ebx,0x8052870
		z_set_timeout_expiry(slice_time(curr), false);
 804c82b:	e8 ba 09 00 00       	call   804d1ea <z_set_timeout_expiry>
 804c830:	83 c4 10             	add    $0x10,%esp
}
 804c833:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804c836:	c9                   	leave  
 804c837:	c3                   	ret    

0804c838 <k_sched_time_slice_set>:
{
 804c838:	f3 0f 1e fb          	endbr32 
 804c83c:	55                   	push   %ebp
 804c83d:	89 e5                	mov    %esp,%ebp
 804c83f:	57                   	push   %edi
 804c840:	56                   	push   %esi
 804c841:	53                   	push   %ebx
 804c842:	83 ec 0c             	sub    $0xc,%esp
 804c845:	8b 75 08             	mov    0x8(%ebp),%esi
 804c848:	8b 7d 0c             	mov    0xc(%ebp),%edi
 804c84b:	e8 ec eb ff ff       	call   804b43c <posix_irq_lock>
 * @return The converted time value
 */
static TIME_CONSTEXPR inline uint32_t k_ms_to_ticks_ceil32(uint32_t t)
{
	/* Generated.  Do not edit.  See above. */
	return z_tmcvt(t, Z_HZ_ms, Z_HZ_ticks, true, true, true, false);
 804c850:	31 d2                	xor    %edx,%edx
		_current_cpu->slice_ticks = 0;
 804c852:	c7 05 70 28 05 08 00 	movl   $0x0,0x8052870
 804c859:	00 00 00 
 804c85c:	89 c3                	mov    %eax,%ebx
 804c85e:	89 f0                	mov    %esi,%eax
		t += off;
 804c860:	83 c0 09             	add    $0x9,%eax
 804c863:	83 d2 00             	adc    $0x0,%edx
		if (result32 && (t < BIT64(32))) {
 804c866:	83 fa 00             	cmp    $0x0,%edx
 804c869:	77 0e                	ja     804c879 <k_sched_time_slice_set+0x41>
			return ((uint32_t)t) / (from_hz / to_hz);
 804c86b:	8d 46 09             	lea    0x9(%esi),%eax
 804c86e:	b9 0a 00 00 00       	mov    $0xa,%ecx
 804c873:	31 d2                	xor    %edx,%edx
 804c875:	f7 f1                	div    %ecx
 804c877:	eb 0e                	jmp    804c887 <k_sched_time_slice_set+0x4f>
			return t / ((uint64_t)from_hz / to_hz);
 804c879:	6a 00                	push   $0x0
 804c87b:	6a 0a                	push   $0xa
 804c87d:	52                   	push   %edx
 804c87e:	50                   	push   %eax
 804c87f:	e8 6c ca ff ff       	call   80492f0 <__udivdi3@plt>
 804c884:	83 c4 10             	add    $0x10,%esp
		slice_ticks = k_ms_to_ticks_ceil32(slice);
 804c887:	89 c1                	mov    %eax,%ecx
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
 804c889:	85 f6                	test   %esi,%esi
 804c88b:	7f 07                	jg     804c894 <k_sched_time_slice_set+0x5c>
		slice_ticks = k_ms_to_ticks_ceil32(slice);
 804c88d:	a3 94 29 05 08       	mov    %eax,0x8052994
 804c892:	eb 11                	jmp    804c8a5 <k_sched_time_slice_set+0x6d>
			slice_ticks = MAX(2, slice_ticks);
 804c894:	83 f8 02             	cmp    $0x2,%eax
 804c897:	b8 02 00 00 00       	mov    $0x2,%eax
 804c89c:	0f 4c c8             	cmovl  %eax,%ecx
 804c89f:	89 0d 94 29 05 08    	mov    %ecx,0x8052994
		z_reset_time_slice(_current);
 804c8a5:	83 ec 0c             	sub    $0xc,%esp
 804c8a8:	ff 35 68 28 05 08    	pushl  0x8052868
		slice_max_prio = prio;
 804c8ae:	89 3d 90 29 05 08    	mov    %edi,0x8052990
		z_reset_time_slice(_current);
 804c8b4:	e8 48 ff ff ff       	call   804c801 <z_reset_time_slice>
	posix_irq_unlock(key);
 804c8b9:	89 5d 08             	mov    %ebx,0x8(%ebp)
 804c8bc:	83 c4 10             	add    $0x10,%esp
}
 804c8bf:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804c8c2:	5b                   	pop    %ebx
 804c8c3:	5e                   	pop    %esi
 804c8c4:	5f                   	pop    %edi
 804c8c5:	5d                   	pop    %ebp
 804c8c6:	e9 87 eb ff ff       	jmp    804b452 <posix_irq_unlock>

0804c8cb <z_reschedule>:
{
 804c8cb:	f3 0f 1e fb          	endbr32 
 804c8cf:	55                   	push   %ebp
 804c8d0:	89 e5                	mov    %esp,%ebp
 804c8d2:	8b 45 0c             	mov    0xc(%ebp),%eax
	if (resched(key.key) && need_swap()) {
 804c8d5:	89 c2                	mov    %eax,%edx
 804c8d7:	0b 15 60 28 05 08    	or     0x8052860,%edx
 804c8dd:	75 1b                	jne    804c8fa <z_reschedule+0x2f>
 804c8df:	8b 0d 68 28 05 08    	mov    0x8052868,%ecx
 804c8e5:	39 0d 78 28 05 08    	cmp    %ecx,0x8052878
 804c8eb:	74 0d                	je     804c8fa <z_reschedule+0x2f>
	ret = arch_swap(key);
 804c8ed:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
}
 804c8f4:	5d                   	pop    %ebp
 804c8f5:	e9 a6 dd ff ff       	jmp    804a6a0 <arch_swap>
 804c8fa:	89 45 08             	mov    %eax,0x8(%ebp)
 804c8fd:	5d                   	pop    %ebp
 804c8fe:	e9 4f eb ff ff       	jmp    804b452 <posix_irq_unlock>

0804c903 <z_reschedule_irqlock>:
{
 804c903:	f3 0f 1e fb          	endbr32 
 804c907:	55                   	push   %ebp
 804c908:	89 e5                	mov    %esp,%ebp
	if (resched(key)) {
 804c90a:	8b 45 08             	mov    0x8(%ebp),%eax
 804c90d:	0b 05 60 28 05 08    	or     0x8052860,%eax
 804c913:	75 0d                	jne    804c922 <z_reschedule_irqlock+0x1f>
 804c915:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
}
 804c91c:	5d                   	pop    %ebp
 804c91d:	e9 7e dd ff ff       	jmp    804a6a0 <arch_swap>
 804c922:	5d                   	pop    %ebp
 804c923:	e9 2a eb ff ff       	jmp    804b452 <posix_irq_unlock>

0804c928 <z_reschedule_unlocked>:
{
 804c928:	55                   	push   %ebp
 804c929:	89 e5                	mov    %esp,%ebp
 804c92b:	83 ec 08             	sub    $0x8,%esp
	return posix_irq_lock();
 804c92e:	e8 09 eb ff ff       	call   804b43c <posix_irq_lock>
	(void) z_reschedule_irqlock(arch_irq_lock());
 804c933:	83 ec 0c             	sub    $0xc,%esp
 804c936:	50                   	push   %eax
 804c937:	e8 c7 ff ff ff       	call   804c903 <z_reschedule_irqlock>
 804c93c:	83 c4 10             	add    $0x10,%esp
}
 804c93f:	c9                   	leave  
 804c940:	c3                   	ret    

0804c941 <k_sched_lock>:
{
 804c941:	f3 0f 1e fb          	endbr32 
 804c945:	55                   	push   %ebp
 804c946:	89 e5                	mov    %esp,%ebp
 804c948:	83 ec 08             	sub    $0x8,%esp
 804c94b:	e8 ec ea ff ff       	call   804b43c <posix_irq_lock>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
 804c950:	8b 15 68 28 05 08    	mov    0x8052868,%edx
 804c956:	fe 4a 0f             	decb   0xf(%edx)
	posix_irq_unlock(key);
 804c959:	83 ec 0c             	sub    $0xc,%esp
 804c95c:	50                   	push   %eax
 804c95d:	e8 f0 ea ff ff       	call   804b452 <posix_irq_unlock>
 804c962:	83 c4 10             	add    $0x10,%esp
}
 804c965:	c9                   	leave  
 804c966:	c3                   	ret    

0804c967 <z_priq_dumb_best>:
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
 804c967:	f3 0f 1e fb          	endbr32 
 804c96b:	55                   	push   %ebp
 804c96c:	89 e5                	mov    %esp,%ebp
 804c96e:	8b 55 08             	mov    0x8(%ebp),%edx
	return list->head == list;
 804c971:	8b 02                	mov    (%edx),%eax
	struct k_thread *thread = NULL;
	sys_dnode_t *n = sys_dlist_peek_head(pq);

	if (n != NULL) {
 804c973:	85 c0                	test   %eax,%eax
 804c975:	74 04                	je     804c97b <z_priq_dumb_best+0x14>
 804c977:	39 c2                	cmp    %eax,%edx
 804c979:	75 02                	jne    804c97d <z_priq_dumb_best+0x16>
	struct k_thread *thread = NULL;
 804c97b:	31 c0                	xor    %eax,%eax
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
 804c97d:	5d                   	pop    %ebp
 804c97e:	c3                   	ret    

0804c97f <update_cache>:
{
 804c97f:	55                   	push   %ebp
 804c980:	89 c1                	mov    %eax,%ecx
 804c982:	89 e5                	mov    %esp,%ebp
 804c984:	53                   	push   %ebx
 804c985:	83 ec 10             	sub    $0x10,%esp
	return _priq_run_best(curr_cpu_runq());
 804c988:	68 7c 28 05 08       	push   $0x805287c
 804c98d:	e8 d5 ff ff ff       	call   804c967 <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 804c992:	8b 1d 6c 28 05 08    	mov    0x805286c,%ebx
	return _priq_run_best(curr_cpu_runq());
 804c998:	83 c4 10             	add    $0x10,%esp
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 804c99b:	85 c0                	test   %eax,%eax
 804c99d:	74 02                	je     804c9a1 <update_cache+0x22>
 804c99f:	89 c3                	mov    %eax,%ebx
	if (preempt_ok != 0) {
 804c9a1:	a1 68 28 05 08       	mov    0x8052868,%eax
 804c9a6:	85 c9                	test   %ecx,%ecx
 804c9a8:	75 14                	jne    804c9be <update_cache+0x3f>
	if (z_is_thread_prevented_from_running(_current)) {
 804c9aa:	f6 40 0d 1f          	testb  $0x1f,0xd(%eax)
 804c9ae:	75 0e                	jne    804c9be <update_cache+0x3f>
	if (is_preempt(_current) || is_metairq(thread)) {
 804c9b0:	66 83 78 0e 7f       	cmpw   $0x7f,0xe(%eax)
 804c9b5:	76 07                	jbe    804c9be <update_cache+0x3f>
		_kernel.ready_q.cache = _current;
 804c9b7:	a3 78 28 05 08       	mov    %eax,0x8052878
 804c9bc:	eb 16                	jmp    804c9d4 <update_cache+0x55>
		if (thread != _current) {
 804c9be:	39 c3                	cmp    %eax,%ebx
 804c9c0:	74 0c                	je     804c9ce <update_cache+0x4f>
			z_reset_time_slice(thread);
 804c9c2:	83 ec 0c             	sub    $0xc,%esp
 804c9c5:	53                   	push   %ebx
 804c9c6:	e8 36 fe ff ff       	call   804c801 <z_reset_time_slice>
 804c9cb:	83 c4 10             	add    $0x10,%esp
		_kernel.ready_q.cache = thread;
 804c9ce:	89 1d 78 28 05 08    	mov    %ebx,0x8052878
}
 804c9d4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804c9d7:	c9                   	leave  
 804c9d8:	c3                   	ret    

0804c9d9 <move_thread_to_end_of_prio_q>:
{
 804c9d9:	55                   	push   %ebp
 804c9da:	89 e5                	mov    %esp,%ebp
 804c9dc:	56                   	push   %esi
 804c9dd:	53                   	push   %ebx
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
 804c9de:	8a 50 0d             	mov    0xd(%eax),%dl
	if (z_is_thread_queued(thread)) {
 804c9e1:	84 d2                	test   %dl,%dl
 804c9e3:	79 0b                	jns    804c9f0 <move_thread_to_end_of_prio_q+0x17>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 804c9e5:	83 e2 7f             	and    $0x7f,%edx
 804c9e8:	88 50 0d             	mov    %dl,0xd(%eax)
	sys_dlist_remove(&thread->base.qnode_dlist);
 804c9eb:	e8 e1 fd ff ff       	call   804c7d1 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_QUEUED;
 804c9f0:	80 48 0d 80          	orb    $0x80,0xd(%eax)
 804c9f4:	8b 15 7c 28 05 08    	mov    0x805287c,%edx
 804c9fa:	8b 1d 80 28 05 08    	mov    0x8052880,%ebx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804ca00:	85 d2                	test   %edx,%edx
 804ca02:	74 33                	je     804ca37 <move_thread_to_end_of_prio_q+0x5e>
 804ca04:	81 fa 7c 28 05 08    	cmp    $0x805287c,%edx
 804ca0a:	74 2b                	je     804ca37 <move_thread_to_end_of_prio_q+0x5e>
	int32_t b1 = thread_1->base.prio;
 804ca0c:	0f be 70 0e          	movsbl 0xe(%eax),%esi
	int32_t b2 = thread_2->base.prio;
 804ca10:	0f be 4a 0e          	movsbl 0xe(%edx),%ecx
	if (b1 != b2) {
 804ca14:	39 ce                	cmp    %ecx,%esi
 804ca16:	74 15                	je     804ca2d <move_thread_to_end_of_prio_q+0x54>
		return b2 - b1;
 804ca18:	29 f1                	sub    %esi,%ecx
		if (z_sched_prio_cmp(thread, t) > 0) {
 804ca1a:	85 c9                	test   %ecx,%ecx
 804ca1c:	7e 0f                	jle    804ca2d <move_thread_to_end_of_prio_q+0x54>
	sys_dnode_t *const prev = successor->prev;
 804ca1e:	8b 4a 04             	mov    0x4(%edx),%ecx
	node->next = successor;
 804ca21:	89 10                	mov    %edx,(%eax)
	node->prev = prev;
 804ca23:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = node;
 804ca26:	89 01                	mov    %eax,(%ecx)
	successor->prev = node;
 804ca28:	89 42 04             	mov    %eax,0x4(%edx)
}
 804ca2b:	eb 1a                	jmp    804ca47 <move_thread_to_end_of_prio_q+0x6e>
	return (node == list->tail) ? NULL : node->next;
 804ca2d:	39 da                	cmp    %ebx,%edx
 804ca2f:	74 06                	je     804ca37 <move_thread_to_end_of_prio_q+0x5e>
 804ca31:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804ca33:	85 d2                	test   %edx,%edx
 804ca35:	75 d9                	jne    804ca10 <move_thread_to_end_of_prio_q+0x37>
	node->next = list;
 804ca37:	c7 00 7c 28 05 08    	movl   $0x805287c,(%eax)
	node->prev = tail;
 804ca3d:	89 58 04             	mov    %ebx,0x4(%eax)
	tail->next = node;
 804ca40:	89 03                	mov    %eax,(%ebx)
	list->tail = node;
 804ca42:	a3 80 28 05 08       	mov    %eax,0x8052880
	update_cache(thread == _current);
 804ca47:	39 05 68 28 05 08    	cmp    %eax,0x8052868
}
 804ca4d:	5b                   	pop    %ebx
	update_cache(thread == _current);
 804ca4e:	0f 94 c0             	sete   %al
}
 804ca51:	5e                   	pop    %esi
 804ca52:	5d                   	pop    %ebp
	update_cache(thread == _current);
 804ca53:	0f b6 c0             	movzbl %al,%eax
 804ca56:	e9 24 ff ff ff       	jmp    804c97f <update_cache>

0804ca5b <z_time_slice>:
{
 804ca5b:	f3 0f 1e fb          	endbr32 
 804ca5f:	55                   	push   %ebp
 804ca60:	89 e5                	mov    %esp,%ebp
 804ca62:	57                   	push   %edi
 804ca63:	56                   	push   %esi
 804ca64:	53                   	push   %ebx
 804ca65:	83 ec 0c             	sub    $0xc,%esp
 804ca68:	8b 7d 08             	mov    0x8(%ebp),%edi
	return posix_irq_lock();
 804ca6b:	e8 cc e9 ff ff       	call   804b43c <posix_irq_lock>
	if (slice_time(_current) && sliceable(_current)) {
 804ca70:	83 3d 94 29 05 08 00 	cmpl   $0x0,0x8052994
 804ca77:	89 c6                	mov    %eax,%esi
 804ca79:	74 4e                	je     804cac9 <z_time_slice+0x6e>
 804ca7b:	8b 1d 68 28 05 08    	mov    0x8052868,%ebx
		&& !z_is_idle_thread_object(thread);
 804ca81:	66 83 7b 0e 7f       	cmpw   $0x7f,0xe(%ebx)
 804ca86:	77 41                	ja     804cac9 <z_time_slice+0x6e>
		&& !z_is_thread_prevented_from_running(thread)
 804ca88:	f6 43 0d 1f          	testb  $0x1f,0xd(%ebx)
 804ca8c:	75 3b                	jne    804cac9 <z_time_slice+0x6e>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 804ca8e:	0f be 43 0e          	movsbl 0xe(%ebx),%eax
	if (slice_time(_current) && sliceable(_current)) {
 804ca92:	39 05 90 29 05 08    	cmp    %eax,0x8052990
 804ca98:	7f 2f                	jg     804cac9 <z_time_slice+0x6e>
 804ca9a:	81 fb a0 27 05 08    	cmp    $0x80527a0,%ebx
 804caa0:	74 27                	je     804cac9 <z_time_slice+0x6e>
		if (ticks >= _current_cpu->slice_ticks) {
 804caa2:	a1 70 28 05 08       	mov    0x8052870,%eax
 804caa7:	39 f8                	cmp    %edi,%eax
 804caa9:	7f 15                	jg     804cac0 <z_time_slice+0x65>
		move_thread_to_end_of_prio_q(curr);
 804caab:	89 d8                	mov    %ebx,%eax
 804caad:	e8 27 ff ff ff       	call   804c9d9 <move_thread_to_end_of_prio_q>
	z_reset_time_slice(curr);
 804cab2:	83 ec 0c             	sub    $0xc,%esp
 804cab5:	53                   	push   %ebx
 804cab6:	e8 46 fd ff ff       	call   804c801 <z_reset_time_slice>
 804cabb:	83 c4 10             	add    $0x10,%esp
	return sched_lock_key;
 804cabe:	eb 13                	jmp    804cad3 <z_time_slice+0x78>
			_current_cpu->slice_ticks -= ticks;
 804cac0:	29 f8                	sub    %edi,%eax
 804cac2:	a3 70 28 05 08       	mov    %eax,0x8052870
 804cac7:	eb 0a                	jmp    804cad3 <z_time_slice+0x78>
		_current_cpu->slice_ticks = 0;
 804cac9:	c7 05 70 28 05 08 00 	movl   $0x0,0x8052870
 804cad0:	00 00 00 
	posix_irq_unlock(key);
 804cad3:	89 75 08             	mov    %esi,0x8(%ebp)
}
 804cad6:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804cad9:	5b                   	pop    %ebx
 804cada:	5e                   	pop    %esi
 804cadb:	5f                   	pop    %edi
 804cadc:	5d                   	pop    %ebp
 804cadd:	e9 70 e9 ff ff       	jmp    804b452 <posix_irq_unlock>

0804cae2 <ready_thread>:
 804cae2:	8a 50 0d             	mov    0xd(%eax),%dl
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
 804cae5:	84 d2                	test   %dl,%dl
 804cae7:	78 73                	js     804cb5c <ready_thread+0x7a>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 804cae9:	f6 c2 1f             	test   $0x1f,%dl
 804caec:	75 6e                	jne    804cb5c <ready_thread+0x7a>
 804caee:	83 78 18 00          	cmpl   $0x0,0x18(%eax)
 804caf2:	75 68                	jne    804cb5c <ready_thread+0x7a>
{
 804caf4:	55                   	push   %ebp
	thread->base.thread_state |= _THREAD_QUEUED;
 804caf5:	83 ca 80             	or     $0xffffff80,%edx
{
 804caf8:	89 e5                	mov    %esp,%ebp
 804cafa:	56                   	push   %esi
 804cafb:	53                   	push   %ebx
	thread->base.thread_state |= _THREAD_QUEUED;
 804cafc:	88 50 0d             	mov    %dl,0xd(%eax)
	return list->head == list;
 804caff:	8b 15 7c 28 05 08    	mov    0x805287c,%edx
 804cb05:	8b 1d 80 28 05 08    	mov    0x8052880,%ebx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804cb0b:	85 d2                	test   %edx,%edx
 804cb0d:	74 33                	je     804cb42 <ready_thread+0x60>
 804cb0f:	81 fa 7c 28 05 08    	cmp    $0x805287c,%edx
 804cb15:	74 2b                	je     804cb42 <ready_thread+0x60>
	int32_t b1 = thread_1->base.prio;
 804cb17:	0f be 70 0e          	movsbl 0xe(%eax),%esi
	int32_t b2 = thread_2->base.prio;
 804cb1b:	0f be 4a 0e          	movsbl 0xe(%edx),%ecx
	if (b1 != b2) {
 804cb1f:	39 ce                	cmp    %ecx,%esi
 804cb21:	74 15                	je     804cb38 <ready_thread+0x56>
		return b2 - b1;
 804cb23:	29 f1                	sub    %esi,%ecx
		if (z_sched_prio_cmp(thread, t) > 0) {
 804cb25:	85 c9                	test   %ecx,%ecx
 804cb27:	7e 0f                	jle    804cb38 <ready_thread+0x56>
	sys_dnode_t *const prev = successor->prev;
 804cb29:	8b 4a 04             	mov    0x4(%edx),%ecx
	node->next = successor;
 804cb2c:	89 10                	mov    %edx,(%eax)
	node->prev = prev;
 804cb2e:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = node;
 804cb31:	89 01                	mov    %eax,(%ecx)
	successor->prev = node;
 804cb33:	89 42 04             	mov    %eax,0x4(%edx)
}
 804cb36:	eb 1a                	jmp    804cb52 <ready_thread+0x70>
	return (node == list->tail) ? NULL : node->next;
 804cb38:	39 d3                	cmp    %edx,%ebx
 804cb3a:	74 06                	je     804cb42 <ready_thread+0x60>
 804cb3c:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804cb3e:	85 d2                	test   %edx,%edx
 804cb40:	75 d9                	jne    804cb1b <ready_thread+0x39>
	node->next = list;
 804cb42:	c7 00 7c 28 05 08    	movl   $0x805287c,(%eax)
	node->prev = tail;
 804cb48:	89 58 04             	mov    %ebx,0x4(%eax)
	tail->next = node;
 804cb4b:	89 03                	mov    %eax,(%ebx)
	list->tail = node;
 804cb4d:	a3 80 28 05 08       	mov    %eax,0x8052880
}
 804cb52:	5b                   	pop    %ebx
		update_cache(0);
 804cb53:	31 c0                	xor    %eax,%eax
}
 804cb55:	5e                   	pop    %esi
 804cb56:	5d                   	pop    %ebp
		update_cache(0);
 804cb57:	e9 23 fe ff ff       	jmp    804c97f <update_cache>
 804cb5c:	c3                   	ret    

0804cb5d <z_ready_thread>:
{
 804cb5d:	f3 0f 1e fb          	endbr32 
 804cb61:	55                   	push   %ebp
 804cb62:	89 e5                	mov    %esp,%ebp
 804cb64:	56                   	push   %esi
 804cb65:	53                   	push   %ebx
 804cb66:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
 804cb69:	e8 ce e8 ff ff       	call   804b43c <posix_irq_lock>
 804cb6e:	89 c3                	mov    %eax,%ebx
			ready_thread(thread);
 804cb70:	89 f0                	mov    %esi,%eax
 804cb72:	e8 6b ff ff ff       	call   804cae2 <ready_thread>
	posix_irq_unlock(key);
 804cb77:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
 804cb7a:	5b                   	pop    %ebx
 804cb7b:	5e                   	pop    %esi
 804cb7c:	5d                   	pop    %ebp
 804cb7d:	e9 d0 e8 ff ff       	jmp    804b452 <posix_irq_unlock>

0804cb82 <z_sched_start>:
{
 804cb82:	f3 0f 1e fb          	endbr32 
 804cb86:	55                   	push   %ebp
 804cb87:	89 e5                	mov    %esp,%ebp
 804cb89:	56                   	push   %esi
 804cb8a:	53                   	push   %ebx
 804cb8b:	8b 75 08             	mov    0x8(%ebp),%esi
	return posix_irq_lock();
 804cb8e:	e8 a9 e8 ff ff       	call   804b43c <posix_irq_lock>
 804cb93:	89 c3                	mov    %eax,%ebx
	if (z_has_thread_started(thread)) {
 804cb95:	8a 46 0d             	mov    0xd(%esi),%al
 804cb98:	a8 04                	test   $0x4,%al
 804cb9a:	75 0e                	jne    804cbaa <z_sched_start+0x28>
	posix_irq_unlock(key);
 804cb9c:	89 5d 08             	mov    %ebx,0x8(%ebp)
}
 804cb9f:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804cba2:	5b                   	pop    %ebx
 804cba3:	5e                   	pop    %esi
 804cba4:	5d                   	pop    %ebp
 804cba5:	e9 a8 e8 ff ff       	jmp    804b452 <posix_irq_unlock>
	thread->base.thread_state &= ~_THREAD_PRESTART;
 804cbaa:	83 e0 fb             	and    $0xfffffffb,%eax
 804cbad:	88 46 0d             	mov    %al,0xd(%esi)
	ready_thread(thread);
 804cbb0:	89 f0                	mov    %esi,%eax
 804cbb2:	e8 2b ff ff ff       	call   804cae2 <ready_thread>
	z_reschedule(&sched_spinlock, key);
 804cbb7:	50                   	push   %eax
 804cbb8:	50                   	push   %eax
 804cbb9:	53                   	push   %ebx
 804cbba:	68 a4 29 05 08       	push   $0x80529a4
 804cbbf:	e8 07 fd ff ff       	call   804c8cb <z_reschedule>
 804cbc4:	83 c4 10             	add    $0x10,%esp
}
 804cbc7:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804cbca:	5b                   	pop    %ebx
 804cbcb:	5e                   	pop    %esi
 804cbcc:	5d                   	pop    %ebp
 804cbcd:	c3                   	ret    

0804cbce <z_thread_timeout>:
{
 804cbce:	f3 0f 1e fb          	endbr32 
 804cbd2:	55                   	push   %ebp
 804cbd3:	89 e5                	mov    %esp,%ebp
 804cbd5:	56                   	push   %esi
 804cbd6:	53                   	push   %ebx
 804cbd7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	return posix_irq_lock();
 804cbda:	e8 5d e8 ff ff       	call   804b43c <posix_irq_lock>
 804cbdf:	89 c6                	mov    %eax,%esi
		if (!killed) {
 804cbe1:	f6 43 f5 28          	testb  $0x28,-0xb(%ebx)
 804cbe5:	75 17                	jne    804cbfe <z_thread_timeout+0x30>
			if (thread->base.pended_on != NULL) {
 804cbe7:	83 7b f0 00          	cmpl   $0x0,-0x10(%ebx)
	struct k_thread *thread = CONTAINER_OF(timeout,
 804cbeb:	8d 43 e8             	lea    -0x18(%ebx),%eax
			if (thread->base.pended_on != NULL) {
 804cbee:	74 05                	je     804cbf5 <z_thread_timeout+0x27>
				unpend_thread_no_timeout(thread);
 804cbf0:	e8 f4 fb ff ff       	call   804c7e9 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 804cbf5:	80 63 f5 eb          	andb   $0xeb,-0xb(%ebx)
			ready_thread(thread);
 804cbf9:	e8 e4 fe ff ff       	call   804cae2 <ready_thread>
	posix_irq_unlock(key);
 804cbfe:	89 75 08             	mov    %esi,0x8(%ebp)
}
 804cc01:	5b                   	pop    %ebx
 804cc02:	5e                   	pop    %esi
 804cc03:	5d                   	pop    %ebp
 804cc04:	e9 49 e8 ff ff       	jmp    804b452 <posix_irq_unlock>

0804cc09 <unready_thread>:
{
 804cc09:	55                   	push   %ebp
 804cc0a:	89 e5                	mov    %esp,%ebp
 804cc0c:	83 ec 08             	sub    $0x8,%esp
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
 804cc0f:	8a 50 0d             	mov    0xd(%eax),%dl
	if (z_is_thread_queued(thread)) {
 804cc12:	84 d2                	test   %dl,%dl
 804cc14:	79 0b                	jns    804cc21 <unready_thread+0x18>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 804cc16:	83 e2 7f             	and    $0x7f,%edx
 804cc19:	88 50 0d             	mov    %dl,0xd(%eax)
	sys_dlist_remove(&thread->base.qnode_dlist);
 804cc1c:	e8 b0 fb ff ff       	call   804c7d1 <sys_dlist_remove>
	update_cache(thread == _current);
 804cc21:	39 05 68 28 05 08    	cmp    %eax,0x8052868
}
 804cc27:	c9                   	leave  
	update_cache(thread == _current);
 804cc28:	0f 94 c0             	sete   %al
 804cc2b:	0f b6 c0             	movzbl %al,%eax
 804cc2e:	e9 4c fd ff ff       	jmp    804c97f <update_cache>

0804cc33 <z_impl_k_thread_suspend>:
{
 804cc33:	f3 0f 1e fb          	endbr32 
 804cc37:	55                   	push   %ebp
 804cc38:	89 e5                	mov    %esp,%ebp
 804cc3a:	56                   	push   %esi
 804cc3b:	53                   	push   %ebx
 804cc3c:	8b 5d 08             	mov    0x8(%ebp),%ebx
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
 804cc3f:	8d 43 18             	lea    0x18(%ebx),%eax
 804cc42:	83 ec 0c             	sub    $0xc,%esp
 804cc45:	50                   	push   %eax
 804cc46:	e8 60 05 00 00       	call   804d1ab <z_abort_timeout>
 804cc4b:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
 804cc4e:	e8 e9 e7 ff ff       	call   804b43c <posix_irq_lock>
 804cc53:	89 c6                	mov    %eax,%esi
 804cc55:	8a 43 0d             	mov    0xd(%ebx),%al
		if (z_is_thread_queued(thread)) {
 804cc58:	84 c0                	test   %al,%al
 804cc5a:	79 0d                	jns    804cc69 <z_impl_k_thread_suspend+0x36>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 804cc5c:	83 e0 7f             	and    $0x7f,%eax
 804cc5f:	88 43 0d             	mov    %al,0xd(%ebx)
	sys_dlist_remove(&thread->base.qnode_dlist);
 804cc62:	89 d8                	mov    %ebx,%eax
 804cc64:	e8 68 fb ff ff       	call   804c7d1 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_SUSPENDED;
 804cc69:	80 4b 0d 10          	orb    $0x10,0xd(%ebx)
		update_cache(thread == _current);
 804cc6d:	31 c0                	xor    %eax,%eax
 804cc6f:	39 1d 68 28 05 08    	cmp    %ebx,0x8052868
 804cc75:	0f 94 c0             	sete   %al
 804cc78:	e8 02 fd ff ff       	call   804c97f <update_cache>
	posix_irq_unlock(key);
 804cc7d:	83 ec 0c             	sub    $0xc,%esp
 804cc80:	56                   	push   %esi
 804cc81:	e8 cc e7 ff ff       	call   804b452 <posix_irq_unlock>
 804cc86:	83 c4 10             	add    $0x10,%esp
	if (thread == _current) {
 804cc89:	39 1d 68 28 05 08    	cmp    %ebx,0x8052868
 804cc8f:	75 0b                	jne    804cc9c <z_impl_k_thread_suspend+0x69>
}
 804cc91:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804cc94:	5b                   	pop    %ebx
 804cc95:	5e                   	pop    %esi
 804cc96:	5d                   	pop    %ebp
		z_reschedule_unlocked();
 804cc97:	e9 8c fc ff ff       	jmp    804c928 <z_reschedule_unlocked>
}
 804cc9c:	8d 65 f8             	lea    -0x8(%ebp),%esp
 804cc9f:	5b                   	pop    %ebx
 804cca0:	5e                   	pop    %esi
 804cca1:	5d                   	pop    %ebp
 804cca2:	c3                   	ret    

0804cca3 <k_sched_unlock>:
{
 804cca3:	f3 0f 1e fb          	endbr32 
 804cca7:	55                   	push   %ebp
 804cca8:	89 e5                	mov    %esp,%ebp
 804ccaa:	53                   	push   %ebx
 804ccab:	50                   	push   %eax
	return posix_irq_lock();
 804ccac:	e8 8b e7 ff ff       	call   804b43c <posix_irq_lock>
 804ccb1:	89 c3                	mov    %eax,%ebx
		++_current->base.sched_locked;
 804ccb3:	a1 68 28 05 08       	mov    0x8052868,%eax
 804ccb8:	fe 40 0f             	incb   0xf(%eax)
		update_cache(0);
 804ccbb:	31 c0                	xor    %eax,%eax
 804ccbd:	e8 bd fc ff ff       	call   804c97f <update_cache>
	posix_irq_unlock(key);
 804ccc2:	83 ec 0c             	sub    $0xc,%esp
 804ccc5:	53                   	push   %ebx
 804ccc6:	e8 87 e7 ff ff       	call   804b452 <posix_irq_unlock>
}
 804cccb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804ccce:	83 c4 10             	add    $0x10,%esp
 804ccd1:	c9                   	leave  
	z_reschedule_unlocked();
 804ccd2:	e9 51 fc ff ff       	jmp    804c928 <z_reschedule_unlocked>

0804ccd7 <z_sched_init>:
	sys_dlist_init(&rq->runq);
#endif
}

void z_sched_init(void)
{
 804ccd7:	f3 0f 1e fb          	endbr32 
 804ccdb:	55                   	push   %ebp
 804ccdc:	89 e5                	mov    %esp,%ebp
 804ccde:	83 ec 10             	sub    $0x10,%esp
	list->head = (sys_dnode_t *)list;
 804cce1:	c7 05 7c 28 05 08 7c 	movl   $0x805287c,0x805287c
 804cce8:	28 05 08 
#else
	init_ready_q(&_kernel.ready_q);
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
 804cceb:	6a 00                	push   $0x0
 804cced:	6a 00                	push   $0x0
	list->tail = (sys_dnode_t *)list;
 804ccef:	c7 05 80 28 05 08 7c 	movl   $0x805287c,0x8052880
 804ccf6:	28 05 08 
 804ccf9:	e8 3a fb ff ff       	call   804c838 <k_sched_time_slice_set>
 804ccfe:	83 c4 10             	add    $0x10,%esp
		CONFIG_TIMESLICE_PRIORITY);
#endif
}
 804cd01:	c9                   	leave  
 804cd02:	c3                   	ret    

0804cd03 <z_impl_k_yield>:
	return !(k_is_pre_kernel() || k_is_in_isr() ||
		 z_is_idle_thread_object(_current));
}

void z_impl_k_yield(void)
{
 804cd03:	f3 0f 1e fb          	endbr32 
 804cd07:	55                   	push   %ebp
 804cd08:	89 e5                	mov    %esp,%ebp
 804cd0a:	57                   	push   %edi
 804cd0b:	56                   	push   %esi
 804cd0c:	53                   	push   %ebx
 804cd0d:	83 ec 0c             	sub    $0xc,%esp
	return posix_irq_lock();
 804cd10:	e8 27 e7 ff ff       	call   804b43c <posix_irq_lock>
 804cd15:	89 c3                	mov    %eax,%ebx

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if (!IS_ENABLED(CONFIG_SMP) ||
	    z_is_thread_queued(_current)) {
		dequeue_thread(_current);
 804cd17:	a1 68 28 05 08       	mov    0x8052868,%eax
	thread->base.thread_state &= ~_THREAD_QUEUED;
 804cd1c:	80 60 0d 7f          	andb   $0x7f,0xd(%eax)
	sys_dlist_remove(&thread->base.qnode_dlist);
 804cd20:	e8 ac fa ff ff       	call   804c7d1 <sys_dlist_remove>
	}
	queue_thread(_current);
 804cd25:	a1 68 28 05 08       	mov    0x8052868,%eax
	thread->base.thread_state |= _THREAD_QUEUED;
 804cd2a:	80 48 0d 80          	orb    $0x80,0xd(%eax)
	return list->head == list;
 804cd2e:	8b 15 7c 28 05 08    	mov    0x805287c,%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804cd34:	85 d2                	test   %edx,%edx
 804cd36:	74 39                	je     804cd71 <z_impl_k_yield+0x6e>
 804cd38:	81 fa 7c 28 05 08    	cmp    $0x805287c,%edx
 804cd3e:	74 31                	je     804cd71 <z_impl_k_yield+0x6e>
	int32_t b1 = thread_1->base.prio;
 804cd40:	0f be 70 0e          	movsbl 0xe(%eax),%esi
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 804cd44:	8b 3d 80 28 05 08    	mov    0x8052880,%edi
	int32_t b2 = thread_2->base.prio;
 804cd4a:	0f be 4a 0e          	movsbl 0xe(%edx),%ecx
	if (b1 != b2) {
 804cd4e:	39 ce                	cmp    %ecx,%esi
 804cd50:	74 15                	je     804cd67 <z_impl_k_yield+0x64>
		return b2 - b1;
 804cd52:	29 f1                	sub    %esi,%ecx
		if (z_sched_prio_cmp(thread, t) > 0) {
 804cd54:	85 c9                	test   %ecx,%ecx
 804cd56:	7e 0f                	jle    804cd67 <z_impl_k_yield+0x64>
	sys_dnode_t *const prev = successor->prev;
 804cd58:	8b 4a 04             	mov    0x4(%edx),%ecx
	node->next = successor;
 804cd5b:	89 10                	mov    %edx,(%eax)
	node->prev = prev;
 804cd5d:	89 48 04             	mov    %ecx,0x4(%eax)
	prev->next = node;
 804cd60:	89 01                	mov    %eax,(%ecx)
	successor->prev = node;
 804cd62:	89 42 04             	mov    %eax,0x4(%edx)
}
 804cd65:	eb 20                	jmp    804cd87 <z_impl_k_yield+0x84>
	return (node == list->tail) ? NULL : node->next;
 804cd67:	39 fa                	cmp    %edi,%edx
 804cd69:	74 06                	je     804cd71 <z_impl_k_yield+0x6e>
 804cd6b:	8b 12                	mov    (%edx),%edx
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 804cd6d:	85 d2                	test   %edx,%edx
 804cd6f:	75 d9                	jne    804cd4a <z_impl_k_yield+0x47>
	sys_dnode_t *const tail = list->tail;
 804cd71:	8b 15 80 28 05 08    	mov    0x8052880,%edx
	node->next = list;
 804cd77:	c7 00 7c 28 05 08    	movl   $0x805287c,(%eax)
	node->prev = tail;
 804cd7d:	89 50 04             	mov    %edx,0x4(%eax)
	tail->next = node;
 804cd80:	89 02                	mov    %eax,(%edx)
	list->tail = node;
 804cd82:	a3 80 28 05 08       	mov    %eax,0x8052880
	update_cache(1);
 804cd87:	b8 01 00 00 00       	mov    $0x1,%eax
 804cd8c:	e8 ee fb ff ff       	call   804c97f <update_cache>
 804cd91:	83 ec 0c             	sub    $0xc,%esp
 804cd94:	53                   	push   %ebx
 804cd95:	e8 06 d9 ff ff       	call   804a6a0 <arch_swap>
 804cd9a:	83 c4 10             	add    $0x10,%esp
	z_swap(&sched_spinlock, key);
}
 804cd9d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804cda0:	5b                   	pop    %ebx
 804cda1:	5e                   	pop    %esi
 804cda2:	5f                   	pop    %edi
 804cda3:	5d                   	pop    %ebp
 804cda4:	c3                   	ret    

0804cda5 <z_tick_sleep>:
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
{
 804cda5:	55                   	push   %ebp
 804cda6:	89 e5                	mov    %esp,%ebp
 804cda8:	57                   	push   %edi
 804cda9:	56                   	push   %esi
 804cdaa:	89 c6                	mov    %eax,%esi
	 */
	LOG_DBG("thread %p for %u ticks", _current, ticks);
#endif

	/* wait of 0 ms is treated as a 'yield' */
	if (ticks == 0) {
 804cdac:	89 d0                	mov    %edx,%eax
{
 804cdae:	53                   	push   %ebx
 804cdaf:	83 ec 1c             	sub    $0x1c,%esp
	if (ticks == 0) {
 804cdb2:	09 f0                	or     %esi,%eax
 804cdb4:	75 0c                	jne    804cdc2 <z_tick_sleep+0x1d>
	z_impl_k_yield();
 804cdb6:	e8 48 ff ff ff       	call   804cd03 <z_impl_k_yield>
		k_yield();
		return 0;
 804cdbb:	31 c0                	xor    %eax,%eax
}
 804cdbd:	e9 84 00 00 00       	jmp    804ce46 <z_tick_sleep+0xa1>
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
	if (Z_TICK_ABS(ticks) <= 0) {
 804cdc2:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 804cdc7:	89 d7                	mov    %edx,%edi
 804cdc9:	83 ca ff             	or     $0xffffffff,%edx
 804cdcc:	89 f3                	mov    %esi,%ebx
 804cdce:	29 f0                	sub    %esi,%eax
 804cdd0:	19 fa                	sbb    %edi,%edx
 804cdd2:	31 c9                	xor    %ecx,%ecx
 804cdd4:	39 c1                	cmp    %eax,%ecx
 804cdd6:	19 d1                	sbb    %edx,%ecx
 804cdd8:	7c 09                	jl     804cde3 <z_tick_sleep+0x3e>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
 804cdda:	e8 a8 05 00 00       	call   804d387 <sys_clock_tick_get_32>
 804cddf:	01 c3                	add    %eax,%ebx
 804cde1:	eb 09                	jmp    804cdec <z_tick_sleep+0x47>
	} else {
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
 804cde3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 804cde8:	29 f0                	sub    %esi,%eax
 804cdea:	89 c3                	mov    %eax,%ebx
 804cdec:	e8 4b e6 ff ff       	call   804b43c <posix_irq_lock>
 804cdf1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
#endif
	unready_thread(_current);
 804cdf4:	a1 68 28 05 08       	mov    0x8052868,%eax
 804cdf9:	e8 0b fe ff ff       	call   804cc09 <unready_thread>
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 804cdfe:	a1 68 28 05 08       	mov    0x8052868,%eax
 804ce03:	57                   	push   %edi
 804ce04:	56                   	push   %esi
 804ce05:	83 c0 18             	add    $0x18,%eax
 804ce08:	68 ce cb 04 08       	push   $0x804cbce
 804ce0d:	50                   	push   %eax
 804ce0e:	e8 2d 02 00 00       	call   804d040 <z_add_timeout>
	z_add_thread_timeout(_current, timeout);
	z_mark_thread_as_suspended(_current);
 804ce13:	a1 68 28 05 08       	mov    0x8052868,%eax
 804ce18:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804ce1b:	80 48 0d 10          	orb    $0x10,0xd(%eax)
 804ce1f:	89 14 24             	mov    %edx,(%esp)
 804ce22:	e8 79 d8 ff ff       	call   804a6a0 <arch_swap>
 804ce27:	83 c4 10             	add    $0x10,%esp

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
 804ce2a:	e8 58 05 00 00       	call   804d387 <sys_clock_tick_get_32>
 804ce2f:	31 d2                	xor    %edx,%edx
 804ce31:	89 c1                	mov    %eax,%ecx
 804ce33:	89 d8                	mov    %ebx,%eax
 804ce35:	31 db                	xor    %ebx,%ebx
 804ce37:	29 c8                	sub    %ecx,%eax
 804ce39:	19 da                	sbb    %ebx,%edx
	if (ticks > 0) {
 804ce3b:	31 db                	xor    %ebx,%ebx
 804ce3d:	39 c3                	cmp    %eax,%ebx
 804ce3f:	89 df                	mov    %ebx,%edi
 804ce41:	19 d7                	sbb    %edx,%edi
		return ticks;
 804ce43:	0f 4d c3             	cmovge %ebx,%eax
	}
#endif

	return 0;
}
 804ce46:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804ce49:	5b                   	pop    %ebx
 804ce4a:	5e                   	pop    %esi
 804ce4b:	5f                   	pop    %edi
 804ce4c:	5d                   	pop    %ebp
 804ce4d:	c3                   	ret    

0804ce4e <z_impl_k_sleep>:

int32_t z_impl_k_sleep(k_timeout_t timeout)
{
 804ce4e:	f3 0f 1e fb          	endbr32 
 804ce52:	55                   	push   %ebp
 804ce53:	89 e5                	mov    %esp,%ebp
 804ce55:	83 ec 08             	sub    $0x8,%esp
 804ce58:	8b 55 0c             	mov    0xc(%ebp),%edx
 804ce5b:	8b 45 08             	mov    0x8(%ebp),%eax
	__ASSERT(!arch_is_in_isr(), "");

	SYS_PORT_TRACING_FUNC_ENTER(k_thread, sleep, timeout);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 804ce5e:	83 fa ff             	cmp    $0xffffffff,%edx
 804ce61:	75 1b                	jne    804ce7e <z_impl_k_sleep+0x30>
 804ce63:	83 f8 ff             	cmp    $0xffffffff,%eax
 804ce66:	75 16                	jne    804ce7e <z_impl_k_sleep+0x30>
		k_thread_suspend(_current);
 804ce68:	a1 68 28 05 08       	mov    0x8052868,%eax
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_THREAD_SUSPEND);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_thread_suspend(thread);
 804ce6d:	83 ec 0c             	sub    $0xc,%esp
 804ce70:	50                   	push   %eax
 804ce71:	e8 bd fd ff ff       	call   804cc33 <z_impl_k_thread_suspend>
 804ce76:	83 c4 10             	add    $0x10,%esp

		SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, (int32_t) K_TICKS_FOREVER);

		return (int32_t) K_TICKS_FOREVER;
 804ce79:	83 c8 ff             	or     $0xffffffff,%eax
}
 804ce7c:	eb 08                	jmp    804ce86 <z_impl_k_sleep+0x38>
	}

	ticks = timeout.ticks;

	ticks = z_tick_sleep(ticks);
 804ce7e:	e8 22 ff ff ff       	call   804cda5 <z_tick_sleep>

	int32_t ret = k_ticks_to_ms_floor64(ticks);
 804ce83:	6b c0 0a             	imul   $0xa,%eax,%eax

	SYS_PORT_TRACING_FUNC_EXIT(k_thread, sleep, timeout, ret);

	return ret;
}
 804ce86:	c9                   	leave  
 804ce87:	c3                   	ret    

0804ce88 <z_impl_z_current_get>:
}
#include <syscalls/k_wakeup_mrsh.c>
#endif

k_tid_t z_impl_z_current_get(void)
{
 804ce88:	f3 0f 1e fb          	endbr32 

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
 804ce8c:	a1 68 28 05 08       	mov    0x8052868,%eax
 804ce91:	c3                   	ret    

0804ce92 <z_thread_abort>:
#endif
	}
}

void z_thread_abort(struct k_thread *thread)
{
 804ce92:	f3 0f 1e fb          	endbr32 
 804ce96:	55                   	push   %ebp
 804ce97:	89 e5                	mov    %esp,%ebp
 804ce99:	57                   	push   %edi
 804ce9a:	56                   	push   %esi
 804ce9b:	53                   	push   %ebx
 804ce9c:	83 ec 0c             	sub    $0xc,%esp
 804ce9f:	8b 5d 08             	mov    0x8(%ebp),%ebx
 804cea2:	e8 95 e5 ff ff       	call   804b43c <posix_irq_lock>
 804cea7:	89 c6                	mov    %eax,%esi
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.user_options & K_ESSENTIAL) != 0) {
 804cea9:	f6 43 0c 01          	testb  $0x1,0xc(%ebx)
 804cead:	74 36                	je     804cee5 <z_thread_abort+0x53>
	posix_irq_unlock(key);
 804ceaf:	83 ec 0c             	sub    $0xc,%esp
 804ceb2:	50                   	push   %eax
 804ceb3:	e8 9a e5 ff ff       	call   804b452 <posix_irq_unlock>
 804ceb8:	83 c4 0c             	add    $0xc,%esp
		k_spin_unlock(&sched_spinlock, key);
		__ASSERT(false, "aborting essential thread %p", thread);
		k_panic();
 804cebb:	68 b6 06 00 00       	push   $0x6b6
 804cec0:	68 1d ee 04 08       	push   $0x804ee1d
 804cec5:	68 3f ee 04 08       	push   $0x804ee3f
 804ceca:	e8 c6 d2 ff ff       	call   804a195 <assert_print>
 804cecf:	58                   	pop    %eax
 804ced0:	5a                   	pop    %edx
 804ced1:	6a 00                	push   $0x0
 804ced3:	6a 04                	push   $0x4
 804ced5:	e8 dd f5 ff ff       	call   804c4b7 <z_fatal_error>
 804ceda:	83 c4 10             	add    $0x10,%esp
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
 804cedd:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804cee0:	5b                   	pop    %ebx
 804cee1:	5e                   	pop    %esi
 804cee2:	5f                   	pop    %edi
 804cee3:	5d                   	pop    %ebp
 804cee4:	c3                   	ret    
	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
 804cee5:	8a 43 0d             	mov    0xd(%ebx),%al
 804cee8:	a8 08                	test   $0x8,%al
 804ceea:	0f 85 96 00 00 00    	jne    804cf86 <z_thread_abort+0xf4>
		thread->base.thread_state &= ~_THREAD_ABORTING;
 804cef0:	89 c2                	mov    %eax,%edx
 804cef2:	83 e2 df             	and    $0xffffffdf,%edx
		if (z_is_thread_queued(thread)) {
 804cef5:	80 ca 08             	or     $0x8,%dl
 804cef8:	78 05                	js     804ceff <z_thread_abort+0x6d>
		thread->base.thread_state &= ~_THREAD_ABORTING;
 804cefa:	88 53 0d             	mov    %dl,0xd(%ebx)
 804cefd:	eb 10                	jmp    804cf0f <z_thread_abort+0x7d>
	thread->base.thread_state &= ~_THREAD_QUEUED;
 804ceff:	83 e0 5f             	and    $0x5f,%eax
 804cf02:	83 c8 08             	or     $0x8,%eax
 804cf05:	88 43 0d             	mov    %al,0xd(%ebx)
	sys_dlist_remove(&thread->base.qnode_dlist);
 804cf08:	89 d8                	mov    %ebx,%eax
 804cf0a:	e8 c2 f8 ff ff       	call   804c7d1 <sys_dlist_remove>
		if (thread->base.pended_on != NULL) {
 804cf0f:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
 804cf13:	74 07                	je     804cf1c <z_thread_abort+0x8a>
			unpend_thread_no_timeout(thread);
 804cf15:	89 d8                	mov    %ebx,%eax
 804cf17:	e8 cd f8 ff ff       	call   804c7e9 <unpend_thread_no_timeout>
	return z_abort_timeout(&thread->base.timeout);
 804cf1c:	83 ec 0c             	sub    $0xc,%esp
 804cf1f:	8d 43 18             	lea    0x18(%ebx),%eax
 804cf22:	50                   	push   %eax
 804cf23:	e8 83 02 00 00       	call   804d1ab <z_abort_timeout>
 804cf28:	83 c4 10             	add    $0x10,%esp
	return list->head == list;
 804cf2b:	8b 7b 3c             	mov    0x3c(%ebx),%edi
	while ((thread = z_waitq_head(wait_q)) != NULL) {
 804cf2e:	85 ff                	test   %edi,%edi
 804cf30:	74 2d                	je     804cf5f <z_thread_abort+0xcd>
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 804cf32:	8d 43 3c             	lea    0x3c(%ebx),%eax
 804cf35:	39 c7                	cmp    %eax,%edi
 804cf37:	74 26                	je     804cf5f <z_thread_abort+0xcd>
		unpend_thread_no_timeout(thread);
 804cf39:	89 f8                	mov    %edi,%eax
 804cf3b:	e8 a9 f8 ff ff       	call   804c7e9 <unpend_thread_no_timeout>
 804cf40:	83 ec 0c             	sub    $0xc,%esp
 804cf43:	8d 47 18             	lea    0x18(%edi),%eax
 804cf46:	50                   	push   %eax
 804cf47:	e8 5f 02 00 00       	call   804d1ab <z_abort_timeout>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->callee_saved.retval = value;
 804cf4c:	c7 47 30 00 00 00 00 	movl   $0x0,0x30(%edi)
 804cf53:	83 c4 10             	add    $0x10,%esp
		ready_thread(thread);
 804cf56:	89 f8                	mov    %edi,%eax
 804cf58:	e8 85 fb ff ff       	call   804cae2 <ready_thread>
 804cf5d:	eb cc                	jmp    804cf2b <z_thread_abort+0x99>
		update_cache(1);
 804cf5f:	b8 01 00 00 00       	mov    $0x1,%eax
 804cf64:	e8 16 fa ff ff       	call   804c97f <update_cache>
	if (thread == _current && !arch_is_in_isr()) {
 804cf69:	39 1d 68 28 05 08    	cmp    %ebx,0x8052868
 804cf6f:	75 15                	jne    804cf86 <z_thread_abort+0xf4>
 804cf71:	83 3d 60 28 05 08 00 	cmpl   $0x0,0x8052860
 804cf78:	75 0c                	jne    804cf86 <z_thread_abort+0xf4>
 804cf7a:	83 ec 0c             	sub    $0xc,%esp
 804cf7d:	56                   	push   %esi
 804cf7e:	e8 1d d7 ff ff       	call   804a6a0 <arch_swap>
 804cf83:	83 c4 10             	add    $0x10,%esp
 804cf86:	89 75 08             	mov    %esi,0x8(%ebp)
}
 804cf89:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804cf8c:	5b                   	pop    %ebx
 804cf8d:	5e                   	pop    %esi
 804cf8e:	5f                   	pop    %edi
 804cf8f:	5d                   	pop    %ebp
 804cf90:	e9 bd e4 ff ff       	jmp    804b452 <posix_irq_unlock>

0804cf95 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
 804cf95:	83 3d 98 29 05 08 00 	cmpl   $0x0,0x8052998
 804cf9c:	75 05                	jne    804cfa3 <elapsed+0xe>
 804cf9e:	e9 cf f4 ff ff       	jmp    804c472 <sys_clock_elapsed>
}
 804cfa3:	31 c0                	xor    %eax,%eax
 804cfa5:	c3                   	ret    

0804cfa6 <remove_timeout>:
{
 804cfa6:	55                   	push   %ebp
 804cfa7:	8b 10                	mov    (%eax),%edx
 804cfa9:	89 e5                	mov    %esp,%ebp
 804cfab:	53                   	push   %ebx
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 804cfac:	85 c0                	test   %eax,%eax
 804cfae:	74 18                	je     804cfc8 <remove_timeout+0x22>
	return (node == list->tail) ? NULL : node->next;
 804cfb0:	3b 05 8c 12 05 08    	cmp    0x805128c,%eax
 804cfb6:	74 10                	je     804cfc8 <remove_timeout+0x22>
	if (next(t) != NULL) {
 804cfb8:	85 d2                	test   %edx,%edx
 804cfba:	74 0c                	je     804cfc8 <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
 804cfbc:	8b 48 0c             	mov    0xc(%eax),%ecx
 804cfbf:	8b 58 10             	mov    0x10(%eax),%ebx
 804cfc2:	01 4a 0c             	add    %ecx,0xc(%edx)
 804cfc5:	11 5a 10             	adc    %ebx,0x10(%edx)
	sys_dnode_t *const prev = node->prev;
 804cfc8:	8b 48 04             	mov    0x4(%eax),%ecx
	prev->next = next;
 804cfcb:	89 11                	mov    %edx,(%ecx)
	next->prev = prev;
 804cfcd:	89 4a 04             	mov    %ecx,0x4(%edx)
}
 804cfd0:	5b                   	pop    %ebx
	node->next = NULL;
 804cfd1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
 804cfd7:	5d                   	pop    %ebp
	node->prev = NULL;
 804cfd8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
 804cfdf:	c3                   	ret    

0804cfe0 <next_timeout>:

static int32_t next_timeout(void)
{
 804cfe0:	55                   	push   %ebp
 804cfe1:	89 e5                	mov    %esp,%ebp
 804cfe3:	53                   	push   %ebx
 804cfe4:	51                   	push   %ecx
	return list->head == list;
 804cfe5:	8b 1d 88 12 05 08    	mov    0x8051288,%ebx
	return sys_dlist_is_empty(list) ? NULL : list->head;
 804cfeb:	81 fb 88 12 05 08    	cmp    $0x8051288,%ebx
 804cff1:	75 02                	jne    804cff5 <next_timeout+0x15>
 804cff3:	31 db                	xor    %ebx,%ebx
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
 804cff5:	e8 9b ff ff ff       	call   804cf95 <elapsed>
 804cffa:	89 c2                	mov    %eax,%edx
	int32_t ret;

	if ((to == NULL) ||
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
 804cffc:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
	if ((to == NULL) ||
 804d001:	85 db                	test   %ebx,%ebx
 804d003:	74 28                	je     804d02d <next_timeout+0x4d>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 804d005:	8b 4b 0c             	mov    0xc(%ebx),%ecx
 804d008:	89 d0                	mov    %edx,%eax
 804d00a:	8b 5b 10             	mov    0x10(%ebx),%ebx
 804d00d:	99                   	cltd   
 804d00e:	29 c1                	sub    %eax,%ecx
	if ((to == NULL) ||
 804d010:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 804d015:	19 d3                	sbb    %edx,%ebx
	if ((to == NULL) ||
 804d017:	31 d2                	xor    %edx,%edx
 804d019:	39 c8                	cmp    %ecx,%eax
 804d01b:	89 d0                	mov    %edx,%eax
 804d01d:	19 d8                	sbb    %ebx,%eax
		ret = MAX_WAIT;
 804d01f:	b8 ff ff ff 7f       	mov    $0x7fffffff,%eax
	if ((to == NULL) ||
 804d024:	7c 07                	jl     804d02d <next_timeout+0x4d>
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
 804d026:	89 c8                	mov    %ecx,%eax
 804d028:	85 db                	test   %ebx,%ebx
 804d02a:	0f 48 c2             	cmovs  %edx,%eax
	}

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
 804d02d:	8b 15 70 28 05 08    	mov    0x8052870,%edx
 804d033:	85 d2                	test   %edx,%edx
 804d035:	74 05                	je     804d03c <next_timeout+0x5c>
 804d037:	39 d0                	cmp    %edx,%eax
 804d039:	0f 4f c2             	cmovg  %edx,%eax
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
 804d03c:	5a                   	pop    %edx
 804d03d:	5b                   	pop    %ebx
 804d03e:	5d                   	pop    %ebp
 804d03f:	c3                   	ret    

0804d040 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
 804d040:	f3 0f 1e fb          	endbr32 
 804d044:	55                   	push   %ebp
 804d045:	89 e5                	mov    %esp,%ebp
 804d047:	57                   	push   %edi
 804d048:	56                   	push   %esi
 804d049:	53                   	push   %ebx
 804d04a:	83 ec 1c             	sub    $0x1c,%esp
 804d04d:	8b 4d 14             	mov    0x14(%ebp),%ecx
 804d050:	8b 55 10             	mov    0x10(%ebp),%edx
 804d053:	8b 75 08             	mov    0x8(%ebp),%esi
 804d056:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d059:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 804d05c:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%ebp)
{
 804d060:	89 55 e0             	mov    %edx,-0x20(%ebp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 804d063:	75 0a                	jne    804d06f <z_add_timeout+0x2f>
 804d065:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
 804d069:	0f 84 34 01 00 00    	je     804d1a3 <z_add_timeout+0x163>
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
 804d06f:	89 46 08             	mov    %eax,0x8(%esi)
	return posix_irq_lock();
 804d072:	e8 c5 e3 ff ff       	call   804b43c <posix_irq_lock>

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
 804d077:	83 ca ff             	or     $0xffffffff,%edx
 804d07a:	89 c7                	mov    %eax,%edi
 804d07c:	89 d3                	mov    %edx,%ebx
 804d07e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 804d083:	3b 45 e0             	cmp    -0x20(%ebp),%eax
 804d086:	1b 5d e4             	sbb    -0x1c(%ebp),%ebx
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
 804d089:	85 db                	test   %ebx,%ebx
 804d08b:	78 2d                	js     804d0ba <z_add_timeout+0x7a>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 804d08d:	2b 05 20 29 05 08    	sub    0x8052920,%eax
 804d093:	1b 15 24 29 05 08    	sbb    0x8052924,%edx
 804d099:	2b 45 e0             	sub    -0x20(%ebp),%eax
 804d09c:	1b 55 e4             	sbb    -0x1c(%ebp),%edx

			to->dticks = MAX(1, ticks);
 804d09f:	31 c9                	xor    %ecx,%ecx
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 804d0a1:	89 56 10             	mov    %edx,0x10(%esi)
			to->dticks = MAX(1, ticks);
 804d0a4:	8b 56 10             	mov    0x10(%esi),%edx
 804d0a7:	39 c1                	cmp    %eax,%ecx
 804d0a9:	89 cb                	mov    %ecx,%ebx
 804d0ab:	19 d3                	sbb    %edx,%ebx
 804d0ad:	bb 01 00 00 00       	mov    $0x1,%ebx
 804d0b2:	0f 4d c3             	cmovge %ebx,%eax
 804d0b5:	0f 4d d1             	cmovge %ecx,%edx
 804d0b8:	eb 1c                	jmp    804d0d6 <z_add_timeout+0x96>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
 804d0ba:	e8 d6 fe ff ff       	call   804cf95 <elapsed>
 804d0bf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804d0c2:	89 c1                	mov    %eax,%ecx
 804d0c4:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804d0c7:	89 cb                	mov    %ecx,%ebx
 804d0c9:	83 c0 01             	add    $0x1,%eax
 804d0cc:	83 d2 00             	adc    $0x0,%edx
 804d0cf:	c1 fb 1f             	sar    $0x1f,%ebx
 804d0d2:	01 c8                	add    %ecx,%eax
 804d0d4:	11 da                	adc    %ebx,%edx
 804d0d6:	89 46 0c             	mov    %eax,0xc(%esi)
	return list->head == list;
 804d0d9:	a1 88 12 05 08       	mov    0x8051288,%eax
 804d0de:	89 56 10             	mov    %edx,0x10(%esi)
 804d0e1:	8b 15 8c 12 05 08    	mov    0x805128c,%edx
 804d0e7:	89 45 e0             	mov    %eax,-0x20(%ebp)
	return sys_dlist_is_empty(list) ? NULL : list->head;
 804d0ea:	3d 88 12 05 08       	cmp    $0x8051288,%eax
 804d0ef:	74 64                	je     804d155 <z_add_timeout+0x115>
		}

		for (t = first(); t != NULL; t = next(t)) {
 804d0f1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
 804d0f5:	74 5e                	je     804d155 <z_add_timeout+0x115>
			if (t->dticks > to->dticks) {
 804d0f7:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804d0fa:	8b 58 10             	mov    0x10(%eax),%ebx
 804d0fd:	8b 48 0c             	mov    0xc(%eax),%ecx
 804d100:	89 5d dc             	mov    %ebx,-0x24(%ebp)
 804d103:	8b 5e 10             	mov    0x10(%esi),%ebx
 804d106:	89 4d d8             	mov    %ecx,-0x28(%ebp)
 804d109:	8b 4e 0c             	mov    0xc(%esi),%ecx
 804d10c:	89 d8                	mov    %ebx,%eax
 804d10e:	3b 4d d8             	cmp    -0x28(%ebp),%ecx
 804d111:	1b 45 dc             	sbb    -0x24(%ebp),%eax
 804d114:	7d 24                	jge    804d13a <z_add_timeout+0xfa>
				t->dticks -= to->dticks;
 804d116:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804d119:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804d11c:	29 c8                	sub    %ecx,%eax
 804d11e:	89 c1                	mov    %eax,%ecx
 804d120:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804d123:	19 da                	sbb    %ebx,%edx
 804d125:	89 50 10             	mov    %edx,0x10(%eax)
	sys_dnode_t *const prev = successor->prev;
 804d128:	8b 50 04             	mov    0x4(%eax),%edx
 804d12b:	89 48 0c             	mov    %ecx,0xc(%eax)
	node->prev = prev;
 804d12e:	89 56 04             	mov    %edx,0x4(%esi)
	node->next = successor;
 804d131:	89 06                	mov    %eax,(%esi)
	prev->next = node;
 804d133:	89 32                	mov    %esi,(%edx)
	successor->prev = node;
 804d135:	89 70 04             	mov    %esi,0x4(%eax)
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
 804d138:	eb 2c                	jmp    804d166 <z_add_timeout+0x126>
			to->dticks -= t->dticks;
 804d13a:	2b 4d d8             	sub    -0x28(%ebp),%ecx
 804d13d:	1b 5d dc             	sbb    -0x24(%ebp),%ebx
 804d140:	89 4e 0c             	mov    %ecx,0xc(%esi)
 804d143:	89 5e 10             	mov    %ebx,0x10(%esi)
	return (node == list->tail) ? NULL : node->next;
 804d146:	39 55 e0             	cmp    %edx,-0x20(%ebp)
 804d149:	74 0a                	je     804d155 <z_add_timeout+0x115>
 804d14b:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804d14e:	8b 00                	mov    (%eax),%eax
 804d150:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804d153:	eb 9c                	jmp    804d0f1 <z_add_timeout+0xb1>
	node->next = list;
 804d155:	c7 06 88 12 05 08    	movl   $0x8051288,(%esi)
	node->prev = tail;
 804d15b:	89 56 04             	mov    %edx,0x4(%esi)
	tail->next = node;
 804d15e:	89 32                	mov    %esi,(%edx)
	list->tail = node;
 804d160:	89 35 8c 12 05 08    	mov    %esi,0x805128c
	return list->head == list;
 804d166:	a1 88 12 05 08       	mov    0x8051288,%eax
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
 804d16b:	39 c6                	cmp    %eax,%esi
 804d16d:	75 25                	jne    804d194 <z_add_timeout+0x154>
 804d16f:	3d 88 12 05 08       	cmp    $0x8051288,%eax
 804d174:	74 1e                	je     804d194 <z_add_timeout+0x154>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
 804d176:	e8 65 fe ff ff       	call   804cfe0 <next_timeout>

			if (next_time == 0 ||
 804d17b:	85 c0                	test   %eax,%eax
 804d17d:	74 08                	je     804d187 <z_add_timeout+0x147>
 804d17f:	39 05 70 28 05 08    	cmp    %eax,0x8052870
 804d185:	74 0d                	je     804d194 <z_add_timeout+0x154>
			    _current_cpu->slice_ticks != next_time) {
				sys_clock_set_timeout(next_time, false);
 804d187:	52                   	push   %edx
 804d188:	52                   	push   %edx
 804d189:	6a 00                	push   $0x0
 804d18b:	50                   	push   %eax
 804d18c:	e8 ac f2 ff ff       	call   804c43d <sys_clock_set_timeout>
 804d191:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804d194:	89 7d 08             	mov    %edi,0x8(%ebp)
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
 804d197:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d19a:	5b                   	pop    %ebx
 804d19b:	5e                   	pop    %esi
 804d19c:	5f                   	pop    %edi
 804d19d:	5d                   	pop    %ebp
 804d19e:	e9 af e2 ff ff       	jmp    804b452 <posix_irq_unlock>
 804d1a3:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d1a6:	5b                   	pop    %ebx
 804d1a7:	5e                   	pop    %esi
 804d1a8:	5f                   	pop    %edi
 804d1a9:	5d                   	pop    %ebp
 804d1aa:	c3                   	ret    

0804d1ab <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
 804d1ab:	f3 0f 1e fb          	endbr32 
 804d1af:	55                   	push   %ebp
 804d1b0:	89 e5                	mov    %esp,%ebp
 804d1b2:	53                   	push   %ebx
 804d1b3:	83 ec 14             	sub    $0x14,%esp
	return posix_irq_lock();
 804d1b6:	e8 81 e2 ff ff       	call   804b43c <posix_irq_lock>
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
 804d1bb:	8b 55 08             	mov    0x8(%ebp),%edx
 804d1be:	89 c3                	mov    %eax,%ebx
	return node->next != NULL;
 804d1c0:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
 804d1c5:	83 3a 00             	cmpl   $0x0,(%edx)
 804d1c8:	74 09                	je     804d1d3 <z_abort_timeout+0x28>
			remove_timeout(to);
 804d1ca:	89 d0                	mov    %edx,%eax
 804d1cc:	e8 d5 fd ff ff       	call   804cfa6 <remove_timeout>
			ret = 0;
 804d1d1:	31 c0                	xor    %eax,%eax
	posix_irq_unlock(key);
 804d1d3:	83 ec 0c             	sub    $0xc,%esp
 804d1d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804d1d9:	53                   	push   %ebx
 804d1da:	e8 73 e2 ff ff       	call   804b452 <posix_irq_unlock>
		}
	}

	return ret;
}
 804d1df:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d1e2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804d1e5:	83 c4 10             	add    $0x10,%esp
 804d1e8:	c9                   	leave  
 804d1e9:	c3                   	ret    

0804d1ea <z_set_timeout_expiry>:
	}
	return ret;
}

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
 804d1ea:	f3 0f 1e fb          	endbr32 
 804d1ee:	55                   	push   %ebp
 804d1ef:	89 e5                	mov    %esp,%ebp
 804d1f1:	57                   	push   %edi
 804d1f2:	56                   	push   %esi
 804d1f3:	53                   	push   %ebx
 804d1f4:	83 ec 0c             	sub    $0xc,%esp
 804d1f7:	8b 75 08             	mov    0x8(%ebp),%esi
 804d1fa:	8b 7d 0c             	mov    0xc(%ebp),%edi
	return posix_irq_lock();
 804d1fd:	e8 3a e2 ff ff       	call   804b43c <posix_irq_lock>
 804d202:	89 c3                	mov    %eax,%ebx
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
 804d204:	e8 d7 fd ff ff       	call   804cfe0 <next_timeout>
		bool sooner = (next_to == K_TICKS_FOREVER)
 804d209:	83 f8 ff             	cmp    $0xffffffff,%eax
 804d20c:	0f 94 c1             	sete   %cl
			      || (ticks <= next_to);
 804d20f:	39 f0                	cmp    %esi,%eax
 804d211:	0f 9d c2             	setge  %dl
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
 804d214:	08 d1                	or     %dl,%cl
 804d216:	74 1b                	je     804d233 <z_set_timeout_expiry+0x49>
 804d218:	83 f8 01             	cmp    $0x1,%eax
 804d21b:	7e 16                	jle    804d233 <z_set_timeout_expiry+0x49>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
 804d21d:	39 f0                	cmp    %esi,%eax
 804d21f:	52                   	push   %edx
 804d220:	0f 4f c6             	cmovg  %esi,%eax
 804d223:	52                   	push   %edx
 804d224:	89 fa                	mov    %edi,%edx
 804d226:	0f b6 fa             	movzbl %dl,%edi
 804d229:	57                   	push   %edi
 804d22a:	50                   	push   %eax
 804d22b:	e8 0d f2 ff ff       	call   804c43d <sys_clock_set_timeout>
 804d230:	83 c4 10             	add    $0x10,%esp
	posix_irq_unlock(key);
 804d233:	89 5d 08             	mov    %ebx,0x8(%ebp)
		}
	}
}
 804d236:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d239:	5b                   	pop    %ebx
 804d23a:	5e                   	pop    %esi
 804d23b:	5f                   	pop    %edi
 804d23c:	5d                   	pop    %ebp
 804d23d:	e9 10 e2 ff ff       	jmp    804b452 <posix_irq_unlock>

0804d242 <sys_clock_announce>:

void sys_clock_announce(int32_t ticks)
{
 804d242:	f3 0f 1e fb          	endbr32 
 804d246:	55                   	push   %ebp
 804d247:	89 e5                	mov    %esp,%ebp
 804d249:	57                   	push   %edi
 804d24a:	56                   	push   %esi
 804d24b:	53                   	push   %ebx
 804d24c:	83 ec 28             	sub    $0x28,%esp
 804d24f:	8b 5d 08             	mov    0x8(%ebp),%ebx
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
 804d252:	53                   	push   %ebx
 804d253:	e8 03 f8 ff ff       	call   804ca5b <z_time_slice>
 804d258:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
 804d25b:	e8 dc e1 ff ff       	call   804b43c <posix_irq_lock>
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
 804d260:	89 1d 98 29 05 08    	mov    %ebx,0x8052998
 804d266:	89 c7                	mov    %eax,%edi
	return list->head == list;
 804d268:	a1 20 29 05 08       	mov    0x8052920,%eax
 804d26d:	8b 15 24 29 05 08    	mov    0x8052924,%edx
 804d273:	8b 1d 88 12 05 08    	mov    0x8051288,%ebx
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
 804d279:	8b 35 98 29 05 08    	mov    0x8052998,%esi
 804d27f:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804d282:	89 55 e4             	mov    %edx,-0x1c(%ebp)

	while (first() != NULL && first()->dticks <= announce_remaining) {
 804d285:	85 db                	test   %ebx,%ebx
 804d287:	74 7d                	je     804d306 <sys_clock_announce+0xc4>
 804d289:	81 fb 88 12 05 08    	cmp    $0x8051288,%ebx
 804d28f:	74 75                	je     804d306 <sys_clock_announce+0xc4>
 804d291:	89 f1                	mov    %esi,%ecx
 804d293:	8b 43 0c             	mov    0xc(%ebx),%eax
 804d296:	8b 53 10             	mov    0x10(%ebx),%edx
 804d299:	89 75 d8             	mov    %esi,-0x28(%ebp)
 804d29c:	c1 f9 1f             	sar    $0x1f,%ecx
 804d29f:	89 4d dc             	mov    %ecx,-0x24(%ebp)
 804d2a2:	8b 4d dc             	mov    -0x24(%ebp),%ecx
 804d2a5:	39 c6                	cmp    %eax,%esi
 804d2a7:	19 d1                	sbb    %edx,%ecx
 804d2a9:	7c 4f                	jl     804d2fa <sys_clock_announce+0xb8>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
		announce_remaining -= dt;
		t->dticks = 0;
 804d2ab:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
		int dt = t->dticks;
 804d2b2:	89 c1                	mov    %eax,%ecx
		curr_tick += dt;
 804d2b4:	99                   	cltd   
 804d2b5:	03 45 e0             	add    -0x20(%ebp),%eax
		t->dticks = 0;
 804d2b8:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
		curr_tick += dt;
 804d2bf:	13 55 e4             	adc    -0x1c(%ebp),%edx
		announce_remaining -= dt;
 804d2c2:	29 ce                	sub    %ecx,%esi
		curr_tick += dt;
 804d2c4:	a3 20 29 05 08       	mov    %eax,0x8052920
		remove_timeout(t);
 804d2c9:	89 d8                	mov    %ebx,%eax
		curr_tick += dt;
 804d2cb:	89 15 24 29 05 08    	mov    %edx,0x8052924
		announce_remaining -= dt;
 804d2d1:	89 35 98 29 05 08    	mov    %esi,0x8052998
		remove_timeout(t);
 804d2d7:	e8 ca fc ff ff       	call   804cfa6 <remove_timeout>
	posix_irq_unlock(key);
 804d2dc:	83 ec 0c             	sub    $0xc,%esp
 804d2df:	57                   	push   %edi
 804d2e0:	e8 6d e1 ff ff       	call   804b452 <posix_irq_unlock>

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
 804d2e5:	89 1c 24             	mov    %ebx,(%esp)
 804d2e8:	ff 53 08             	call   *0x8(%ebx)
 804d2eb:	83 c4 10             	add    $0x10,%esp
	return posix_irq_lock();
 804d2ee:	e8 49 e1 ff ff       	call   804b43c <posix_irq_lock>
 804d2f3:	89 c7                	mov    %eax,%edi
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
 804d2f5:	e9 6e ff ff ff       	jmp    804d268 <sys_clock_announce+0x26>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
 804d2fa:	2b 45 d8             	sub    -0x28(%ebp),%eax
 804d2fd:	1b 55 dc             	sbb    -0x24(%ebp),%edx
 804d300:	89 43 0c             	mov    %eax,0xc(%ebx)
 804d303:	89 53 10             	mov    %edx,0x10(%ebx)
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
 804d306:	c7 05 98 29 05 08 00 	movl   $0x0,0x8052998
 804d30d:	00 00 00 
	curr_tick += announce_remaining;
 804d310:	89 f0                	mov    %esi,%eax
 804d312:	99                   	cltd   
 804d313:	03 45 e0             	add    -0x20(%ebp),%eax
 804d316:	13 55 e4             	adc    -0x1c(%ebp),%edx
 804d319:	89 15 24 29 05 08    	mov    %edx,0x8052924
 804d31f:	a3 20 29 05 08       	mov    %eax,0x8052920

	sys_clock_set_timeout(next_timeout(), false);
 804d324:	e8 b7 fc ff ff       	call   804cfe0 <next_timeout>
 804d329:	52                   	push   %edx
 804d32a:	52                   	push   %edx
 804d32b:	6a 00                	push   $0x0
 804d32d:	50                   	push   %eax
 804d32e:	e8 0a f1 ff ff       	call   804c43d <sys_clock_set_timeout>
	posix_irq_unlock(key);
 804d333:	89 7d 08             	mov    %edi,0x8(%ebp)
 804d336:	83 c4 10             	add    $0x10,%esp

	k_spin_unlock(&timeout_lock, key);
}
 804d339:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d33c:	5b                   	pop    %ebx
 804d33d:	5e                   	pop    %esi
 804d33e:	5f                   	pop    %edi
 804d33f:	5d                   	pop    %ebp
 804d340:	e9 0d e1 ff ff       	jmp    804b452 <posix_irq_unlock>

0804d345 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
 804d345:	f3 0f 1e fb          	endbr32 
 804d349:	55                   	push   %ebp
 804d34a:	89 e5                	mov    %esp,%ebp
 804d34c:	57                   	push   %edi
 804d34d:	83 ec 14             	sub    $0x14,%esp
	return posix_irq_lock();
 804d350:	e8 e7 e0 ff ff       	call   804b43c <posix_irq_lock>
 804d355:	89 c7                	mov    %eax,%edi
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + sys_clock_elapsed();
 804d357:	e8 16 f1 ff ff       	call   804c472 <sys_clock_elapsed>
 804d35c:	31 d2                	xor    %edx,%edx
 804d35e:	03 05 20 29 05 08    	add    0x8052920,%eax
 804d364:	13 15 24 29 05 08    	adc    0x8052924,%edx
	posix_irq_unlock(key);
 804d36a:	83 ec 0c             	sub    $0xc,%esp
 804d36d:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804d370:	57                   	push   %edi
 804d371:	89 55 f4             	mov    %edx,-0xc(%ebp)
 804d374:	e8 d9 e0 ff ff       	call   804b452 <posix_irq_unlock>
	}
	return t;
}
 804d379:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804d37c:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804d37f:	83 c4 10             	add    $0x10,%esp
 804d382:	8b 7d fc             	mov    -0x4(%ebp),%edi
 804d385:	c9                   	leave  
 804d386:	c3                   	ret    

0804d387 <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
 804d387:	f3 0f 1e fb          	endbr32 
 804d38b:	55                   	push   %ebp
 804d38c:	89 e5                	mov    %esp,%ebp
 804d38e:	83 ec 08             	sub    $0x8,%esp
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
 804d391:	e8 af ff ff ff       	call   804d345 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
 804d396:	c9                   	leave  
 804d397:	c3                   	ret    

0804d398 <z_impl_k_busy_wait>:
}
#include <syscalls/k_uptime_ticks_mrsh.c>
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
 804d398:	f3 0f 1e fb          	endbr32 
 804d39c:	55                   	push   %ebp
 804d39d:	89 e5                	mov    %esp,%ebp
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
 804d39f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d3a3:	74 06                	je     804d3ab <z_impl_k_busy_wait+0x13>
	}
#else
	arch_busy_wait(usec_to_wait);
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
 804d3a5:	5d                   	pop    %ebp
	arch_busy_wait(usec_to_wait);
 804d3a6:	e9 40 ee ff ff       	jmp    804c1eb <arch_busy_wait>
}
 804d3ab:	5d                   	pop    %ebp
 804d3ac:	c3                   	ret    

0804d3ad <boot_banner>:
#define BOOT_DELAY_BANNER ""
#endif

#if defined(CONFIG_BOOT_DELAY) || CONFIG_BOOT_DELAY > 0
void boot_banner(void)
{
 804d3ad:	f3 0f 1e fb          	endbr32 
 804d3b1:	55                   	push   %ebp
 804d3b2:	89 e5                	mov    %esp,%ebp
 804d3b4:	83 ec 0c             	sub    $0xc,%esp
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
 804d3b7:	68 cc ec 04 08       	push   $0x804eccc
 804d3bc:	68 cc ec 04 08       	push   $0x804eccc
 804d3c1:	68 48 ee 04 08       	push   $0x804ee48
 804d3c6:	e8 2c c4 ff ff       	call   80497f7 <printk>
 804d3cb:	83 c4 10             	add    $0x10,%esp
#else
	printk("*** Booting Zephyr OS version %s %s ***\n",
	       KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif
}
 804d3ce:	c9                   	leave  
 804d3cf:	c3                   	ret    

0804d3d0 <z_device_state_init>:
 *
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
 804d3d0:	f3 0f 1e fb          	endbr32 

	while (dev < __device_end) {
		z_object_init(dev);
		++dev;
	}
}
 804d3d4:	c3                   	ret    

0804d3d5 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
 804d3d5:	f3 0f 1e fb          	endbr32 
 804d3d9:	55                   	push   %ebp
 804d3da:	89 e5                	mov    %esp,%ebp
 804d3dc:	57                   	push   %edi
 804d3dd:	56                   	push   %esi
 804d3de:	53                   	push   %ebx
 804d3df:	83 ec 0c             	sub    $0xc,%esp
 804d3e2:	8b 5d 08             	mov    0x8(%ebp),%ebx
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 804d3e5:	8b 34 9d 50 e1 04 08 	mov    0x804e150(,%ebx,4),%esi
 804d3ec:	39 34 9d 54 e1 04 08 	cmp    %esi,0x804e154(,%ebx,4)
 804d3f3:	76 38                	jbe    804d42d <z_sys_init_run_level+0x58>
		const struct device *dev = entry->dev;
 804d3f5:	8b 7e 04             	mov    0x4(%esi),%edi
		int rc = entry->init(dev);
 804d3f8:	83 ec 0c             	sub    $0xc,%esp
 804d3fb:	57                   	push   %edi
 804d3fc:	ff 16                	call   *(%esi)
 804d3fe:	83 c4 10             	add    $0x10,%esp

		if (dev != NULL) {
 804d401:	85 ff                	test   %edi,%edi
 804d403:	74 23                	je     804d428 <z_sys_init_run_level+0x53>
			/* Mark device initialized.  If initialization
			 * failed, record the error condition.
			 */
			if (rc != 0) {
 804d405:	8b 57 0c             	mov    0xc(%edi),%edx
 804d408:	85 c0                	test   %eax,%eax
 804d40a:	74 18                	je     804d424 <z_sys_init_run_level+0x4f>
				if (rc < 0) {
 804d40c:	89 c1                	mov    %eax,%ecx
 804d40e:	c1 f9 1f             	sar    $0x1f,%ecx
 804d411:	31 c8                	xor    %ecx,%eax
 804d413:	29 c8                	sub    %ecx,%eax
					rc = -rc;
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
 804d415:	b9 ff 00 00 00       	mov    $0xff,%ecx
 804d41a:	3d ff 00 00 00       	cmp    $0xff,%eax
 804d41f:	0f 4f c1             	cmovg  %ecx,%eax
 804d422:	88 02                	mov    %al,(%edx)
			}
			dev->state->initialized = true;
 804d424:	80 4a 01 01          	orb    $0x1,0x1(%edx)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 804d428:	83 c6 08             	add    $0x8,%esi
 804d42b:	eb bf                	jmp    804d3ec <z_sys_init_run_level+0x17>
		}
	}
}
 804d42d:	8d 65 f4             	lea    -0xc(%ebp),%esp
 804d430:	5b                   	pop    %ebx
 804d431:	5e                   	pop    %esi
 804d432:	5f                   	pop    %edi
 804d433:	5d                   	pop    %ebp
 804d434:	c3                   	ret    

0804d435 <_OffsetAbsSyms>:
/*
 * The final link step uses the symbol _OffsetAbsSyms to force the linkage of
 * offsets.o into the ELF image.
 */

GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
 804d435:	f3 0f 1e fb          	endbr32 

#if defined(CONFIG_FPU_SHARING)
GEN_OFFSET_SYM(_thread_arch_t, excNestCount);
#endif

GEN_ABS_SYM_END
 804d439:	c3                   	ret    

0804d43a <__x86.get_pc_thunk.bp>:
 804d43a:	8b 2c 24             	mov    (%esp),%ebp
 804d43d:	c3                   	ret    

Disassembly of section .fini:

0804d440 <_fini>:
 804d440:	f3 0f 1e fb          	endbr32 
 804d444:	53                   	push   %ebx
 804d445:	83 ec 08             	sub    $0x8,%esp
 804d448:	e8 63 c1 ff ff       	call   80495b0 <__x86.get_pc_thunk.bx>
 804d44d:	81 c3 b3 3b 00 00    	add    $0x3bb3,%ebx
 804d453:	83 c4 08             	add    $0x8,%esp
 804d456:	5b                   	pop    %ebx
 804d457:	c3                   	ret    
